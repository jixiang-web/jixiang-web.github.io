<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1、你管这破玩意叫 IO 多路复用？https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;3gC-nUnFGv-eoSBsEdSZuA select服务端代码，这样来写。 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。 select 是操作系统提供的系统调">
<meta property="og:type" content="article">
<meta property="og:title" content="面试基础">
<meta property="og:url" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、你管这破玩意叫 IO 多路复用？https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;3gC-nUnFGv-eoSBsEdSZuA select服务端代码，这样来写。 首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。 select 是操作系统提供的系统调">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151421258.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151742332.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151851896.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327080529220.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327084224462.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327084448870.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210607140141421.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210607140235900.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/笔记/java/SpringCloud/image-20210615214231974.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210615214519618.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327172654537.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328144344935.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328152357109.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328232348020.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328233017427.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328235959004.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329001222507.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329003753420.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010037509.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010459631.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010930419.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329101938780.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329104752874.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419134131564.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329113741836.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329120200913.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329122319380.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329005646972.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329005619956.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329132425707.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329135510767.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210416170117304.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210330085519793.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419092002255.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419095313348.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419102956614.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419103324274.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419103345018.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419104618554.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105134581.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105252980.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105508529.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408171612061.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408172025628.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419101627226.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419101928970.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422210840955.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422213026119.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422213540264.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215617327.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215850565.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215941606.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422220813121.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422221723963.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422225831090.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422230012098.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422231316848.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422235046738.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422234654060.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422234902879.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423153747460.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423153917512.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423171454116.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/threadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210613204612552.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521153308427.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521160457471.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210613210924869.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132047143.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132207741.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132329986.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132850592.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419133117549.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144100174.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144302599.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144720889.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144640940.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421161341573.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421161851846.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421173613994.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421174031846.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421175635747.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422123109167.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422121110896.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422121544516.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122327692.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122720437.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122909784.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422124345574.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422124406141.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422125116192.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422125825477.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422130233619.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422131038527.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422131254856.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140026740.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140613390.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140905552.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422143707735.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144148409.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144309260.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144653939.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144706794.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144907890.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144942473.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422145011160.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422145642192.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422151428111.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422204842558.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408234411875.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3String-Pool-Java1-450x249.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25178350.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10317146.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/b48228c2-ac00-4668-a78f-6f221f8563b5.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11034259.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/72762049.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801144758528.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422180734009.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422181023674.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521110443084.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422170256672.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422170916735.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521115128603.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521120726613.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521121152984.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521121806753.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521122411638.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521141713835.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190039560.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190523421.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422172222211.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521143731489.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521143152127.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521144952344.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521145400914.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422175123464.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422175400373.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422180219119.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190844163.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192719091.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192819513.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192956109.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193112324.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193252893.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193415068.png">
<meta property="og:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521175630355.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/factory-1.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png">
<meta property="article:published_time" content="2022-05-09T07:27:29.000Z">
<meta property="article:modified_time" content="2022-05-09T07:04:43.887Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151421258.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-工作面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2022-05-09T07:27:29.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1、你管这破玩意叫-IO-多路复用？"><a href="#1、你管这破玩意叫-IO-多路复用？" class="headerlink" title="1、你管这破玩意叫 IO 多路复用？"></a>1、你管这破玩意叫 IO 多路复用？</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA">https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA</a></p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p>
<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<p>可以看出几个细节：</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）<img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151421258.png" alt="image-20210801151421258"></p>
</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h3><p>poll 也是操作系统提供的系统调用函数。</p>
<p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h3><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151742332.png" alt="image-20210801151742332"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801151851896.png" alt="image-20210801151851896"></p>
<p><strong>重要的事情再说一遍： I&#x2F;O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I&#x2F;O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I&#x2F;O流</strong>.</p>
<h2 id="2、请谈一谈，系统如何提高并发性？"><a href="#2、请谈一谈，系统如何提高并发性？" class="headerlink" title="2、请谈一谈，系统如何提高并发性？"></a>2、请谈一谈，系统如何提高并发性？</h2><p>考察：操作系统综合性</p>
<h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、提高CPU并发计算能力</p>
<p>（1）多进程&amp;多线程</p>
<p>（2）减少进程切换，使用线程，考虑进程绑定CPU</p>
<p>（3）减少使用不必要的锁，考虑无锁编程</p>
<p>（4）考虑进程优先级</p>
<p>（5）关注系统负载</p>
<p>2、改进I&#x2F;O模型</p>
<p>(1)DMA技术</p>
<p>(2)异步I&#x2F;O</p>
<p>(3)改进多路I&#x2F;O就绪通知策略，epoll</p>
<p>(4)Sendfile</p>
<p>(5)内存映射</p>
<p>(6)直接I&#x2F;O</p>
<h2 id="3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？"><a href="#3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？" class="headerlink" title="3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？"></a>3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？</h2><p>考察点：死锁</p>
<h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。</p>
<p>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持 不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。</p>
<p>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。</p>
<p>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。</p>
<h2 id="4、介绍一下，什么是hashmap"><a href="#4、介绍一下，什么是hashmap" class="headerlink" title="4、介绍一下，什么是hashmap?"></a>4、介绍一下，什么是hashmap?</h2><p>考察点：哈希表</p>
<h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<p>hashmap共有4个构造函数：</p>
<p>&#x2F;&#x2F; 默认构造函数。HashMap()</p>
<p>&#x2F;&#x2F; 指定“容量大小”的构造函数</p>
<p>HashMap(int capacity)</p>
<p>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</p>
<p>HashMap(int capacity, float loadFactor)</p>
<p>&#x2F;&#x2F; 包含“子Map”的构造函数</p>
<p>HashMap(Map&lt;? extends K, ? extends V&gt; map)</p>
<p>HashMap控制数组长度为2的整数次幂，好处是对hashcode进行求余运算和让hashcode与数组长度-1进行位与运算是相同的效果。</p>
<p><strong>小结</strong></p>
<ol>
<li>HashMap通过高16位与低16位进行异或运算来让高位参与散列，提高散列效果；</li>
<li>HashMap控制数组的长度为2的整数次幂来简化取模运算，提高性能；</li>
<li>HashMap通过控制初始化的数组长度为2的整数次幂、扩容为原来的2倍来控制数组长度一定为2的整数次幂。</li>
</ol>
<p><strong>小结</strong></p>
<ol>
<li>HashMap采用链地址法，当发生冲突时会转化为链表，当链表过长会转化为红黑树提高效率。</li>
<li>HashMap对红黑树进行了限制，让红黑树只有在极少数极端情况下进行抗压。</li>
</ol>
<p>关于红黑树的转化，HashMap做了以下限制。</p>
<ul>
<li>当链表的长度&gt;&#x3D;8且数组长度&gt;&#x3D;64时，会把链表转化成红黑树。</li>
<li>当链表长度&gt;&#x3D;8，但数组长度&lt;64时，会优先进行扩容，而不是转化成红黑树。</li>
<li>当红黑树节点数&lt;&#x3D;6，自动转化成链表。</li>
</ul>
<h4 id="jdk1-7及以前扩容时采用的是头插法，这种方式插入速度快，但在多线程环境下会造成链表环，而链表环会在下一次插入时找不到链表尾而发生死循环。"><a href="#jdk1-7及以前扩容时采用的是头插法，这种方式插入速度快，但在多线程环境下会造成链表环，而链表环会在下一次插入时找不到链表尾而发生死循环。" class="headerlink" title="jdk1.7及以前扩容时采用的是头插法，这种方式插入速度快，但在多线程环境下会造成链表环，而链表环会在下一次插入时找不到链表尾而发生死循环。"></a>jdk1.7及以前扩容时采用的是头插法，这种方式插入速度快，但在多线程环境下会造成链表环，而链表环会在下一次插入时找不到链表尾而发生死循环。</h4><p>那如果结果数据一致性问题呢？解决这个问题有三个方案：</p>
<ul>
<li>采用Hashtable</li>
<li>调用Collections.synchronizeMap()方法来让HashMap具有多线程能力</li>
<li>采用ConcurrentHashMap</li>
</ul>
<p>ConcurrentHashMap的设计就是为了解决此问题。他通过降低锁粒度+CAS的方式来提高效率。简单来说，ConcurrentHashMap锁的并不是整个对象，而是一个数组的一个节点，那么其他线程访问数组其他节点是不会互相影响，极大提高了并发效率；同时ConcurrentHashMap读操作并不需要获取锁</p>
<p>所以ConcurrentHashMap类或者Collections.synchronizeMap()方法或者Hashtable都只能在一定的限度上保证线程安全，而无法保证绝对线程安全。</p>
<p>HashMap1.8采用尾插法进行扩容，防止出现链表环导致的死循环问题</p>
<h2 id="5、现在有十万个单词，请你找出重复次数最多的十个。"><a href="#5、现在有十万个单词，请你找出重复次数最多的十个。" class="headerlink" title="5、现在有十万个单词，请你找出重复次数最多的十个。"></a>5、现在有十万个单词，请你找出重复次数最多的十个。</h2><p>文件太大的话，先对存单词的文件进行分流，这里是十个，那就分成十份，分流采用hash，这样相同的单词必然是分到同一台机器上，然后分别统计每一台机器上每个单词出现的次数并分别排序，这样就有了每一台机器上单词出现次数的有序列表。剩下的就是算法了，大家有没有做过一个算法题，N个排好序的数组，求这N个数组中最大的N个数？思路是先建一个大小为N的大顶堆，堆中的元素是这N个数组中的最大值，也就是每个数组的最右边（或者最左边，看排序方式）的值，那么堆顶的元素必然是所有数组中最大的那个，取出来存着，然后这个最大值来自哪个数组，将这个数组的次大值拿来放入堆中，重新调整，然后继续将堆顶元素取出，看堆顶元素属于哪个数组，取其次大值，放入堆中继续调整……..如此循环，取出N个数后，停止。最后就得到了最大的N个数，套到这个题目来就是出现次数最多的单词的次数，对应的单词是什么设计数组结构的时候存一下就行了。</p>
<h2 id="6、现在，有一个组合索引（A-B-C），可以有哪几种查询方式？"><a href="#6、现在，有一个组合索引（A-B-C），可以有哪几种查询方式？" class="headerlink" title="6、现在，有一个组合索引（A,B,C），可以有哪几种查询方式？"></a>6、现在，有一个组合索引（A,B,C），可以有哪几种查询方式？</h2><p>优: select * from test order by a</p>
<p>差: select * from test order by b</p>
<p>差: select * from test order by c</p>
<p>怎么看出优差之分？</p>
<p>​	</p>
<p>MySql索引底层采用B+树的数据结构，仅在叶子节点存储数据，并且从左到右串联起来便于范围查询。这样的结构导致复合索引的查询符合“最左原则”，也就是当建立（a,b,c）复合索引时，查询条件中必须有a才能走索引，a,ab,ac,abc均;但是b,bc,c都不能走索引。</p>
<h2 id="7、请你讲解一下数据连接池的工作机制"><a href="#7、请你讲解一下数据连接池的工作机制" class="headerlink" title="7、请你讲解一下数据连接池的工作机制?"></a>7、请你讲解一下数据连接池的工作机制?</h2><p>考察点：连接池</p>
<h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<h2 id="8、请介绍一些你了解的数据库优化方法"><a href="#8、请介绍一些你了解的数据库优化方法" class="headerlink" title="8、请介绍一些你了解的数据库优化方法"></a>8、请介绍一些你了解的数据库优化方法</h2><p>考察点：数据库</p>
<h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>（1）选取最适用的字段属性</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>（2）使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询</p>
<p>（3）使用联合(UNION)来代替手动创建的临时表</p>
<p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p>
<p>（4）事务</p>
<p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p>
<h2 id="9、-讲一讲，数据库ACID的特性。"><a href="#9、-讲一讲，数据库ACID的特性。" class="headerlink" title="9、 讲一讲，数据库ACID的特性。"></a>9、 讲一讲，数据库ACID的特性。</h2><p>考察点：数据库</p>
<h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性指事务前后数据的完整性必须保持一致。</p>
<p>隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离。</p>
<p>持久性是指一个事务一旦提交，它对数据库中数据的改变就是永久性的，即便数据库发生故障也不应该对其有任何影响。</p>
<h2 id="10、请你介绍一下，数据库乐观锁和悲观锁"><a href="#10、请你介绍一下，数据库乐观锁和悲观锁" class="headerlink" title="10、请你介绍一下，数据库乐观锁和悲观锁"></a>10、请你介绍一下，数据库乐观锁和悲观锁</h2><p>考察点：数据库</p>
<h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>悲观锁</p>
<p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<p>乐观锁</p>
<p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>乐观锁一般来说有以下2种方式：</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<p>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>
<h2 id="11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效"><a href="#11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效" class="headerlink" title="11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效"></a>11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效</h2><p>考察点：数据库索引</p>
<h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>B+树实现的。</p>
<p>没有遵循最左匹配原则。</p>
<p>一些关键字会导致索引失效，例如 or， ！&#x3D; ， not in，is null ,is not unll</p>
<p>like查询是以%开头</p>
<p>隐式转换会导致索引失效。</p>
<p>对索引应用内部函数，索引字段进行了运算。</p>
<h2 id="12、-请你说一说，mysql数据库的两种引擎-区别"><a href="#12、-请你说一说，mysql数据库的两种引擎-区别" class="headerlink" title="12、 请你说一说，mysql数据库的两种引擎 区别"></a>12、 请你说一说，mysql数据库的两种引擎 区别</h2><p>考察点：数据库存储引擎</p>
<h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>InnoDB是聚集索引，支持事务，支持行级锁；MyISAM是非聚集索引，不支持事务，只支持表级锁。</p>
<h2 id="13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。"><a href="#13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。" class="headerlink" title="13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。"></a>13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。</h2><p>考察点：数据库</p>
<h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>存储引擎</p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。InnoDB主要面向在线事务处理（OLTP）的应用。MyISAM主要面向一些OLAP（联机分析处理）的应用。</p>
<h2 id="14、请你讲讲-Statement-和-PreparedStatement-的区别？哪个性能更好？"><a href="#14、请你讲讲-Statement-和-PreparedStatement-的区别？哪个性能更好？" class="headerlink" title="14、请你讲讲 Statement 和 PreparedStatement 的区别？哪个性能更好？"></a>14、请你讲讲 Statement 和 PreparedStatement 的区别？哪个性能更好？</h2><p>考察点：Statement</p>
<h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<p>为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
<h2 id="15、-请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"><a href="#15、-请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？" class="headerlink" title="15、 请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"></a>15、 请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？</h2><p>考察点：servlet</p>
<h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<p>Servlet 通过调用 init () 方法进行初始化。</p>
<p>Servlet 调用 service() 方法来处理客户端的请求。</p>
<p>Servlet 通过调用 destroy() 方法终止（结束）。</p>
<p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>
<p>Servlet单实例，减少了产生servlet的开销；</p>
<h2 id="16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？</h2><p>考察点：控制反转</p>
<h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h2 id="17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"><a href="#17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？" class="headerlink" title="17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"></a>17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？</h2><p>考察点：spring</p>
<h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>①IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</p>
<p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>举个简单的例子，我们找女朋友常见的情况是，我们到处去看哪里有长得漂亮身材又好的女孩子，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
<p>②实现IOC的步骤</p>
<p>定义用来描述bean的配置的Java类</p>
<p>解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术</p>
<p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可</p>
<h1 id="18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired-和resource区别是什么？"><a href="#18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired-和resource区别是什么？" class="headerlink" title="18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired 和resource区别是什么？"></a>18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired 和resource区别是什么？</h1><p>考察点：Spring</p>
<h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、共同点</p>
<p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<p>2、不同点</p>
<p>（1）@Autowired</p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p>
<p>（2）@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h1 id="19、请问AOP的原理是什么？"><a href="#19、请问AOP的原理是什么？" class="headerlink" title="19、请问AOP的原理是什么？"></a>19、请问AOP的原理是什么？</h1><p>考察点：动态代理</p>
<h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>AOP（Aspect Orient Programming），指面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<h1 id="20、请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？"><a href="#20、请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？" class="headerlink" title="20、请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？"></a>20、请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</h1><p>考察点：锁机制</p>
<h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>主要相同点：Lock能完成synchronized所实现的所有功能<br>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<h1 id="21-请说明一下锁和同步的区别。"><a href="#21-请说明一下锁和同步的区别。" class="headerlink" title="21 请说明一下锁和同步的区别。"></a>21 请说明一下锁和同步的区别。</h1><p>考察点：锁</p>
<h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>用法上的不同：<br>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br>synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br>性能上的不同：<br>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。<br>锁机制不同：<br>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。</p>
<h1 id="22、请说明一下synchronized的可重入怎么实现。"><a href="#22、请说明一下synchronized的可重入怎么实现。" class="headerlink" title="22、请说明一下synchronized的可重入怎么实现。"></a>22、请说明一下synchronized的可重入怎么实现。</h1><p>考察点：锁</p>
<h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法&#x2F;块时，计数器会递减，如果计数器为0则释放该锁。</p>
<h1 id="23、-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"><a href="#23、-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。" class="headerlink" title="23、 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"></a>23、 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。</h1><p>考察点：锁</p>
<h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>如果一个锁是公平的，那么锁的获取顺序就应4该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<h2 id="24、GC中如何判断对象是否需要被回收？"><a href="#24、GC中如何判断对象是否需要被回收？" class="headerlink" title="24、GC中如何判断对象是否需要被回收？"></a>24、GC中如何判断对象是否需要被回收？</h2><p>考察点：JAVA虚拟机</p>
<h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>即使在可达性分析算法中不可达的对象,也并非是“非回收不可”的,这时候它们暂时处于“等待”阶段,要真正宣告一个对象回收,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</p>
<p>如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。</p>
<p>finalize()方法是对象逃脱回收的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中跳出回收——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。</p>
<h1 id="25-、假设一个场景，要求stop-the-world时间非常短，你会怎么设计垃圾回收机制？"><a href="#25-、假设一个场景，要求stop-the-world时间非常短，你会怎么设计垃圾回收机制？" class="headerlink" title="25 、假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？"></a>25 、假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？</h1><p>绝大多数新创建的对象分配在Eden区。</p>
<p>在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。</p>
<p>在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。</p>
<p>一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。</p>
<p>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p>
<h1 id="26、-请说明一下eden区和survial区的含义以及工作原理？"><a href="#26、-请说明一下eden区和survial区的含义以及工作原理？" class="headerlink" title="26、 请说明一下eden区和survial区的含义以及工作原理？"></a>26、 请说明一下eden区和survial区的含义以及工作原理？</h1><p>考察点：JVM</p>
<h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。</p>
<p>我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；<br>2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p>
<h1 id="27、-请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？"><a href="#27、-请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？" class="headerlink" title="27、 请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？"></a>27、 请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？</h1><p>考察点：JVM</p>
<h3 id="参考回答：-22"><a href="#参考回答：-22" class="headerlink" title="参考回答："></a>参考回答：</h3><p>垃圾回收算法</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p>
<p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<h3 id="增量算法"><a href="#增量算法" class="headerlink" title="增量算法"></a>增量算法</h3><p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="[3.4 分代收集算法"></a>[3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>
<p>根据上面的对分代收集算法的介绍回答。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。</p>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p>
<p>通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。</p>
<p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<p>-UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p>-UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：</p>
<p>初始标记(initial mark)</p>
<p>并发标记(concurrent mark)</p>
<p>重新标记(remark)</p>
<p>并发清除(concurrent sweep)</p>
<p>注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。</p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS 垃圾收集器 "></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="[4.7 G1 收集器"></a>[4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p>
<p>G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<p>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</p>
<p>分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。</p>
<p>空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。</p>
<p>可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<h3 id="CMS：采用标记清除算法"><a href="#CMS：采用标记清除算法" class="headerlink" title="CMS：采用标记清除算法"></a>CMS：采用标记清除算法</h3><p>解决这个问题的办法就是可以让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，CMS提供了以下参数来控制：</p>
<p>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction&#x3D;5</p>
<p>也就是CMS在进行5次Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。</p>
<h1 id="28、-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下"><a href="#28、-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下" class="headerlink" title="28、 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下"></a>28、 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下</h1><p>考察点：GC</p>
<h3 id="参考回答：-23"><a href="#参考回答：-23" class="headerlink" title="参考回答："></a>参考回答：</h3><p>可能是堆内存太小。</p>
<h1 id="29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"><a href="#29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？" class="headerlink" title="29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"></a>29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？</h1><h2 id="考察点：内存泄漏"><a href="#考察点：内存泄漏" class="headerlink" title="考察点：内存泄漏"></a>考察点：内存泄漏</h2><h3 id="参考回答：-24"><a href="#参考回答：-24" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</p>
<h1 id="30、进程间常用的通信方式有哪些"><a href="#30、进程间常用的通信方式有哪些" class="headerlink" title="30、进程间常用的通信方式有哪些"></a>30、进程间常用的通信方式有哪些</h1><ol>
<li><p><strong>管道&#x2F;匿名管道(Pipes)</strong> ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</p>
</li>
<li><p><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服 这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁 盘⽂件的⽅式存在，可以实现本机任意两个进程通信。最后一个引用它的进程终止时，留在FIFO的数据也将会被删除 </p>
</li>
<li><p><strong>信号(Signal)</strong> ：信号是⼀种⽐复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣； </p>
</li>
<li><p><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息 队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在 于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字节流以及缓冲区⼤⼩受限等缺。</p>
</li>
<li><p><strong>信号量(Semaphores)</strong> ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p>
</li>
</ol>
<p>和自旋锁一样，信号量也是保护临界资源的一种有用方法。信号量只有当得到信号量时，进程或者线程才能够进入临界区，执行临界代码(down等函数后面的代码块)。</p>
<p>信号量与自旋锁的最大不同点在于，当一个进程试图去获取一个已经锁定的信号量时，该进程不会像自旋锁一样在自旋忙等待，而是会将自身加入一个等待队列中去睡眠，直到其他进程释放信号量后，处于等待队列中的进程才会被唤醒。当进程唤醒 后，就立刻重新从睡眠的地方开始执行，又一次试图获得信号量，当获得信号量后，程序继续执行。</p>
<p>所以，从信号量的原理上来说，没有获得信号量的函数可能睡眠。这就要求只有能够睡眠的进程才能够使用信号量，不能睡眠的进程不能使用信号量。例如中断处理程序中，由于中断需要立刻完成，所以不能睡眠，也就是说在中断处理程序中不能使用信号量。</p>
<ul>
<li>如果信号量值大于0，则资源可用，并且将其减1，表示当前已被使用</li>
<li>如果信号量值为0，则进程休眠直至信号量值大于0</li>
</ul>
<ol>
<li><p><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对 ⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。 </p>
<p>那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中</p>
</li>
<li><p><strong>套接字(Sockets)</strong> : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP&#x2F;IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p>
</li>
</ol>
<h1 id="31、-操作系统中CPU调度算法有哪些？介绍下"><a href="#31、-操作系统中CPU调度算法有哪些？介绍下" class="headerlink" title="31、.操作系统中CPU调度算法有哪些？介绍下"></a>31、.操作系统中CPU调度<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>有哪些？介绍下</h1><h3 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h3><h3 id="短作业优先算法（SJF）"><a href="#短作业优先算法（SJF）" class="headerlink" title="短作业优先算法（SJF）"></a>短作业优先算法（SJF）</h3><h3 id="高响应比优先调度算法（HRRN）"><a href="#高响应比优先调度算法（HRRN）" class="headerlink" title="高响应比优先调度算法（HRRN）"></a>高响应比优先调度算法（HRRN）</h3><h3 id="时间片轮转调度算法（RR）"><a href="#时间片轮转调度算法（RR）" class="headerlink" title="时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h3><h3 id="优先级调度算法（HPF）"><a href="#优先级调度算法（HPF）" class="headerlink" title="优先级调度算法（HPF）"></a>优先级调度算法（HPF）</h3><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><h1 id="32、GET-和-POST-方法都是安全和幂等的吗？"><a href="#32、GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="32、GET 和 POST 方法都是安全和幂等的吗？"></a>32、GET 和 POST 方法都是安全和幂等的吗？</h1><p> 先说明下安全和幂等的概念： 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。</p>
<h1 id="33、HTTP-x2F-1-1-的性能如何？"><a href="#33、HTTP-x2F-1-1-的性能如何？" class="headerlink" title="33、HTTP&#x2F;1.1 的性能如何？"></a>33、HTTP&#x2F;1.1 的性能如何？</h1><h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1.长连接"></a>1.长连接</h2><p> 早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握 手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在 于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<h2 id="2、管道网络传输"><a href="#2、管道网络传输" class="headerlink" title="2、管道网络传输"></a>2、管道网络传输</h2><p> HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就 可以发第二个请求出去，可以减少整体的响应时间。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等 待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p>
<h2 id="3、队头阻塞"><a href="#3、队头阻塞" class="headerlink" title="3、队头阻塞"></a>3、队头阻塞</h2><p> 「请求 - 应答」的模式加剧了 HTTP 的性能问题。 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞 了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。</p>
<h1 id="34、HTTP-与-HTTPS-有哪些区别？"><a href="#34、HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="34、HTTP 与 HTTPS 有哪些区别？"></a>34、HTTP 与 HTTPS 有哪些区别？</h1><ol>
<li><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的 缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</p>
</li>
<li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次 握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。 </p>
</li>
<li><p>HTTP 的端口号是 80，HTTPS 的端口号是 443。 </p>
</li>
<li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327080529220.png" alt="image-20210327080529220"></p>
<h1 id="35、HTTPS-是如何建立连接的？其间交互了什么？"><a href="#35、HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="35、HTTPS 是如何建立连接的？其间交互了什么？"></a>35、HTTPS 是如何建立连接的？其间交互了什么？</h1><p> SSL&#x2F;TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。 </li>
<li>双方协商生产「会话秘钥」。 </li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是握手阶段。 SSL&#x2F;TLS 的「握手阶段」涉及四次通信，可见下图：</p>
<p>HTTPS 连接建立过程 SSL&#x2F;TLS 协议建立的详细流程：</p>
<ol>
<li>ClientHello 首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 在这一步，客户端主要向服务器发送以下信息： （1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。 （2）客户端生产的随机数（ Client Random ），后面用于生产「会话秘钥」。 （3）客户端支持的密码套件列表，如 RSA 加密算法。</li>
<li>SeverHello 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容： （1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。 （2）服务器生产的随机数（ Server Random ），后面用于生产「会话秘钥」。 （3）确认的密码套件列表，如 RSA 加密算法。 （4）服务器的数字证书。</li>
<li>客户端回应 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的 真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如 下信息： （1）一个随机数（ pre-master key ）。该随机数会被服务器公钥加密。 （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数 据做个摘要，用来供服务端校验。 上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着 就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</li>
<li>服务器的最后回应 服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信 的「会话秘钥」。然后，向客户端发生最后的信息： （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数 据做个摘要，用来供客户端校验。至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通 的 HTTP 协议，只不过用「会话秘钥」加密内容。</li>
</ol>
<h1 id="36、说说-HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？"><a href="#36、说说-HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？" class="headerlink" title="36、说说 HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>36、说说 HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h1><h2 id="三、HTTP1-0和HTTP1-1的一些区别"><a href="#三、HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="三、HTTP1.0和HTTP1.1的一些区别"></a><strong>三、HTTP1.0和HTTP1.1的一些区别</strong></h2><ol>
<li><p><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
</li>
<li><p><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
</li>
</ol>
<h2 id="HTTP-x2F-1-1-相比-HTTP-x2F-1-0-性能上的改进："><a href="#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-性能上的改进：" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进："></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</h2><ul>
<li>使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。 </li>
<li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求 出去，可以减少整体的响应时间。</li>
</ul>
<h2 id="但-HTTP-x2F-1-1-还是有性能瓶颈："><a href="#但-HTTP-x2F-1-1-还是有性能瓶颈：" class="headerlink" title="但 HTTP&#x2F;1.1 还是有性能瓶颈："></a>但 HTTP&#x2F;1.1 还是有性能瓶颈：</h2><ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多； </li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头 阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h1 id="37、那上面的-HTTP-x2F-1-1-的性能瓶颈，HTTP-x2F-2-做了什么优-化？"><a href="#37、那上面的-HTTP-x2F-1-1-的性能瓶颈，HTTP-x2F-2-做了什么优-化？" class="headerlink" title="37、那上面的 HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优 化？"></a>37、那上面的 HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优 化？</h1><h2 id="HTTP-x2F-2-协议是基于-HTTPS-的，所以-HTTP-x2F-2-的安全性也是有保障的。-那-HTTP-x2F-2-相比-HTTP-x2F-1-1-性能上的改进："><a href="#HTTP-x2F-2-协议是基于-HTTPS-的，所以-HTTP-x2F-2-的安全性也是有保障的。-那-HTTP-x2F-2-相比-HTTP-x2F-1-1-性能上的改进：" class="headerlink" title="HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。 那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进："></a>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。 那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</h2><ol>
<li>头部压缩 HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会 帮你消除重复的分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生 成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 </li>
<li>二进制格式 HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式。 头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong></li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327084224462.png" alt="image-20210327084224462"></p>
<p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明 文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</p>
<ol start="3">
<li><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2></li>
</ol>
<p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必 须要对数据包做标记，指出它属于哪个回应。 </p>
<p>每个请求或回应的所有数据包，称为一个数据流（ Stream ）。 </p>
<p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数 </p>
<p>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327084448870.png" alt="image-20210327084448870"></p>
<ol start="4">
<li><p>多路复用 HTTP&#x2F;2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。 移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟， 大幅度提高了连接的利用率。举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗 时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
</li>
<li><p>服务器推送 HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
</li>
</ol>
<h2 id="HTTP2-0多路复用有多好？"><a href="#HTTP2-0多路复用有多好？" class="headerlink" title="HTTP2.0多路复用有多好？"></a><strong>HTTP2.0多路复用有多好？</strong></h2><p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br>HTTP&#x2F;2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><p>对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。 非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开</p>
<h1 id="38、线程和进程的区别是什么？-还有-协程"><a href="#38、线程和进程的区别是什么？-还有-协程" class="headerlink" title="38、线程和进程的区别是什么？ 还有 协程"></a>38、线程和进程的区别是什么？ 还有 协程</h1><p>1、进程是资源分配最小单位，线程是程序执行的最小单位；</p>
<p>2、进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；</p>
<p>3、CPU切换一个线程比切换进程花费小；</p>
<p>4、创建一个线程比进程开销小；</p>
<p>5、线程占用的资源要⽐进程少很多。</p>
<p>6、线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）</p>
<p>7、多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；</p>
<p>8、进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；</p>
<ul>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>处理机分给线程，即<strong>真正在处理机上运行的是线程</strong>；</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程（<strong>coroutine</strong>）是一种<strong>程序运行的方式</strong>，即在单线程里多个函数并发地执行.</p>
<h2 id="2-协程与线程的区别"><a href="#2-协程与线程的区别" class="headerlink" title="2 协程与线程的区别"></a>2 协程与线程的区别</h2><ol>
<li>由于协程的特性, 适合执行大量的<strong>I&#x2F;O 密集型任务</strong>, 而线程在这方面弱于协程</li>
<li>协程涉及到函数的切换, 多线程涉及到线程的切换, 所以都有<strong>执行上下文</strong>, 但是协程不是被操作系统内核所管理, 而完全是由程序所控制（也就是在<strong>用户态</strong>执行）, 这样带来的好处就是性能得到了很大的提升, 不会像线程那样需要<strong>在内核态进行上下文切换</strong>来消耗资源，因此<strong>协程的开销远远小于线程的开销</strong></li>
<li>同一时间, 在多核处理器的环境下, <strong>多个线程是可以并行的</strong>，但是<strong>运行的协程的函数却只能有一个</strong>，<strong>其他的协程的函数都被suspend</strong>, 即<strong>协程是并发的</strong></li>
<li>由于协程在同一个线程中, 所以不需要用来守卫<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E9%94%AE%E5%8C%BA%E6%AE%B5"><strong>临界区段</strong></a>的同步性原语（primitive）比如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a>、信号量等，并且<strong>不需要来自操作系统的支持</strong></li>
<li>在协程之间的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">切换</a>不需要涉及任何<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>或任何<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BB%E5%A1%9E_(%E8%AE%A1%E7%AE%97)&action=edit&redlink=1">阻塞</a>调用</li>
<li><strong>通常的线程是抢先式(即由操作系统分配执行权)</strong>, 而协程是<strong>由程序分配执行权</strong></li>
</ol>
<h3 id="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"><a href="#协程的特点在于是一个线程执行，那和多线程比，协程有何优势？" class="headerlink" title="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"></a>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</h3><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
<p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<h1 id="39、线程间的同步的方式"><a href="#39、线程间的同步的方式" class="headerlink" title="39、线程间的同步的方式"></a>39、线程间的同步的方式</h1><ol>
<li>互斥量（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。</li>
<li>临界区：临界区只限制与同一进程的各个线程之间使用，</li>
<li>信号量（Semphares）：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li>事件（Event）：Wait&#x2F;Notify：通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态：有信号状态和无信号状态。Cevent类对象有两种类型：人工事件和自动事件。</span><br><span class="line">自动事件对象，在被至少一个线程释放后自动返回到无信号状态；   类似于CountdownLatch</span><br></pre></td></tr></table></figure>

<h1 id="进程同步方式"><a href="#进程同步方式" class="headerlink" title="进程同步方式"></a>进程同步方式</h1><p>互斥锁，条件变量，信号量</p>
<h1 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h1><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h1 id="40、各种锁"><a href="#40、各种锁" class="headerlink" title="40、各种锁"></a>40、各种锁</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012998254/article/details/82558178">https://blog.csdn.net/u012998254/article/details/82558178</a></p>
<p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
</ul>
<p>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起 来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级 锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所 以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻 量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。</p>
<ul>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
</ul>
<p>，轻量级锁所适应的场 景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁。</p>
<ul>
<li>重量级锁：有实际竞争，且锁竞争时间长。</li>
</ul>
<p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p>
<p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210607140141421.png" alt="image-20210607140141421"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210607140235900.png" alt="image-20210607140235900"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/笔记\java\SpringCloud\image-20210615214231974.png" alt="image-20210615214231974"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210615214519618.png" alt="image-20210615214519618"></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h2><p>CAS:Compare and Swap, 翻译成比较并交换。 </p>
<p>java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种<strong>乐观锁</strong>。</p>
<p><strong>CAS应用</strong></p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h1 id="41、Synchronized-有几种用法？"><a href="#41、Synchronized-有几种用法？" class="headerlink" title="41、Synchronized 有几种用法？"></a>41、Synchronized 有几种用法？</h1><h2 id="1、同步普通方法"><a href="#1、同步普通方法" class="headerlink" title="1、同步普通方法"></a>1、同步普通方法</h2><p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用在普通方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronizedMethod&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、同步静态方法"><a href="#2、同步静态方法" class="headerlink" title="2、同步静态方法"></a>2、同步静态方法</h2><p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用在静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">synchronizedStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronizedStaticMethod&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、同步类"><a href="#3、同步类" class="headerlink" title="3、同步类"></a>3、同步类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用在类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">synchronizedClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (TestSynchronized.class) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronizedClass&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用在类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">synchronizedGetClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronizedGetClass&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>
<h2 id="4、同步this实例"><a href="#4、同步this实例" class="headerlink" title="4、同步this实例"></a>4、同步this实例</h2><p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">synchronizedThis</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronizedThis&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、同步对象实例"><a href="#5、同步对象实例" class="headerlink" title="5、同步对象实例"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>
<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用在对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">synchronizedInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronizedInstance&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<h1 id="42、如何实现线程安全"><a href="#42、如何实现线程安全" class="headerlink" title="42、如何实现线程安全"></a>42、如何实现线程安全</h1><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是<strong>线程安全</strong>的。</p>
<ul>
<li>第一种 : 互斥同步(synchronized)</li>
</ul>
<p>大家应该都知道，java 在虚拟机中除了线程计数器，java虚拟机栈 是线程私有的，其余的java堆，方法区，和运行时常量池都是线程共享的内存区域。java堆是存储对象和数组的，但是对象在内存中的存储布局可以分为三块区域：对象头，实例数据（对象真正存储的有效信息，程序代码中所定义的各个类型的字段内容），对齐填充。</p>
<p>为什么说synchronized的锁是存放在对象头里面呢？因为对象头里面也存储了两部分信息：第一部分呢，存储对象自身的运行时数据，包括哈希码，GC分代年龄，锁状态标识位，线程持有的锁，偏向锁Id，偏向时间戳等数据。第二部分是类型指针，虚拟机通过这个来确定该对象是哪个类的实例。</p>
<ul>
<li>第二种方法就是：非阻塞同步</li>
</ul>
<p>我们想想哈，互斥同步里实现了 操作的原子性(这个操作没有被中断) 和 可见性（对数据进行更改后，会立马写入到内存中，其他线程在使用到这个数据时，会获取o到最新的数据），那怎么才能不用同步来实现原子性和可见性呢？ </p>
<p>  CAS是实现非阻塞同步的计算机指令，它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。</p>
<ul>
<li>第三种：无同步方案</li>
</ul>
<p>线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。</p>
<p>经常使用的就是ThreadLocal类</p>
<p>ThreadLocal类 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等。</p>
<h1 id="43、什么是哈希表，HashMap怎么解决的哈希冲突"><a href="#43、什么是哈希表，HashMap怎么解决的哈希冲突" class="headerlink" title="43、什么是哈希表，HashMap怎么解决的哈希冲突"></a>43、什么是哈希表，HashMap怎么解决的哈希冲突</h1><p> 哈希表：数据经过哈希算法之后得到的集合。这样关键字和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询。</p>
<p>Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。</p>
<p>Hashmap里面的bucket出现了单链表的形式，散列表要解决的一个问题就是散列值的冲突问题，通常是两种方法：链表法和开放地址法。</p>
<h2 id="1-链表法"><a href="#1-链表法" class="headerlink" title="1.链表法"></a>1.链表法</h2><p>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</p>
<h3 id="2、开放地址法"><a href="#2、开放地址法" class="headerlink" title="2、开放地址法"></a>2、开放地址法</h3><p>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。java.util.HashMap采用的链表法的方式，链表是单向链表。形成单链表的核心代码如下：</p>
<h2 id="3-再哈希"><a href="#3-再哈希" class="headerlink" title="3. 再哈希"></a>3. 再哈希</h2><p>如果发生冲突，就用另一个方法计算hashcode，两次结果值不一样就不会发生hash冲突；</p>
<ol start="4">
<li><h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2></li>
</ol>
<p>将哈希表分为基本表和溢出表两部分，范式和基本表发生冲突的元素，一律填入溢出表。</p>
<h1 id="44、synchronized实现原理"><a href="#44、synchronized实现原理" class="headerlink" title="44、synchronized实现原理"></a>44、synchronized实现原理</h1><p>从上面可以看出，<strong>同步代码块</strong>是使用monitorenter和monitorexit指令实现的，<strong>同步方法</strong>（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<h1 id="45、synchronized和lock的区别"><a href="#45、synchronized和lock的区别" class="headerlink" title="45、synchronized和lock的区别"></a>45、synchronized和lock的区别</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210327172654537.png" alt="image-20210327172654537"></p>
<p>区别如下：</p>
<ol>
<li>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</li>
<li>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li>
<li>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li>
<li>是否知道获取锁<br>Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
<li>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</li>
</ol>
<h4 id="1、synchronized和lock的用法区别"><a href="#1、synchronized和lock的用法区别" class="headerlink" title="1、synchronized和lock的用法区别"></a>1、synchronized和lock的用法区别</h4><p>synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</p>
<p>lock：一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</p>
<h4 id="2、synchronized和lock性能区别"><a href="#2、synchronized和lock性能区别" class="headerlink" title="2、synchronized和lock性能区别"></a>2、synchronized和lock性能区别</h4><p>synchronized是托管给JVM执行的，<br>而lock是java写的控制锁的代码。</p>
<p>在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。</p>
<p>但是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。</p>
<p>2种机制的具体区别：<br><strong>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。</strong>独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p>
<p><strong>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作</strong>（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p>
<p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<h4 id="3、synchronized和lock用途区别"><a href="#3、synchronized和lock用途区别" class="headerlink" title="3、synchronized和lock用途区别"></a>3、synchronized和lock用途区别</h4><p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。</p>
<p>1.某个线程在等待一个锁的控制权的这段时间需要中断<br>2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>3.具有公平锁功能，每个到来的线程都将排队等候</p>
<p>下面细细道来……</p>
<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候<strong>ReentrantLock就提供了2种机制：可中断&#x2F;可不中断</strong><br>第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；<br>第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。</p>
<h1 id="46、Java中synchronized和volatile有什么区别？"><a href="#46、Java中synchronized和volatile有什么区别？" class="headerlink" title="46、Java中synchronized和volatile有什么区别？"></a>46、Java中synchronized和volatile有什么区别？</h1><p><strong>一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。</strong></p>
<p>另外一方面，因为<strong>volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。</strong></p>
<p>所以，在日后需要做并发控制的时候，如果不涉及到原子性的问题，可以优先考虑使用volatile关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line"><span class="number">2</span>      <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line"><span class="number">3</span>       <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line"><span class="number">4</span>       <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="number">5</span>       <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="number">6</span>           <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line"><span class="number">7</span>               <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="number">8</span>                   singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line"><span class="number">9</span>               &#125;  </span><br><span class="line"><span class="number">10</span>           &#125;  </span><br><span class="line"><span class="number">11</span>       &#125;  </span><br><span class="line"><span class="number">12</span>       <span class="keyword">return</span> singleton;  </span><br><span class="line"><span class="number">13</span>       &#125;  </span><br><span class="line"><span class="number">14</span>   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上过程，看上去并没有什么问题，但是，其实，在Step4，Thread2在调用singleton.call()的时候，是有可能抛出空指针异常的。</p>
<p>之所有会有NPE抛出，是因为在Step3，Thread2拿到的singleton对象并不是一个完整的对象。</p>
<p><strong>什么叫做不完整对象，这个怎么理解呢？</strong></p>
<p>我们这里来先来看一下，singleton &#x3D; new Singleton();这行代码到底做了什么事情，大致过程如下：</p>
<ul>
<li>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。 </li>
<li>2、检查符号引用代表的类是否被加载、解析、初始化过。 </li>
<li>3、虚拟机为对象分配内存。 </li>
<li>4、虚拟机将分配到的内存空间都初始化为零值。 </li>
<li>5、虚拟机对对象进行必要的设置。 </li>
<li>6、执行方法，成员变量进行初始化。</li>
<li>7、将对象的引用指向这个内存区域。</li>
</ul>
<p>我们把这个过程简化一下，简化成3个步骤：</p>
<ul>
<li><p>a、JVM为对象分配一块内存M </p>
</li>
<li><p>b、在内存M上为对象进行初始化 </p>
</li>
<li><p>c、将内存M的地址复制给singleton变量</p>
</li>
<li><p>因为将内存的地址赋值给singleton变量是最后一步，所以Thread1在这一步骤执行之前，Thread2在对singleton&#x3D;&#x3D;null进行判断一直都是true的，那么他会一直阻塞，直到Thread1将这一步骤执行完。</p>
<p>但是，问题就出在以上过程并不是一个原子操作，并且编译器可能会进行重排序，如果以上步骤被重排成：</p>
<ul>
<li>a、JVM为对象分配一块内存M </li>
<li>c、将内存的地址复制给singleton变量 </li>
<li>b、在内存M上为对象进行初始化</li>
</ul>
</li>
</ul>
<p>这样的话，Thread1会先执行内存分配，在执行变量赋值，最后执行对象的初始化，那么，也就是说，在Thread1还没有为对象进行初始化的时候，Thread2进来判断singleton&#x3D;&#x3D;null就可能提前得到一个false，则会返回一个不完整的sigleton对象，因为他还未完成初始化操作。</p>
<p><strong>这种情况一旦发生，我们拿到了一个不完整的singleton对象，当尝试使用这个对象的时候就极有可能发生NPE异常。</strong></p>
<p>那么，怎么解决这个问题呢？因为指令重排导致了这个问题，那就避免指令重排就行了。</p>
<p>所以，volatile就派上用场了，因为volatile可以避免指令重排。</p>
<h1 id="47、-事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#47、-事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="47、 事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>47、 事务隔离级别有哪些?MySQL的默认隔离级别是?</h1><ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<p>SQL 标准定义了四个隔离级别： </p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导 致脏读、幻读或不可重复读。 </li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读 或不可重复读仍有可能发⽣。 </li>
<li>REPEATABLE-READ(可重复读)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务 ⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 </li>
<li>SERIALIZABLE(可串⾏化)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个 执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及 幻读。</li>
</ul>
<h1 id="48-⼤表优化"><a href="#48-⼤表优化" class="headerlink" title="48 ⼤表优化"></a>48 ⼤表优化</h1><p> 当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下： </p>
<h2 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h2><p>务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以 控制在⼀个⽉的范围内； </p>
<h2 id="读-x2F-写分离"><a href="#读-x2F-写分离" class="headerlink" title="读&#x2F;写分离"></a>读&#x2F;写分离</h2><p>经典的数据库拆分⽅案，主库负责写，从库负责读； </p>
<h2 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h2><p>根据数据库⾥⾯数据表的相关性进⾏拆分。 例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信 息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。 </p>
<ul>
<li>垂直拆分的优点： 可以使得列数据变⼩，在查询时减少读取的Block数，减少I&#x2F;O次数。此外， 垂直分区可以简化表的结构，易于维护。 </li>
<li>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应⽤层 进⾏Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h2 id="⽔平分区"><a href="#⽔平分区" class="headerlink" title="⽔平分区"></a>⽔平分区</h2><p> 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，达到了 分布式的⽬的。 ⽔平拆分可以⽀撑⾮常⼤的数据量。</p>
<p> ⽔平拆分是指数据表⾏的拆分，表的⾏数超过200万⾏时，就会变慢，这时可以把⼀张的表的数据拆成 多张表来存放。举个例⼦：我们可以将⽤户信息表拆分成多个⽤户信息表，这样就可以避免单⼀表数据 量过⼤对性能造成影响。</p>
<p>⽔平拆分可以⽀持⾮常⼤的数据量。需要注意的⼀点是：分表仅仅是解决了单⼀表数据过⼤的问题，但 由于表的数据还是在同⼀台机器上，其实对于提升MySQL并发能⼒没有什么意义，所以 ⽔平拆分最好分 库 。</p>
<p> ⽔平拆分能够 ⽀持⾮常⼤的数据量存储，应⽤端改造也少，但 分⽚事务难以解决 ，跨节点Join性能 ᫾差，逻辑复杂。《Java⼯程师修炼之道》的作者推荐 尽量不要对数据进⾏分⽚，因为拆分会带来逻 辑、部署、运维的各种复杂度 ，⼀般的数据表在优化得当的情况下⽀撑千万以下的数据量是没有太⼤ 问题的。如果实在要分⽚，尽量选择客户端分⽚架构，这样可以减少⼀次和中间件的⽹络I&#x2F;O。 </p>
<p>下⾯补充⼀下数据库分⽚的两种常⻅⽅案：</p>
<p> 客户端代理： 分⽚逻辑在应⽤端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当⽹的 Sharding-JDBC 、阿⾥的TDDL是两种⽐᫾常⽤的实现。</p>
<p> 中间件代理： 在应⽤和数据中间加了⼀个代理层。分⽚逻辑统⼀维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、⽹易的DDB等等都是这种架构的实现。 </p>
<h1 id="49-分库分表之后-id-主键如何处理"><a href="#49-分库分表之后-id-主键如何处理" class="headerlink" title="49 分库分表之后,id 主键如何处理"></a>49 分库分表之后,id 主键如何处理</h1><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id 来⽀持。 ⽣成全局 id 有下⾯这⼏种⽅式：</p>
<ul>
<li>UUID：不适合作为主键，因为太⻓了，并且⽆序不可读，查询效率低。比较适合⽤于⽣成唯⼀的 名字的标示⽐如⽂件的名字。</li>
<li>数据库⾃增 id : 两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式 ⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。 </li>
<li>利⽤ redis ⽣成 id : 性能比较好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成 系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。 </li>
<li>Twitter的snowflake算法 ：Github 地址：<a target="_blank" rel="noopener" href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a> </li>
<li>美团的Leaf分布式ID⽣成系统 ：Leaf 是美团开源的分布式ID⽣成器，能保证全局唯⼀性、趋势 递增、单调递增、信息安全，⾥⾯也提到了⼏种分布式⽅案的对⽐，但也需要依赖关系数据库、 Zookeeper等中间件。感觉还不错。美团技术团队的⼀篇⽂章：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017">https://tech.meituan.com/2017</a> &#x2F;04&#x2F;21&#x2F;mt-leaf.html 。 ……</li>
</ul>
<h1 id="50-⼀条SQL语句执⾏得很慢的原因有哪些？"><a href="#50-⼀条SQL语句执⾏得很慢的原因有哪些？" class="headerlink" title="50 ⼀条SQL语句执⾏得很慢的原因有哪些？"></a>50 ⼀条SQL语句执⾏得很慢的原因有哪些？</h1><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>
<h1 id="51-为什么要⽤-redis-⽽不⽤-map-x2F-guava-做缓存"><a href="#51-为什么要⽤-redis-⽽不⽤-map-x2F-guava-做缓存" class="headerlink" title="51 为什么要⽤ redis ⽽不⽤ map&#x2F;guava 做缓存?"></a>51 为什么要⽤ redis ⽽不⽤ map&#x2F;guava 做缓存?</h1><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最 主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都 需要各⾃保存⼀份缓存，缓存不具有⼀致性。 </p>
<p>使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓 存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上᫾为复杂。</p>
<h1 id="52、-redis-内存淘汰机制-MySQL⾥有2000w数据，Redis中只存20w的数据，如何-保证Redis中的数据都是热点数据"><a href="#52、-redis-内存淘汰机制-MySQL⾥有2000w数据，Redis中只存20w的数据，如何-保证Redis中的数据都是热点数据" class="headerlink" title="52、 redis 内存淘汰机制(MySQL⾥有2000w数据，Redis中只存20w的数据，如何 保证Redis中的数据都是热点数据?)"></a>52、 redis 内存淘汰机制(MySQL⾥有2000w数据，Redis中只存20w的数据，如何 保证Redis中的数据都是热点数据?)</h1><p>redis 提供 6种数据淘汰策略：</p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使⽤的数 据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘 汰 </li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li>
<li>allkeys-lru：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是 最常⽤的） </li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li>
<li>no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。 这个应该没⼈使⽤吧！</li>
</ol>
<p> 4.0版本后增加以下两种：</p>
<ol start="7">
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使⽤的数据 淘汰 </li>
<li>. allkeys-lfu：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最不经常使⽤的key</li>
</ol>
<h2 id="10、redis过期键的删除策略？"><a href="#10、redis过期键的删除策略？" class="headerlink" title="10、redis过期键的删除策略？"></a>10、redis过期键的删除策略？</h2><p>1、定时删除:在设置键的过期时间的同时，创建一个定时器timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</p>
<p>3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328144344935.png" alt="image-20210328144344935"></p>
<h1 id="53、-缓存雪崩和缓存穿透问题解决⽅案"><a href="#53、-缓存雪崩和缓存穿透问题解决⽅案" class="headerlink" title="53、 缓存雪崩和缓存穿透问题解决⽅案"></a>53、 缓存雪崩和缓存穿透问题解决⽅案</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>什么是缓存雪崩？ 简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤ 量请求⽽崩掉。</p>
<p>有哪些解决办法？ （中华⽯杉⽼师在他的视频中提到过，视频地址在最后⼀个问题中有提到）： </p>
<p>事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策 略。</p>
<p> 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 </p>
<p>事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="缓存穿透-什么是缓存穿透？"><a href="#缓存穿透-什么是缓存穿透？" class="headerlink" title="缓存穿透 什么是缓存穿透？"></a>缓存穿透 什么是缓存穿透？</h3><p> 缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有 经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库。下⾯⽤图⽚展示⼀下(这两张图⽚不是我画的，为了省事直接在⽹上找的，这⾥说明⼀ 下)： 正常缓存处理流程：</p>
<h3 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h3><p>最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的 数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p> 1）缓存⽆效 key : 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时 间，具体命令如下： SET key value EX 10086 。这种⽅式可以解决请求的 key 变化不频繁的情况，如 果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key 的过期 时间设置短⼀点⽐如 1 分钟。 另外，这⾥多说⼀嘴，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。</p>
<p>2）布隆过滤器：布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“⼈”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会⾛下⾯的流程。总结⼀下就是下⾯这张图(这张图⽚不是我画的，为了省事 直接在⽹上找的)：</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328152357109.png" alt="image-20210328152357109"></p>
<h1 id="54-Spring"><a href="#54-Spring" class="headerlink" title="54 Spring"></a>54 Spring</h1><h2 id="spring-中的-bean-的作⽤域有哪些"><a href="#spring-中的-bean-的作⽤域有哪些" class="headerlink" title="spring 中的 bean 的作⽤域有哪些?"></a>spring 中的 bean 的作⽤域有哪些?</h2><p>singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的。 </p>
<p>prototype : 每次请求都会创建⼀个新的 bean 实例。 </p>
<p>request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</p>
<p> session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</p>
<p> global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义，Spring5已 经没有了。Portlet是能够⽣成语义代码(例如：HTML)⽚段的⼩型Java Web插件。它们基于 portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有 不同的会话 </p>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问 题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程 安全问题。 常⻅的有两种解决办法： </p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的 ⼀种⽅式）。</li>
</ol>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol>
<li>作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 </li>
<li>@Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean 告诉 了Spring这是某个类的实例，当我需要⽤它的时候还给我。 </li>
<li>@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来 注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来 实现。</li>
</ol>
<h2 id="将⼀个类声明为Spring的-bean-的注解有哪些"><a href="#将⼀个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将⼀个类声明为Spring的 bean 的注解有哪些?"></a>将⼀个类声明为Spring的 bean 的注解有哪些?</h2><p>我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配 的 bean 的类,采⽤以下注解可实现：</p>
<p> @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个 层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</p>
<h3 id="Repository的作用："><a href="#Repository的作用：" class="headerlink" title="@Repository的作用："></a>@Repository的作用：</h3><p><strong>这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。</strong></p>
<p> @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 </p>
<p>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据 给前端⻚⾯。</p>
<h2 id="SpringMVC-⼯作原理了解吗"><a href="#SpringMVC-⼯作原理了解吗" class="headerlink" title="SpringMVC ⼯作原理了解吗"></a>SpringMVC ⼯作原理了解吗</h2><p>流程说明（重要）： </p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 </li>
<li>解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 </li>
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是 个逻辑上的 View 。 </li>
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。 </li>
<li>把 View 返回给请求者（浏览器）</li>
</ol>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h2><p>我们知道：Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说 是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。 当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时， 我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥ ⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。 在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候 才会回滚,加上 rollbackFor&#x3D;Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。</p>
<h1 id="堆（heap）和栈（stack）的区别"><a href="#堆（heap）和栈（stack）的区别" class="headerlink" title="堆（heap）和栈（stack）的区别"></a>堆（heap）和栈（stack）的区别</h1><h3 id="1、存储"><a href="#1、存储" class="headerlink" title="1、存储"></a>1、存储</h3><p>栈：变量、对象的引用</p>
<p>堆：实例对象</p>
<h3 id="2、速度"><a href="#2、速度" class="headerlink" title="2、速度"></a>2、速度</h3><p>栈：存取速度快</p>
<p>堆：存取速度慢</p>
<h3 id="3、线程访问"><a href="#3、线程访问" class="headerlink" title="3、线程访问"></a>3、线程访问</h3><p>栈：每个线程都有一个栈区</p>
<p>堆：所有线程共享一个堆区</p>
<h3 id="4、垃圾回收"><a href="#4、垃圾回收" class="headerlink" title="4、垃圾回收"></a>4、垃圾回收</h3><p>栈：比较频繁</p>
<p>堆：不频繁</p>
<h1 id="55、在浏览器中输入URL后，执行的全部过程。"><a href="#55、在浏览器中输入URL后，执行的全部过程。" class="headerlink" title="55、在浏览器中输入URL后，执行的全部过程。"></a>55、在浏览器中输入URL后，执行的全部过程。</h1><p>整个流程如下：<br>域名解析<br>为了将消息从你的PC上传到服务器<br>上.需要用到1P协议、ARP协议和0SPF协议<br>发起TCP的3次握手<br>建立TCP连接后发起http请求<br>服务器响应htp请求<br>浏览器解析htm代码,并请求html代码中的资源(如js、css、图片等）<br>断开TCP连接<br>浏览器对页面进行渲染呈现给用户</p>
<h3 id="一、域名解析的详细内部过程"><a href="#一、域名解析的详细内部过程" class="headerlink" title="一、域名解析的详细内部过程"></a>一、域名解析的详细内部过程</h3><h3 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手"></a>二、三次握手</h3><h3 id="三、建立TCP连接后发起http请求"><a href="#三、建立TCP连接后发起http请求" class="headerlink" title="三、建立TCP连接后发起http请求"></a>三、建立TCP连接后发起http请求</h3><h3 id="四、服务器收到请求并响应HTTP请求"><a href="#四、服务器收到请求并响应HTTP请求" class="headerlink" title="四、服务器收到请求并响应HTTP请求"></a>四、服务器收到请求并响应HTTP请求</h3><h3 id="五-浏览器解析htm代码-并请求htm代码中的资源-如js、css图片等"><a href="#五-浏览器解析htm代码-并请求htm代码中的资源-如js、css图片等" class="headerlink" title="五.浏览器解析htm代码,并请求htm代码中的资源(如js、css图片等)"></a>五.浏览器解析htm代码,并请求htm代码中的资源(如js、css图片等)</h3><h3 id="六-断开TCP连接"><a href="#六-断开TCP连接" class="headerlink" title="六.断开TCP连接"></a>六.断开TCP连接</h3><h3 id="七-浏览器对页面进行渲染呈现给用户"><a href="#七-浏览器对页面进行渲染呈现给用户" class="headerlink" title="七.浏览器对页面进行渲染呈现给用户"></a>七.浏览器对页面进行渲染呈现给用户</h3><h1 id="56、GET和POST的区别？"><a href="#56、GET和POST的区别？" class="headerlink" title="56、GET和POST的区别？"></a>56、GET和POST的区别？</h1><p>首先，GET和POST都是HTTP协议中的两种发送请求的方法，由于HTTP的底层是TCP&#x2F;IP。所以GET和POST的底层也是TCP&#x2F;IP。GET和POST能做的事情是一样一样的。如果给GET加上request body，活着给POST带上url参数，技术上是完全行的通的。也就是说，GET和POST在本质上没什么区别。</p>
<p>但是如果真的一点区别都没有，那么这个问题也就不存在了，所以，两者之间最重大的区别就是：</p>
<blockquote>
<p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
</blockquote>
<p>具体点说来就是：</p>
<p><em>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</em></p>
<p><em>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</em></p>
<p>这样看起来，因为POST需要两步，时间上消耗的要多一点，所以GET比POST更有效。那么可不可以用GET替换POST来优化网站性能？</p>
<p>\1. GET与POST都有自己的语义，不能随便混用。</p>
<p>\2. 如果网络环境好的话，发一次包的时间和发两次包的时间差别基本可以无视。如果网络环境差的话，两次包的TCP在验证数据包完整性上，有非常大的优点。</p>
<p>\3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
<p>另外，w3schools上面的参考答案也是可以酌情说一些的&#x3D;。&#x3D;</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h2 id="2-6静态数据缓存"><a href="#2-6静态数据缓存" class="headerlink" title="2.6静态数据缓存"></a>2.6静态数据缓存</h2><p>如果get请求的是静态资源，则会在第一次打开时进行缓存处理，这样在用户第二次访问相同地址时能够快速打开；而post则不行。</p>
<h2 id="2-7post不能进行管道化传输"><a href="#2-7post不能进行管道化传输" class="headerlink" title="2.7post不能进行管道化传输"></a>2.7post不能进行管道化传输</h2><p>http&#x2F;1.1中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，如果连接中断，则清空重新发送；这样的通信方式对于幂等请求get还好（每次都是相同的结果），但是post就不行了（比如支付）</p>
<h1 id="57、mysql慢查询"><a href="#57、mysql慢查询" class="headerlink" title="57、mysql慢查询"></a>57、mysql慢查询</h1><p>MySQL的慢查询，全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来记录在MySQL中<strong>响应时间超过阀值</strong>的语句</p>
<p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p>
<p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p>
<p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p>
<p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h2><h3 id="3-1-slow-query-log"><a href="#3-1-slow-query-log" class="headerlink" title="3.1 slow_query_log"></a>3.1 slow_query_log</h3><p>默认情况下<code>slow_query_log</code>的值为<code>OFF</code>，表示慢查询日志是禁用的，可以通过设置<code>slow_query_log</code>的值来开启，如下所示：</p>
<p>使用set global slow_query_log&#x3D;1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。</p>
<p>如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）。</p>
<p>my.cnf要增加或修改参数slow_query_log 和slow_query_log_file，如下所示</p>
<h2 id="Mysql优化"><a href="#Mysql优化" class="headerlink" title="Mysql优化"></a>Mysql优化</h2><ul>
<li>更小的更好</li>
</ul>
<p>尽量使用更小,</p>
<ul>
<li>简单就好</li>
<li><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328232348020.png" alt="image-20210328232348020"></li>
<li>尽量避免null</li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328233017427.png" alt="image-20210328233017427"></p>
<p>- </p>
<p>OLAP  OLTP</p>
<h2 id="所用数据结构"><a href="#所用数据结构" class="headerlink" title="所用数据结构"></a>所用数据结构</h2><p>InnoDB和Myisam 使用B+树，而memory使用hash.</p>
<p>InnoDB使用自适应(用户没办法干预)hash</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210328235959004.png" alt="image-20210328235959004"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329001222507.png" alt="image-20210329001222507"></p>
<p>hash函数难选合适的</p>
<p>树缺点：无论二叉树还是红黑树，都会因为树的深度过深而造成io次数变多，影响数据读取的效率.</p>
<p>InnoDB默认每次读16k数据</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329003753420.png" alt="image-20210329003753420"></p>
<p>因为分块 分页，所以查询时，不会所有的读入内存，进行提速。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010037509.png" alt="image-20210329010037509"></p>
<p>所有数据都放在叶子节点中，上边节点为数据的key(指针)。 因为非叶子节点只存指针，所以存的指针 而不是数据，所以存的更多(相比B树。每层要存数据)。</p>
<p>Myisam 和innodb在最终data处放的东西不同，innodb放的整行数据,mysalm存放的数据的地址所在行（所以还要到对应位置取出数据）。</p>
<p>索引越小越好，在 int和varchar选int，因为varchar占据更大内存，会导致树越来越深。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010459631.png" alt="image-20210329010459631"></p>
<p>所以B+树中说的key，要么是主键，要么是唯一键，要么是6字节的row_id;</p>
<p><strong>一开始索引主键和数据是绑定在一起，当给其他列加索引，这时这个索引的B+树叶子节点不再是数据Data，而是要么主键或者唯一键或者rowid</strong> 查了后再去主键索引树去查数据。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329010930419.png" alt="image-20210329010930419"></p>
<p>主键自增问题，当是分布式不推荐，不是分布式可以。  当不是按照顺序增加，那么会导致插入数据在中间。</p>
<h3 id="回表："><a href="#回表：" class="headerlink" title="回表："></a>回表：</h3><p>比如用name，id做索引后，select name时，查出id，又到id索引树查询，有二级索引时，称为回表.  产生io问题，一般数据量大时才看出来问题。</p>
<h3 id="索引覆盖："><a href="#索引覆盖：" class="headerlink" title="索引覆盖："></a>索引覆盖：</h3><p>select * from table where name&#x3D;?  回表</p>
<p>select id from table where name&#x3D;?   索引覆盖</p>
<h3 id="索引下推："><a href="#索引下推：" class="headerlink" title="索引下推："></a>索引下推：</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329101938780.png" alt="image-20210329101938780"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329104752874.png" alt="image-20210329104752874"></p>
<h3 id="最左匹配（和组合索引配合使用）："><a href="#最左匹配（和组合索引配合使用）：" class="headerlink" title="最左匹配（和组合索引配合使用）："></a>最左匹配（和组合索引配合使用）：</h3><p>组合索引：name,age</p>
<p>(name,age)    在一个BTree中以元组方式存储，必须先比较第一个，然后比较第二个元素才能取出正确的元素数据。 有<strong>索引下推</strong>就使得Io量少了，如果没有，那么就Io量会大。</p>
<p><strong>必须先匹配name再匹配age</strong></p>
<p>where name&#x3D;? and age&#x3D;?     走索引</p>
<p>where name&#x3D;?           走索引</p>
<p>where age&#x3D;?               不走索引</p>
<p>where age&#x3D;? and name&#x3D;?   走索引（因为有优化器 所以走索引了）</p>
<h2 id="为什么要最左匹配原则"><a href="#为什么要最左匹配原则" class="headerlink" title="为什么要最左匹配原则"></a>为什么要最左匹配原则</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419134131564.png" alt="image-20210419134131564"></p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>主键索引  唯一索引(unique)  普通索引  全文索引  组合索引</p>
<h3 id="MRR-mult-range-read"><a href="#MRR-mult-range-read" class="headerlink" title="MRR mult_range read"></a>MRR mult_range read</h3><p>将查询的数据排序 ，然后进行范围查询 提速。</p>
<h3 id="FIC-fast-index-create"><a href="#FIC-fast-index-create" class="headerlink" title="FIC  fast index create"></a>FIC  fast index create</h3><p>插入或者删除数据</p>
<ol>
<li>先创建临时表，将数据导入到临时表中</li>
<li>把原始表删除</li>
<li>修改临时表的名字</li>
</ol>
<p>给当前表添加一个Share锁，不会有创建临时文件的资源消耗，还是在源文件中做，但是此时如果有人发起DML操作，很明显数据会不一致，所以添加share锁，读取时没有问题，但是DML会有问题。(加锁的时候，修改时会把索引一起修改</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329113741836.png" alt="image-20210329113741836"></p>
<p>全值匹配：用到了索引中所有的键。</p>
<p>只访问索引的查询就是索引覆盖。</p>
<h3 id="索引匹配失效点："><a href="#索引匹配失效点：" class="headerlink" title="索引匹配失效点："></a>索引匹配失效点：</h3><ol>
<li>模糊查询%在前</li>
<li>出现范围查询,范围后续的所有索引失效 。 范围本身的索引还有效。</li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329120200913.png" alt="image-20210329120200913"></p>
<p>使用and时，最左匹配。  使用or，如果没带普通列，会使用全部组合索引，如果带了普通列，不会走索引。</p>
<p>使用in等字符时，不会走索引。  走索引是正常使用 where a&#x3D;x and b&gt;c  这些</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329122319380.png" alt="image-20210329122319380"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329005646972.png" alt="image-20210329005646972"></p>
<p>创建索引，只用前三个</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329005619956.png" alt="image-20210329005619956"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329132425707.png" alt="image-20210329132425707"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210329135510767.png" alt="image-20210329135510767"></p>
<h1 id="TCP-为什么是三次握手，而不是两次或四次？"><a href="#TCP-为什么是三次握手，而不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手，而不是两次或四次？"></a>TCP 为什么是三次握手，而不是两次或四次？</h1><p>另外还有一个就是在谢希仁著《计算机网络》第四版中，讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，这个只能算是表因，并不涉及本质。</p>
<p>也就是 TCP 的协议 RFC，你就会发现里面就讲到了为什么三次握手是必须的——TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。</p>
<p>我们首先要知道到一点就是， TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。	</p>
<p>三次握手（A three way handshake）是必须的， 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）。</p>
<p>接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是是否延迟了很久了，除非他有办法记住在这条连接中，最后接收到的那个sequence numbers（然而这不总是可行的）。</p>
<p>这句话的意思是：一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？</p>
<p>所以，接收方一定需要跟发送方确认 SYN。</p>
<p>只有B确认了收到了 A 的 SEQ， A 无法确认收到 B 的。也就是说，只有 A 发送给 B 的包都是可靠的， 而 B 发送给 A 的则不是，所以这不是可靠的连接。这种情况如果只需要 A 发送给 B ，B 无需回应，则可以不做三次握手。</p>
<h2 id="对于三次握手分别出现超时重传情况时"><a href="#对于三次握手分别出现超时重传情况时" class="headerlink" title="对于三次握手分别出现超时重传情况时"></a>对于三次握手分别出现超时重传情况时</h2><p>如果是第三次握手阻塞掉。那么服务端发送5次ack+syn后断开，客户端是出于建立连接状态。</p>
<ul>
<li>客户端发送消息时，会被阻塞重传，此时按照设置的最大次数，默认15次，进行重传，超过重传次数便停止报错，断开连接。</li>
<li>客户端不发消息就会在保活机制情况下2小时11分15秒后断开连接。</li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210416170117304.png" alt="image-20210416170117304"></p>
<h2 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h2><p> URG：紧急指针（urgent pointer）有效。ACK：确认序号有效。PSH：接收方应该尽快将这个报文交给应 用层。RST：重置连接。SYN：发起一个新连接。FIN：释放一个连接。 </p>
<p>假设是客户端发送第一次挥手 </p>
<ol>
<li>第一次挥手：客户端和服务器均可以发起(FIN&#x3D;1,seq&#x3D;x) 发送 FIN&#x3D;1 表示客户端已经没有 数据可以发送了，但是仍可以接收数据 发送完毕后，客户端进入 FIN_WAIT_1 阶段 </li>
<li>第二次挥手：(ACK&#x3D;1,ACKNum &#x3D; x+1) 服务器确认客户端的 FIN 包，发送一个确认包，表 明自己接受到了客户端关闭连接的请求，但还没准备好关闭连接。 发送完毕后，服务 器进入 CLOST_WAIT 阶段，客户端接收到这个报文之后进入 FIN_WAIT_2 状态，表示等 待服务器关闭连接 </li>
<li>第三次挥手：(FIN&#x3D;1,seq&#x3D;y) 服务器端准备好关闭连接时，向客户端发送结束连接请求， FIN 置为 1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。 </li>
<li>第四次挥手：(ACK&#x3D;1,ACKNum&#x3D;y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包. 服务器端接收 到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两 个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态.</li>
</ol>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p> 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还 需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： </p>
<p>1 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就 会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 </p>
<p>2 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得 下一个新的连接不会出现旧的连接请求报文。 </p>
<h3 id="为什么-TIME-WAIT-状态需要经过-2MSL-才能返回到-CLOSE-状态？"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-才能返回到-CLOSE-状态？" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？"></a>为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？</h3><p> 一、保证 TCP 协议的全双工连接能够可靠关闭 </p>
<p>二、保证这次连接的重复数据段从网络中消失</p>
<h1 id="59、-TCP-UDP-协议的区别"><a href="#59、-TCP-UDP-协议的区别" class="headerlink" title="59、 TCP,UDP 协议的区别"></a>59、 TCP,UDP 协议的区别</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210330085519793.png" alt="image-20210330085519793"></p>
<p>如果UDP采用可靠传输，两者区别应该还有传输形式不同。</p>
<p>UDP支持一对一，一对多，多对一和多对多交互通信,TCP只能一对一通信</p>
<p>UDP 报文的最大长度为 512 字节，而 TCP 则允许报文长度超过512字节</p>
<p>5、TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节 6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</p>
<p>7、分片不同。TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收 到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这 个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后， 在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有 的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</p>
<h2 id="UDP-中一个包的大小最大能多大"><a href="#UDP-中一个包的大小最大能多大" class="headerlink" title="UDP 中一个包的大小最大能多大"></a>UDP 中一个包的大小最大能多大</h2><p>1.以太网(Ethernet)数据帧的长度必须在46-1500字节之间，这是由以太网的物理特性决定的。 这个 1500 字节被称为链路层的 MTU(最大传输单元)。 但这并不是指链路层的长度被限制在 1500 字节，其实这个 MTU 指的是链路层的数据区。 </p>
<p>2.并不包括链路层的首部和尾部的 18 个字节。所以，事实上，这个 1500 字节就是网络层 IP 数据报的长度限制。因为 IP 数据报的首部为 20 字节,所以 IP 数据报的数据区长度最大为 1480 字节。 </p>
<p>3.而这个 1480 字节就是用来放 TCP 传来的 TCP 报文段或 UDP 传来的 UDP 数据报的。又因为 UDP 数据报的首部 8 字节，所以 UDP 数据报的数据区最大长度为 1472 字节。这个 <strong>1472 字 节</strong>就是我们可以使用的字节数。 （TCP 首部是 20 ~60 个字节）</p>
<h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a><strong>UDP如何实现可靠传输</strong></h2><p>由于在传输层UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制</p>
<p>简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的</p>
<p>超时重传（定时器）</p>
<p>有序接受 （添加包序号）</p>
<p>应答确认 （Seq&#x2F;Ack应答机制）</p>
<p>滑动窗口流量控制等机制 （滑动窗口协议）</p>
<p>等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法。</p>
<p>目前已经有一些实现UDP可靠传输的机制，比如</p>
<h3 id="UDT（UDP-based-Data-Transfer-Protocol）"><a href="#UDT（UDP-based-Data-Transfer-Protocol）" class="headerlink" title="UDT（UDP-based Data Transfer Protocol）"></a>UDT（UDP-based Data Transfer Protocol）</h3><p>基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。 由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</p>
<h2 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h2><p>Socket通信过程：先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<p>注意：accept 的第一个参数为服务器的 socket 描述字，是服务器开始调用 socket()函数生成 的，称为监听 socket 描述字；而 accept 函数返回的是已连接的 socket 描述字。一个服务器 通常通常仅仅只创建一个监听 socket 描述字，它在该服务器的生命周期内一直存在。内核 为每个由服务器进程接受的客户连接创建了一个已连接 socket 描述字，当服务器完成了对 某个客户的服务，相应的已连接 socket 描述字就被关闭。</p>
<h2 id="计网TCP-报文结构"><a href="#计网TCP-报文结构" class="headerlink" title="计网TCP 报文结构"></a>计网TCP 报文结构</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419092002255.png" alt="image-20210419092002255"></p>
<ul>
<li><p>源端口（Source Port）：16 位的源端口字段包含初始化通信的端口号。源端口和 IP 地址的 作用是标识报文的返回地址。 </p>
</li>
<li><p>目的端口(Destination Port):16 位的目的端口字段定义传输的目的。这个端口指明接收方计 算机上的应用程序接口。 l</p>
</li>
<li><p>序列号（Sequence Number，seq）:该字段用来标识 TCP 源端设备向目的端设备发送的字节 流，它表示在这个报文段中的第几个数据字节。序列号是一个 32 位的数。 l </p>
</li>
<li><p>确认号（Acknowledge Number，ack）：TCP 使用 32 位的确认号字段标识期望收到的下一 个段的第一个字节，并声明此前的所有数据已经正确无误地收到，因此，确认号应该是上 次已成功收到的数据字节序列号加 1！！！！。收到确认号的源计算机会知道特定的段已经 被收到。确认号的字段只在 ACK 标志被设置时才有效。 l </p>
</li>
<li><p>数据偏移（Data Offset）:这个 4 位字段包括 TCP 头大小。由于首部可能含有选项内容，因 此 TCP 首部的长度是不确定的。首部长度的单位是 32 比特或 4 个八位组。首部长度实际上 也指示了数据区在报文段中的起始偏移值。 l </p>
</li>
<li><p>保留（Reserved）:6 位置 0 的字段。为将来定义新的用途保留。、 l </p>
</li>
<li><p>控制位(Control Bits):共 6 位，每一位标志可以打开一个控制功能。 </p>
<ul>
<li> URG(Urgent Pointer Field Significant,紧急指针字段标志):表示 TCP 包的紧急指针字段有 效，用来保证 TCP 连接不被中断，并且督促中间齐备尽快处理这些数据。 </li>
<li> ACK（Acknowledgement field significant,确认字段标志）: 取 1 时表示应答字段有效，也 即 TCP 应答号将包含在 TCP 段中，为 0 则反之。 </li>
<li> PSH(Push Function,推功能)：这个标志表示 Push 操作。所谓 Push 操作就是指在数据包 到达接收端以后，立即送给应用程序，而不是在缓冲区中排队。 </li>
<li> RST（Reset the connection,重置连接）：这个标志表示感谢连接复位请求，用来复位那 些产生错误的连接，也被用来拒绝错误和非法的数据包。 </li>
<li> SYN（Synchronize sequence numbers,同步序列号）:表示同步序号，用来建立连接。 </li>
<li> FIN（No more data from sender）:表示发送端已经发送到数据末尾，数据传送完成，发 送 FIN 标志位的 TCP 段，连接将被断开。</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419095313348.png" alt="image-20210419095313348"></p>
<h1 id="60、TCP-协如何保证可靠传输。"><a href="#60、TCP-协如何保证可靠传输。" class="headerlink" title="60、TCP 协如何保证可靠传输。"></a>60、TCP 协如何保证可靠传输。</h1><ol>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="滑动窗口（流量控制）："><a href="#滑动窗口（流量控制）：" class="headerlink" title="滑动窗口（流量控制）："></a>滑动窗口（流量控制）：</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接 收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它 信息设置自己的窗口大小。 </p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字 节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不 是已发送并且已确认的状态；</p>
<p>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付 主机，就向右滑动接收窗口。 </p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送 方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。、</p>
<p>TCP 采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。发送窗口在连接建立时由双方商定。 但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值 （可增大或减小）</p>
<h3 id="1、为什么要设置窗口？"><a href="#1、为什么要设置窗口？" class="headerlink" title="1、为什么要设置窗口？"></a>1、为什么要设置窗口？</h3><p> 我们可以把窗口理解为缓冲区（但是有些窗口和缓冲区又不太一样）。 如果没有这些“窗口”，那么 TCP 每发送一段数据后都必须等到接收端确认后才能发送下一段 数据，这样做的话 TCP 传输的效率实在是太低了。 解决的办法就是在发送端等待确认的时候继续发送数据，假设发送到第 X 个数据段是收到接 收端的确认信息，如果 X 在可接受的范围内那么这样做也是可接受的。这就是窗口（缓冲区） 引入的缘由。 </p>
<ul>
<li> 接收端窗口</li>
</ul>
<p>rwnd 接收端缓冲区大小。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</p>
<ul>
<li> 拥塞窗口 cwnd（congestion window）</li>
</ul>
<p>网络拥塞限制缓冲区大小 </p>
<ul>
<li> 发送窗口 swnd 发送窗口的上限值 &#x3D; Min[rwnd，cwnd]</li>
</ul>
<p>当 rwnd &lt; cwnd 时，是接收端的接收能力限制发送窗口的最大值。 </p>
<p>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p>
<ul>
<li> 接收窗口和发送窗口的大小是相等的吗？</li>
</ul>
<p> 并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。 因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话， 这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口 是约等于的关系。</p>
<h3 id="2、窗口关闭"><a href="#2、窗口关闭" class="headerlink" title="2、窗口关闭"></a>2、窗口关闭</h3><p>定义：如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止， 这就是窗口关闭。 </p>
<p><strong>潜在危险：</strong></p>
<p> 接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。 那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报 文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。这会导致发送方一直 等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互 等待的过程，会造成了<strong>死锁</strong>的现象。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419102956614.png" alt="image-20210419102956614"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419103324274.png" alt="image-20210419103324274"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419103345018.png" alt="image-20210419103345018"></p>
<h2 id="（2）回退-N-针协议-流量控制"><a href="#（2）回退-N-针协议-流量控制" class="headerlink" title="（2）回退 N 针协议(流量控制)"></a>（2）回退 N 针协议(流量控制)</h2><ul>
<li><p>第一种：比特滑动窗口协议（停等协议）</p>
</li>
<li><p> 第二种：回退 N 帧协议</p>
</li>
</ul>
<p>发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内 仍收到确认帧，就要重发相应的数据帧。如：当发送方发送了 N 个帧后，若发现该 N 帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不 得不重新发送出错帧及其后的 N 帧</p>
<ul>
<li> 第三种：选择重传协议</li>
</ul>
<p>另一种效率更高的策略是当接收方发现某帧出错后，其后继续送来的正确的帧 虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在一个缓冲区中，同时要求 发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余 帧一并按正确的顺序递交高层。这种方法称为选择重发(SELECTICE REPEAT)，其工作过程如图 所示。显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间。</p>
<h1 id="61、拥塞控制"><a href="#61、拥塞控制" class="headerlink" title="61、拥塞控制"></a>61、拥塞控制</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419104618554.png" alt="image-20210419104618554"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105134581.png" alt="image-20210419105134581"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105252980.png" alt="image-20210419105252980"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419105508529.png" alt="image-20210419105508529"></p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
<li><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408171612061.png" alt="image-20210408171612061"></li>
<li><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408172025628.png" alt="image-20210408172025628"></li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419101627226.png" alt="image-20210419101627226"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419101928970.png" alt="image-20210419101928970"></p>
<h2 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h2><p> TCP 本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并 出有意义的信息呢？通常会有以下一些常用的方法：</p>
<p> 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接 收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。 </p>
<p>2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从 接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 </p>
<p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不 同的数据包拆分开。</p>
<h2 id="【计网】TCP-协议的四大计时器（超时重传）"><a href="#【计网】TCP-协议的四大计时器（超时重传）" class="headerlink" title="【计网】TCP 协议的四大计时器（超时重传）"></a>【计网】TCP 协议的四大计时器（超时重传）</h2><h3 id="1、重传计时器"><a href="#1、重传计时器" class="headerlink" title="1、重传计时器"></a>1、重传计时器</h3><p> 在一个 TCP 连接中，TCP 每发送一个报文段，就对此报文段设置一个超时重传计时器。若在 收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。</p>
<h3 id="2、持续计时器"><a href="#2、持续计时器" class="headerlink" title="2、持续计时器"></a>2、持续计时器</h3><p>为了对付零窗口大小通知，TCP 需要另一个计时器。 假定接收 TCP 宣布了窗口大小为零。发送 TCP 就停止传送报文段，直到接收 TCP 发送确认并 宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在 TCP 中，对确认是不需要发送确认的。若确认丢失了，接收 TCP 并不知道，而是会认为它已经完成任务了，并等待着发 送 TCP 接着会发送更多的报文段。但发送 TCP 由于没有收到确认，就等待对方发送确认来通 知窗口的大小。双方的 TCP 都在永远地等待着对方。要打开这种死锁，TCP 为每一个连接使 用一个坚持计时器。当发送 TCP 收到一个窗口大小为零的确认时，就启动坚持计时器。当坚 持计时器期限到时，发送 TCP 就发送一个特殊的报文段， 叫做 探测报文段 。这个报文段只 有一个字节的数据。它有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的 数据的确认时该序号也被忽略。探测报文段提醒对端：确认已丢失，必须重传。</p>
<h3 id="3、保活计时器"><a href="#3、保活计时器" class="headerlink" title="3、保活计时器"></a>3、保活计时器</h3><p> 保活计时器使用在某些实现中，用来防止在两个 TCP 之间的连接出现长时期的空闲。 假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故 障了。在这种情况下，这个连接将永远地处理打开状态。保活计时器每隔一段时间会超时， 超时后会检查连接是否空闲太久了，如果空闲的时间超过了设置时间，就会发送探测报文。 然后通过对端是否响应、响应是否符合预期，来判断对端是否正常，如果不正常，就主动关 闭连接，而不用等待 HTTP 层的关闭了。 </p>
<h3 id="4、时间等待计时器"><a href="#4、时间等待计时器" class="headerlink" title="4、时间等待计时器"></a>4、时间等待计时器</h3><p>时间等待计时器是在连接终止期间使用的。（TIME_WAIT） 当 TCP 关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间中，连 接还处于一种中间过渡状态。这就可以使重复的 FIN 报文段（如果有的话）可以到达目的站 因而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</p>
<h1 id="62、TCP长连接"><a href="#62、TCP长连接" class="headerlink" title="62、TCP长连接"></a>62、TCP长连接</h1><p>我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在<strong>两小时</strong>内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p>
<ul>
<li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送<strong>10个这样的探测，每个间隔75秒</strong>。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li>
<li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位<strong>，使得服务器终止这个连接</strong>。</li>
<li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li>
</ul>
<h1 id="63、什么时候用长连接，短连接？"><a href="#63、什么时候用长连接，短连接？" class="headerlink" title="63、什么时候用长连接，短连接？"></a><strong>63、什么时候用长连接，短连接？</strong></h1><p><strong>长连接</strong>多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：<strong>数据库的连接</strong>用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p>
<p>　　而像WEB网站的http服务一般都用<strong>短链接</strong>，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<h1 id="64、操作系统的内存管理主要是做什么？"><a href="#64、操作系统的内存管理主要是做什么？" class="headerlink" title="64、操作系统的内存管理主要是做什么？"></a>64、<strong>操作系统的内存管理主要是做什么？</strong></h1><p>操作系统的内存管理主要负责<strong>内存的分配与回收</strong>（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址<strong>转换</strong>成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h1 id="65、操作系统的内存管理机制了解吗？内存管理有哪几种方式"><a href="#65、操作系统的内存管理机制了解吗？内存管理有哪几种方式" class="headerlink" title="65、操作系统的内存管理机制了解吗？内存管理有哪几种方式?"></a>65、<strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></h1><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的</p>
<h1 id="66、-快表和多级页表"><a href="#66、-快表和多级页表" class="headerlink" title="66、 快表和多级页表]"></a>66、 快表和多级页表]</h1><p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>
<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li>多级页表如何节约内存：<a target="_blank" rel="noopener" href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p>
<h1 id="67、-分页机制和分段机制的共同点和区别"><a href="#67、-分页机制和分段机制的共同点和区别" class="headerlink" title="67、 分页机制和分段机制的共同点和区别"></a>67、 分页机制和分段机制的共同点和区别</h1><ol>
<li>共同点：<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别：<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h1 id="68、-逻辑-虚拟-地址和物理地址"><a href="#68、-逻辑-虚拟-地址和物理地址" class="headerlink" title="68、 逻辑(虚拟)地址和物理地址"></a>68、 逻辑(虚拟)地址和物理地址</h1><p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>
<p>🙋 <strong>我：</strong> em…好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h1 id="69、-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#69、-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="69、 CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>69、 CPU 寻址了解吗?为什么需要虚拟地址空间?</h1><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h1 id="70、-虚拟内存的技术实现"><a href="#70、-虚拟内存的技术实现" class="headerlink" title="70、 虚拟内存的技术实现"></a>70、 虚拟内存的技术实现</h1><p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>
<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h1 id="71、页面置换算法"><a href="#71、页面置换算法" class="headerlink" title="71、页面置换算法"></a>71、页面置换算法</h1><p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p>
</blockquote>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h1 id="AQS详解（面试）AbstractQueuedSynchronizer-可以叫做抽象队列同步器"><a href="#AQS详解（面试）AbstractQueuedSynchronizer-可以叫做抽象队列同步器" class="headerlink" title="AQS详解（面试）AbstractQueuedSynchronizer,可以叫做抽象队列同步器"></a>AQS详解（面试）AbstractQueuedSynchronizer,可以叫做抽象队列同步器</h1><p><strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>
<p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>
<p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong><br>AQS实现的具体方式如下：</p>
<p>![image-20210401160909636](C:\Users\mea su\Desktop\image-20210401160909636.png)</p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线y程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3-AQS-底层使用了模板方法模式"><a href="#6-2-3-AQS-底层使用了模板方法模式" class="headerlink" title="[6.2.3. AQS 底层使用了模板方法模式"></a>[6.2.3. AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<blockquote>
<p> 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p>
</blockquote>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code> countDown()</code> 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="6-3-AQS-组件总结"><a href="#6-3-AQS-组件总结" class="headerlink" title="6.3. AQS 组件总结"></a>6.3. AQS 组件总结</h3><ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="6-4-用过-CountDownLatch-么？什么场景下用的？"><a href="#6-4-用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="[6.4. 用过 CountDownLatch 么？什么场景下用的？"></a>[6.4. 用过 CountDownLatch 么？什么场景下用的？</h3><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<p>伪代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 处理文件的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//处理文件的业务操作</span></span><br><span class="line">          ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">          countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>有没有可以改进的地方呢？</strong></p>
<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line"> CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以接续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">        .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">        fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="ReentrantLock-公平锁，非公平锁"><a href="#ReentrantLock-公平锁，非公平锁" class="headerlink" title="ReentrantLock 公平锁，非公平锁"></a>ReentrantLock 公平锁，非公平锁</h3><p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p>
<p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>非公平锁的 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h1 id="72、内存屏蔽"><a href="#72、内存屏蔽" class="headerlink" title="72、内存屏蔽"></a>72、内存屏蔽</h1><h2 id="内存屏障的由来"><a href="#内存屏障的由来" class="headerlink" title="内存屏障的由来"></a>内存屏障的由来</h2><p>对于CPU的写，目前主流策略有两种：</p>
<p>1、write back：即CPU向内存写数据时，先把真实数据放入store buffer中，待到某个合适的时间点，CPU才会将store buffer中的数据刷到内存中，而且这两个操作是异步的。这在多线程环境中，有些情况下是可以接受的，但是有些情况是不可接受的，为了让程序员有能力根据业务需要达到同步完成，就设计了内存屏障。</p>
<p>2、write through：即CPU向内存写数据时，同步完成写store buffer与内存。</p>
<p>当前CPU大多数采用的是write back策略。可能有童鞋要问了：为什么呢？因为大多数情况下，CPU异步完成写内存产生的部分延迟是可以接受的，而且这个延迟极短。只有在多线程环境下需要严格保证内存可见等极少数特殊情况下才需要保证CPU的写在外界看来是同步完成的，需要借助CPU提供的内存屏障实现。如果直接采用策略2：write through，那每次写内存都需要等待数据刷入内存，极大影响了CPU的执行效率。</p>
<h2 id="内存屏障实现思路"><a href="#内存屏障实现思路" class="headerlink" title="内存屏障实现思路"></a>内存屏障实现思路</h2><p>为什么要插入屏障？本质是业务层面不能接受写store buffer与刷回内存这两个异步操作产生的哪怕是极少的延迟，即对内存可见性的要求极高。</p>
<p>内存屏障到底是什么？内存屏障什么都不是，它只是一个抽象概念，就像OOP。如果这样说你不理解，那你把他理解成一堵墙，这堵墙正面与反面的指令无法被CPU乱序执行及这堵墙正面与反面的读写操作需有序执行。</p>
<p>CPU提供了三个汇编指令串行化运行读写指令达到实现保证读写有序性的目的：</p>
<p>SFENCE：在该指令前的写操作必须在该指令后的写操作前完成</p>
<p>LFENCE：在该指令前的读操作必须在该指令后的读操作前完成</p>
<p>MFENCE：在该指令前的读写操作必须在该指令后的读写操作前完成</p>
<h1 id="73、操作系统锁有哪几种分类"><a href="#73、操作系统锁有哪几种分类" class="headerlink" title="73、操作系统锁有哪几种分类"></a>73、操作系统锁有哪几种分类</h1><p>　<strong>操作系统锁的种类1、读写锁(Read-Write Lock)</strong></p>
<p>　　适 用于一个特定的场合。比如对于一段线程间访问的数据，如果程序大部分时间都是在读取，而只有很少的时间才会写入，那么使用前面几种锁时，每次读取也是同样 要申请锁的，而这时其它的线程就无法再对此段数据进行读取。可是，多个线程同时对一段数据进行读取时，是不存在同步问题的，那么这些读取时设置的锁就影响 了程序的性能。读写锁的出现就是为了解决这个问题的。</p>
<p>　　对于一个读写锁，有两种获取方式：共享(Shared)或独占 (Exclusive)。如果当前读写锁处于空闲状态，那么当多个线程同时以共享方式访问该读写锁时，都可以成功;而此时如果一个线程以独占的方式访问该 读写锁，那么它会等待所有共享访问都结束后才可以成功。在读写锁被独占访问的过程中，再次共享和独占请求访问该锁，都会进行等待状态。</p>
<p>　　<strong>操作系统锁的种类2、互斥量 (Mutex)</strong></p>
<p>　　和二元信号量类似， 唯一不同的是，互斥量的获取和释放必须是在同一个线程中进行的。如果一个线程去释放一个并不是它所占有的互斥量是无效的。而信号量是可以由其它线程进行释放的。</p>
<p>　　<strong>操作系统锁的种类3、信号量(Semaphore)</strong></p>
<p>　　信号量分为二元信号量和多元信号量，所谓二元信号量就是指该信号量只有两个状态，要么被占用，要么空闲;而多元信号量则允许同时被N个线程占有，超出N个外的占用请求将被阻塞。信号量是“系统级别”的，即同一个信号量可以被不同的进程访问。</p>
<p>　　<strong>操作系统锁的种类4、临界区(Critical Section)</strong></p>
<p>　　术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区是“进程级别”的，即它只在本进程的所有线程中可见，其它性质与互斥量相同(即谁获取，谁释放)</p>
<p>　　<strong>操作系统锁的种类5、条件变量(Condition Variable)</strong></p>
<p>　　条件变量相当于一种通知机制。多个线程可以设置等待该条件变量，而一旦另外的线程设置了该条件变量(相当于唤醒条件变量)后，多个等待的线程就可以继续执行了。</p>
<h1 id="74、String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#74、String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="74、String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>74、String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h1><p><strong>可变性</strong></p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<h1 id="75、26-x3D-x3D-与-equals-重要"><a href="#75、26-x3D-x3D-与-equals-重要" class="headerlink" title="75、26. &#x3D;&#x3D; 与 equals(重要)"></a>75、26. &#x3D;&#x3D; 与 equals(重要)</h1><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型&#x3D;&#x3D;比较的是值，引用数据类型&#x3D;&#x3D;比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</li>
<li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相 应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。**<code>hashCode()</code>在散列表中才有用，在其它情况下没用**。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="java-sleep和wait的区别"><a href="#java-sleep和wait的区别" class="headerlink" title="java sleep和wait的区别"></a>java sleep和wait的区别</h1><ul>
<li><p>首先，要记住这个差别，“sleep是Thread类的方法,wait是Object类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</p>
</li>
<li><p>Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为。</p>
</li>
<li><p>Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify&#x2F;notifyAll才能够重新获得CPU执行时间。</p>
</li>
<li><p>新创建的但是没有执行（还没有调用start())的线程应该是处于“新建”状态，调用start()才进入“就绪”状态，在得到cpu资源以后才能开始执行run()进入“运行”状态。<br>注：线程在调用start()以后不会马上执行run()进入“运行”状态，而是要跟其他线程竞争cpu，在竞争中获得了cpu以后才能执行run()从而进入“运行”状态。</p>
</li>
<li><p>Thread.State.BLOCKED（阻塞）表示线程正在获取锁时，因为锁不能获取到而被迫暂停执行下面的指令，一直等到这个锁被别的线程释放。BLOCKED状态下线程，OS调度机制需要决定下一个能够获取锁的线程是哪个，这种情况下，就是产生锁的争用，无论如何这都是很耗时的操作。</p>
</li>
</ul>
<h1 id="工业化面试之-Redis-zset是如何实现的？"><a href="#工业化面试之-Redis-zset是如何实现的？" class="headerlink" title="工业化面试之 Redis zset是如何实现的？"></a>工业化面试之 Redis zset是如何实现的？</h1><h2 id="1、什么是zset"><a href="#1、什么是zset" class="headerlink" title="1、什么是zset?"></a>1、什么是zset?</h2><p>zset是 Redis五种数据结构中的一种（String、List、Hash、Set、Zset）。也称为sortedSet，它类似于Java里面是soretdSet和HashMap的结合体，因为它本身具有HashSet中不含重复元素的特性，又包含了SortedSet中内部有序的特性(通过传入一个score，根据score来排序)。但它内部的数据结构却与上述两种完全不同，它内部是通过一种名为 SkipList(跳跃表) 的数据结构来实现的。</p>
<h2 id="2、什么是skipList"><a href="#2、什么是skipList" class="headerlink" title="2、什么是skipList?"></a>2、什么是skipList?</h2><p>SkipList是一种随机化的数据结构，是一种层次化的链表结构，它使得在进行增删改查时，都能在可接收的时间范围内完成操作。</p>
<p>它的原理就是每次查找数据时，先在最上层查找，然后在定位到下一层，层层定位，最终找到目标数据，这种查找方式不用遍历整个链表，而是跳跃着查，这样就使得查找的时间复杂度退化到了logn（近似于二分查找），大大提高了查找效率。</p>
<p>一般来说，我们可以按下一层的链表来构造上一层的链表，举个例子，最下一层是所有数据构成的链表，我们将它分段，隔一个节点构造一个新的节点，这样，第二层的链表长度就是第一层的一半，第三层又是第二层的一半，以此类推。但是这里我们会发现一个严重的问题，每次对zset进行更新时，需要重新构建zset，这又增加了时间复杂度，所以zset在构建skiplist的时候，就给每个节点赋予了一个随机的层数，这样就避免了重新构建。</p>
<h2 id="3、为什么不使用List-红黑树或平衡二叉树呢？"><a href="#3、为什么不使用List-红黑树或平衡二叉树呢？" class="headerlink" title="3、为什么不使用List\红黑树或平衡二叉树呢？"></a>3、为什么不使用List\红黑树或平衡二叉树呢？</h2><p>我们知道，List是顺序存储，访问速度很快，但是添加和删除操作是一个(On)的操作，对于Redis这样要求高写入和高读取的数据库来说，List显然不能满足其要求。</p>
<p>至于红黑树和平衡二叉树，每次更新redis的值，都要调整树结构，这样会造成额外的开销，而跳跃表只需要调整表局部的链表结构就行，显然跳跃表更适合。</p>
<p>最后一个原因：跳跃表实现起来更简单：）</p>
<h2 id="4、跳跃表的层数可以一直增加下去吗？"><a href="#4、跳跃表的层数可以一直增加下去吗？" class="headerlink" title="4、跳跃表的层数可以一直增加下去吗？"></a>4、跳跃表的层数可以一直增加下去吗？</h2><p>不能， 用数学的概念来解释，就是一个新建的节点有 50% 的概率被分配到 Level 1，25% 的概率被分配到 Level 2，12.5% 的概率被分配到 Level 3，以此类推…有 2-63的概率被分配到最顶层，因为这里每一层的晋升率都是 50%。只有当第一层节点数量达到是264时，也就是说层数到达32时，才可能被分到最顶层，因此，跳跃表的层数最大只能到达32层，这也被源码ZSKIPLIST_MAXLEVEL 定义了</p>
<h1 id="76、枚举类型"><a href="#76、枚举类型" class="headerlink" title="76、枚举类型"></a>76、枚举类型</h1><h2 id="1-使用-x3D-x3D-比较枚举类型"><a href="#1-使用-x3D-x3D-比较枚举类型" class="headerlink" title="1.使用 &#x3D;&#x3D; 比较枚举类型"></a>1.使用 &#x3D;&#x3D; 比较枚举类型</h2><p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用 <code>==</code> 运算符比较两个变量，如上例所示；此外，<code>==</code> 运算符可提供编译时和运行时的安全性。</p>
<p>首先，让我们看一下以下代码段中的运行时安全性，其中 <code>==</code> 运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>
<h2 id="2-通过枚举实现一些设计模式"><a href="#2-通过枚举实现一些设计模式" class="headerlink" title="2. 通过枚举实现一些设计模式"></a>2. 通过枚举实现一些设计模式</h2><h3 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h3><p>通常，使用类实现 Singleton 模式并非易事，枚举提供了一种实现单例的简便方法。</p>
<p>《Effective Java 》和《Java与模式》都非常推荐这种方式，使用这种方式方式实现枚举可以有什么好处呢？</p>
<p>《Effective Java》</p>
<blockquote>
<p>这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton的最佳方法。 —-《Effective Java 中文版 第二版》</p>
</blockquote>
<p>《Java与模式》</p>
<blockquote>
<p>《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
</blockquote>
<p>下面的代码段显示了如何使用枚举实现单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaDeliverySystemConfiguration</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class="line">        <span class="comment">// Initialization configuration which involves</span></span><br><span class="line">        <span class="comment">// overriding defaults like delivery strategy</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PizzaDeliveryStrategy</span> <span class="variable">deliveryStrategy</span> <span class="operator">=</span> PizzaDeliveryStrategy.NORMAL;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PizzaDeliverySystemConfiguration <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> PizzaDeliveryStrategy <span class="title function_">getDeliveryStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deliveryStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>PizzaDeliverySystemConfiguration.getInstance()</code> 获取的就是单例的 <code>PizzaDeliverySystemConfiguration</code></p>
<h1 id="77、集合类型"><a href="#77、集合类型" class="headerlink" title="77、集合类型"></a>77、集合类型</h1><h3 id="1-4-9-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-4-9-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.4.9. ConcurrentHashMap 和 Hashtable 的区别"></a>1.4.9. ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p>![image-20210404162534518](C:\Users\mea su\Desktop\image-20210404162534518.png)</p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h4 id="1-4-10-1-JDK1-7（上面有示意图）"><a href="#1-4-10-1-JDK1-7（上面有示意图）" class="headerlink" title="[1.4.10.1. JDK1.7（上面有示意图）"></a>[1.4.10.1. JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<h4 id="1-4-10-2-JDK1-8-（上面有示意图）"><a href="#1-4-10-2-JDK1-8-（上面有示意图）" class="headerlink" title="[1.4.10.2. JDK1.8 （上面有示意图）"></a>[1.4.10.2. JDK1.8 （上面有示意图）</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h3 id="2-初始化-initTable"><a href="#2-初始化-initTable" class="headerlink" title="2. 初始化 initTable"></a>2. 初始化 initTable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        ／／　如果 sizeCtl &lt; <span class="number">0</span> ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
<h1 id="78、并发"><a href="#78、并发" class="headerlink" title="78、并发"></a>78、并发</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="三种线程池工具类创建线程池方法，三种方法实际都是ThreadPoolExcutor类"><a href="#三种线程池工具类创建线程池方法，三种方法实际都是ThreadPoolExcutor类" class="headerlink" title="三种线程池工具类创建线程池方法，三种方法实际都是ThreadPoolExcutor类"></a>三种线程池工具类创建线程池方法，三种方法实际都是ThreadPoolExcutor类</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422210840955.png" alt="image-20210422210840955"></p>
<h3 id="线程池的阻塞队列"><a href="#线程池的阻塞队列" class="headerlink" title="线程池的阻塞队列"></a>线程池的阻塞队列</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422213026119.png" alt="image-20210422213026119"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422213540264.png" alt="image-20210422213540264"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215617327.png" alt="image-20210422215617327"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215850565.png" alt="image-20210422215850565"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422215941606.png" alt="image-20210422215941606"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422220813121.png" alt="image-20210422220813121"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422221723963.png" alt="image-20210422221723963"></p>
<p>第四种，自己设置阻塞时间，时间到后不再阻塞。</p>
<p>Synchronousueue队列实际因为实际相当于单个元素队列，所以存入一个元素后，不取出，再存储就会一直阻塞。</p>
<p>下图为传统人工控制线程，新版concurrent包出来后，就由阻塞队列配合while等来自动实现控制阻塞与否。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422225831090.png" alt="image-20210422225831090"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422230012098.png" alt="image-20210422230012098"></p>
<p>多线程程序判定资源这里都使用while（文档就这样建议），而不是if，否则多线程情况下</p>
<h3 id="Synchornized-不需要手动释放锁且异常能自动释放锁，因为有两个Monitorexit"><a href="#Synchornized-不需要手动释放锁且异常能自动释放锁，因为有两个Monitorexit" class="headerlink" title="Synchornized 不需要手动释放锁且异常能自动释放锁，因为有两个Monitorexit"></a>Synchornized 不需要手动释放锁且异常能自动释放锁，因为有两个Monitorexit</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422231316848.png" alt="image-20210422231316848"></p>
<h3 id="LOCK的精确唤醒"><a href="#LOCK的精确唤醒" class="headerlink" title="LOCK的精确唤醒"></a>LOCK的精确唤醒</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422235046738.png" alt="image-20210422235046738"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422234654060.png" alt="image-20210422234654060"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422234902879.png" alt="image-20210422234902879"></p>
<h3 id="2-2-程序计数器为什么是私有的"><a href="#2-2-程序计数器为什么是私有的" class="headerlink" title="2.2. 程序计数器为什么是私有的?"></a>2.2. 程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="2-3-虚拟机栈和本地方法栈为什么是私有的"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="2.3. 虚拟机栈和本地方法栈为什么是私有的?"></a>2.3. 虚拟机栈和本地方法栈为什么是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="2-4-一句话简单了解堆和方法区"><a href="#2-4-一句话简单了解堆和方法区" class="headerlink" title="2.4. 一句话简单了解堆和方法区"></a>2.4. 一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="线程池7大参数"><a href="#线程池7大参数" class="headerlink" title="线程池7大参数"></a>线程池7大参数</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423153747460.png" alt="image-20210423153747460"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423153917512.png" alt="image-20210423153917512"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210423171454116.png" alt="image-20210423171454116"></p>
<p>2.3的意思是，阻塞队列满后，线程池没满，新建线程会被阻塞队列外的新任务抢占。</p>
<h2 id="7-什么是上下文切换"><a href="#7-什么是上下文切换" class="headerlink" title="7. 什么是上下文切换?"></a>7. 什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<h3 id="8-2-如何避免线程死锁"><a href="#8-2-如何避免线程死锁" class="headerlink" title="8.2. 如何避免线程死锁?"></a>8.2. 如何避免线程死锁?</h3><p>我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p>
<ol>
<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<h2 id="单例模式（双重检验锁方式）"><a href="#单例模式（双重检验锁方式）" class="headerlink" title="单例模式（双重检验锁方式）"></a>单例模式（双重检验锁方式）</h2><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-构造方法可以使用-synchronized-关键字修饰么？"><a href="#1-3-构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="1.3. 构造方法可以使用 synchronized 关键字修饰么？"></a>1.3. 构造方法可以使用 synchronized 关键字修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h2 id="2-volatile-关键字"><a href="#2-volatile-关键字" class="headerlink" title="2. volatile 关键字"></a>2. volatile 关键字</h2><h3 id="2-2-讲一下-JMM-Java-内存模型"><a href="#2-2-讲一下-JMM-Java-内存模型" class="headerlink" title="2.2. 讲一下 JMM(Java 内存模型)"></a>2.2. 讲一下 JMM(Java 内存模型)</h3><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p>要解决这个问题，就需要把变量声明为**<code>volatile</code>**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p>所以，**<code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**</p>
<h3 id="2-3-并发编程的三个重要特性"><a href="#2-3-并发编程的三个重要特性" class="headerlink" title="2.3. 并发编程的三个重要特性"></a>2.3. 并发编程的三个重要特性</h3><ol>
<li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<h3 id="2-4-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-4-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.4. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.4. 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以**<code>volatile </code>性能肯定比<code>synchronized</code>关键字要好<strong>。但是</strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块**。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<p>变量被定义为 volatile 后具备两种特性：</p>
<p> （1）保证变量对所有线程可见：当一条线程修改了变量值，新值对于其他线程来说是立即 可以得知的。volatile 变量在各个线程的工作内存中不存在一致性问题，但 Java 的运算操 作符并非原子操作，导致 volatile 变量运算在并发下仍不安全。 </p>
<p>（2）禁止指令重排序优化：使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相 当于一个内存屏障，后面的指令不能重排到内存屏障之前。使用 lock 前缀引发两件事：① 将当前处理器缓存行的数据写回系统内存。②使其他处理器的缓存无效。相当于对缓存变量 做了一次 store 和 write 操作，让 volatile 变量的修改对其他处理器立即可见。 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile 关 键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏）<strong>，内存屏障会提供 3 个功能：</strong> </p>
<ul>
<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指 令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完 成； </p>
</li>
<li><p>它会强制将对缓存的修改操作立即写入主存； </p>
</li>
<li><p>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</p>
</li>
</ul>
<h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><h3 id="3-1-ThreadLocal-简介"><a href="#3-1-ThreadLocal-简介" class="headerlink" title="3.1. ThreadLocal 简介"></a>3.1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h3 id="3-2-ThreadLocal-示例"><a href="#3-2-ThreadLocal-示例" class="headerlink" title="3.2. ThreadLocal 示例"></a>3.2. ThreadLocal 示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExample</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread Name= 0 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 0 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 1 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 1 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 3 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 3 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 5 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 5 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 6 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 6 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 7 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 7 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 8 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 9 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 8 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 9 formatter = yy-M-d ah:mmCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="3-3-ThreadLocal-原理"><a href="#3-3-ThreadLocal-原理" class="headerlink" title="3.3. ThreadLocal 原理"></a>3.3. ThreadLocal 原理</h3><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/threadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ThreadLocal数据结构"></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="ThreadLocal内部类"></p>
<h3 id="3-4-ThreadLocal-内存泄露问题"><a href="#3-4-ThreadLocal-内存泄露问题" class="headerlink" title="3.4. ThreadLocal 内存泄露问题]"></a>3.4. ThreadLocal 内存泄露问题]</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line"></span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="built_in">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h3 id="GC-之后key是否为null？"><a href="#GC-之后key是否为null？" class="headerlink" title="[GC 之后key是否为null？"></a>[GC 之后key是否为null？</h3><p>回应开头的那个问题， <code>ThreadLocal</code> 的<code>key</code>是弱引用，那么在<code>ThreadLocal.get()</code>的时候,发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常new出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用SoftReference修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<h3 id="4-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#4-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="4.2. 实现 Runnable 接口和 Callable 接口的区别"></a>4.2. 实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。**<code>Runnable</code> 接口<strong>不会返回结果或抛出检查异常，但是</strong><code>Callable</code> 接口<strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **<code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<h2 id="六-ConcurrentSkipListMap"><a href="#六-ConcurrentSkipListMap" class="headerlink" title="六 ConcurrentSkipListMap]"></a>六 ConcurrentSkipListMap]</h2><p>下面这部分内容参考了极客时间专栏<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&utm_term=SPoster">《数据结构与算法之美》</a>以及《实战 Java 高并发程序设计》。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p><strong>为了引出 ConcurrentSkipListMap，先带着大家简单理解一下跳表。</strong></p>
<p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>
<p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg" alt="2级索引跳表"></p>
<p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg" alt="在跳表中查找元素18"></p>
<p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p>
<p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p>
<p>使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。</p>
<h1 id="79、反射"><a href="#79、反射" class="headerlink" title="79、反射"></a>79、反射</h1><h3 id="反射的优势和劣势"><a href="#反射的优势和劣势" class="headerlink" title="反射的优势和劣势"></a>反射的优势和劣势</h3><p>  个人理解，反射机制实际上就是上帝模式，如果说方法的调用是 Java 正确的打开方式，那反射机制就是上帝偷偷开的后门，只要存在对应的class，一切都能够被调用。</p>
<p>  那上帝为什么要打开这个后门呢？这涉及到了静态和动态的概念</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
<p>  两者的区别在于，动态编译可以最大程度地支持多态，而多态最大的意义在于降低类的耦合性，因此反射的优点就很明显了：解耦以及提高代码的灵活性。</p>
<p>  因此，反射的优势和劣势分别在于：</p>
<ul>
<li>优势<ul>
<li>运行期类型的判断，动态类加载：提高代码灵活度</li>
</ul>
</li>
<li>劣势<ul>
<li>性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多</li>
</ul>
</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>  在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架，也是利用CGLIB 反射机制才得以实现，下面就举例最常见的两个例子，来说明反射机制的强大之处：</p>
<ul>
<li>JDBC 的数据库的连接</li>
</ul>
<p>在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成</p>
<ol>
<li>通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）</li>
<li>通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码</li>
<li>通过Connection 接口接收连接</li>
</ol>
<p><strong>动态代理</strong></p>
<p>使用反射可以在运行时创建接口的动态实现，java.lang.reflect.Proxy类提供了创建动态实现的功能。我们把运行时创建接口的动态实现称为动态代理。</p>
<p>动态代理可以用于许多不同的目的，例如数据库连接和事务管理、用于单元测试的动态模拟对象以及其他类似aop的方法拦截等。</p>
<p><strong>创建代理</strong></p>
<p>调用java.lang.reflect.Proxy类的newProxyInstance()方法就可以常见动态代理，newProxyInstance()方法有三个参数： 1、用于“加载”动态代理类的类加载器。<br>2、要实现的接口数组。 3、将代理上的所有方法调用转发到InvocationHandler的对象。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">                            MyInterface.class.getClassLoader(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; MyInterface.class &#125;,</span><br><span class="line">                            handler);</span><br></pre></td></tr></table></figure>

<p>运行上面代码后，proxy变量包含了MyInterface接口的动态实现。</p>
<p>对代理的所有调用都将由到实现了InvocationHandler接口的handler 对象来处理。</p>
<p><strong>InvocationHandler</strong><br>如上面说的一样，必须将InvocationHandler的实现传递给Proxy.newProxyInstance()方法。对动态代理的所有方法调用都转发到实现接口的InvocationHandler对象。 InvocationHandler代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">  Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">         <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现InvocationHandler接口的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//do something &quot;dynamic&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细介绍传递给invoke方法的三个参数。</p>
<p>Object proxy参数，实现接口的动态代理对象。通常不需要这个对象。</p>
<p>Method method参数，表示在动态代理实现的接口上调用的方法。通过Method对象，可以获取到方法名，参数类型，返回类型等信息。</p>
<p>Object[] args参数，包含调用接口中实现的方法时传递给代理的参数值。注意：如果接口中的参数是int、long等基本数据时，这里的args必须使用Integer, Long等包装类型。</p>
<p>上面代码中会生成一个MyInterface接口的对象proxy，通过proxy对象调用的方法都会由MyInvocationHandler类的invoke方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Object tar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定委托对象，并返回代理类</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object tar)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.tar = tar;</span><br><span class="line">        <span class="comment">//绑定该类实现的所有接口，取得代理类 </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(tar.getClass().getClassLoader(),</span><br><span class="line">                                      tar.getClass().getInterfaces(),</span><br><span class="line">                                      <span class="built_in">this</span>);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy , Method method , Object[] args)</span><span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这里就可以进行所谓的AOP编程了</span></span><br><span class="line">        <span class="comment">//在调用具体函数方法前，执行功能处理</span></span><br><span class="line">        result = method.invoke(tar,args);</span><br><span class="line">        <span class="comment">//在调用具体函数方法后，执行功能处理</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>动态代理使用场景：<br>1、数据库连接和事务管理。例如Spring框架有一个事务代理，可以启动和提交&#x2F;回滚事务<br>2、用于单元测试的动态模拟对象<br>3、类似AOP的方法拦截。</p>
<p>本文重点介绍了如何通过反射获取到某个类的方法、成员变量、构造函数等信息，同时也介绍动态代理的用法，这些都是反射的基础功能，反射的其他功能里就不一一介绍了</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20794107">https://www.zhihu.com/question/20794107</a></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>​		字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体 使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户 信息会经过一次反序列化的过程。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210613204612552.png" alt="image-20210613204612552"></p>
<p><strong>计数</strong>  </p>
<p>如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521153308427.png" alt="image-20210521153308427"></p>
<p>缓存穿透时：</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521160457471.png" alt="image-20210521160457471"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/reecelin/p/13358432.html">https://www.cnblogs.com/reecelin/p/13358432.html</a></p>
<p>实现有ziplist,quicklist,linkedlist(和JAVA中的LinkedList类似)</p>
<p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是<strong>链表</strong>而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。</p>
<p> 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。 </p>
<p>Redis 的列表结构常用来做<strong>异步队列</strong>使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210613210924869.png" alt="image-20210613210924869"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132047143.png" alt="image-20210419132047143"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132207741.png" alt="image-20210419132207741"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132329986.png" alt="image-20210419132329986"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419132850592.png" alt="image-20210419132850592"></p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>在rehash过程中，并不会将ht[0]的数据，一次性的rehash到ht[1]中（键值对数量过多，会造成Redis在一段时间内不可用），渐进式的将ht[0]中的数据rehash到ht[1]的步骤如下：</p>
<p>为ht[1]分配空间，让字典中同时持有ht[0]和ht[1]两个哈希表。<br>在字典中维持一个索引计数器变量，rehashidx，并将它的值设置为0，rehash正式开始。<br>在rehash期间，每次对于字典的crud操作，除了要执行指定的操作之外，还会将ht[0]哈希表在rehashidx索引上的所有的键值对rehash到ht[1]上，然后将rehashidx属性值增加1。<br>当ht[0]上所有的键值对都rehash到ht[1]上之后，会将rehashidx的值设置为-1，表示rehash的全部工作完成。<br>在执行rehash期间，字典的删除、查找、更新操作，会在ht[0]、ht[1]两个哈希表上进行，添加操作只会在ht[1]上进行操作，不会在ht[0]上操作，以保证ht[0]中键值对的数量只减不增，并随着rehash，逐渐变为空表。<br><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210419133117549.png" alt="image-20210419133117549"></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144100174.png" alt="image-20210421144100174"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144302599.png" alt="image-20210421144302599"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144720889.png"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421144640940.png" alt="image-20210421144640940"></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421161341573.png" alt="image-20210421161341573"></p>
<h2 id="模拟秒杀过程"><a href="#模拟秒杀过程" class="headerlink" title="模拟秒杀过程"></a>模拟秒杀过程</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421161851846.png" alt="image-20210421161851846"></p>
<p>线程池解决连接超时问题，乐观锁（Watch）解决超卖问题，但是乐观锁会可能导致库存遗留问题（因为版本号问题，一个提交后，其他的后续提交会失败，最后会导致库存遗留）。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421173613994.png" alt="image-20210421173613994"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421174031846.png" alt="image-20210421174031846"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210421175635747.png" alt="image-20210421175635747"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422123109167.png" alt="image-20210422123109167"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422121110896.png" alt="image-20210422121110896"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422121544516.png" alt="image-20210422121544516"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122327692.png" alt="image-20210422122327692"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122720437.png" alt="image-20210422122720437"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422122909784.png" alt="image-20210422122909784"></p>
<p>且重新变为从机时，会复制主机中的所有信息进从机。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422124345574.png" alt="image-20210422124345574"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422124406141.png" alt="image-20210422124406141"></p>
<p>薪火相传：从服务器下面还可以有从服务器。</p>
<p>反客为主：主机挂掉后，从机变为主机</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422125116192.png" alt="image-20210422125116192"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422125825477.png" alt="image-20210422125825477"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422130233619.png" alt="image-20210422130233619"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422131038527.png" alt="image-20210422131038527"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422131254856.png" alt="image-20210422131254856"></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：<img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140026740.png" alt="image-20210422140026740"></h3><h3 id="无中心化集群：任意一台服务器-都可以互相连通"><a href="#无中心化集群：任意一台服务器-都可以互相连通" class="headerlink" title="无中心化集群：任意一台服务器 都可以互相连通"></a>无中心化集群：任意一台服务器 都可以互相连通</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140613390.png" alt="image-20210422140613390"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422140905552.png" alt="image-20210422140905552"></p>
<p>LInux命令（集体替换）：%s&#x2F;6379&#x2F;6380</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>热点数据过期，大量请求进入数据库</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422143707735.png" alt="image-20210422143707735"></p>
<h2 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144148409.png" alt="image-20210422144148409"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144309260.png" alt="image-20210422144309260"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144653939.png" alt="image-20210422144653939"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144706794.png" alt="image-20210422144706794"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144907890.png" alt="image-20210422144907890"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422144942473.png" alt="image-20210422144942473"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422145011160.png" alt="image-20210422145011160"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422145642192.png" alt="image-20210422145642192"></p>
<h2 id="分布式锁的误删问题："><a href="#分布式锁的误删问题：" class="headerlink" title="分布式锁的误删问题："></a>分布式锁的误删问题：</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422151428111.png" alt="image-20210422151428111"></p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422204842558.png" alt="image-20210422204842558"></p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210408234411875.png" alt="image-20210408234411875"></p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="[2.1 程序计数器"></a>[2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="[2.2 Java 虚拟机栈"></a>[2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常异常。</li>
</ul>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="img"></p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法&#x2F;函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="[2.3 本地方法栈"></a>[2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="[2.4 堆"></a>[2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7"></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8"></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">  <span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
</blockquote>
<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>
<li>……</li>
</ol>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="[2.5 方法区]"></a>[2.5 方法区]</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h4 id="2-5-1-方法区和永久代的关系"><a href="#2-5-1-方法区和永久代的关系" class="headerlink" title="[2.5.1 方法区和永久代的关系]"></a>[2.5.1 方法区和永久代的关系]</h4><blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<h4 id="2-5-2-常用参数"><a href="#2-5-2-常用参数" class="headerlink" title="[2.5.2 常用参数]"></a>[2.5.2 常用参数]</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGenCopy to </span></span><br></pre></td></tr></table></figure>

<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h4 id="2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="[2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?]"></a>[2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?]</h4><ol>
<li><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
</li>
</ol>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<ol>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
</ol>
<h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="[2.6 运行时常量池]"></a>[2.6 运行时常量池]</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p>
<blockquote>
<p>修正(<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>)：</p>
<ol>
<li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<p>相关问题：JVM 常量池中存储的是对象还是引用呢？： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/57109429/answer/151717241">https://www.zhihu.com/question/57109429/answer/151717241</a> by RednaxelaFX</p>
<h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="[2.7 直接内存"></a>[2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input&#x2F;Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="[三 HotSpot 虚拟机对象探秘]"></a>[三 HotSpot 虚拟机对象探秘]</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="[3.1 对象的创建]"></a>[3.1 对象的创建]</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。 <img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程"></p>
<h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="[Step1:类加载检查]"></a>[Step1:类加载检查]</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="[Step2:分配内存"></a>[Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式"></p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="[Step3:初始化零值]"></a>[Step3:初始化零值]</h4><h4 id="内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在-Java-代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。"><a href="#内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在-Java-代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。" class="headerlink" title="内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。"></a>内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</h4><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="[Step4:设置对象头]"></a>[Step4:设置对象头]</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="[Step5:执行 init 方法]"></a>[Step5:执行 init 方法]</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="[3.2 对象的内存布局]"></a>[3.2 对象的内存布局]</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="[3.3 对象的访问定位]"></a>[3.3 对象的访问定位]</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄"></p>
</li>
<li><p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
</li>
</ol>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针"></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="四-重点补充内容"><a href="#四-重点补充内容" class="headerlink" title="[四 重点补充内容]"></a>[四 重点补充内容]</h2><h3 id="4-1-String-类和常量池"><a href="#4-1-String-类和常量池" class="headerlink" title="[4.1 String 类和常量池]"></a>[4.1 String 类和常量池]</h3><p><strong>String 对象的两种创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;<span class="comment">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>这两种不同的创建方法是有差别的。</p>
<ul>
<li>第一种方式是在常量池中拿对象；</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<p>再给大家一个图应该更容易理解，图片来源：<a target="_blank" rel="noopener" href="https://www.journaldev.com/797/what-is-java-string-pool%EF%BC%9A">https://www.journaldev.com/797/what-is-java-string-pool：</a></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3String-Pool-Java1-450x249.png" alt="String-Pool-Java"></p>
<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">         </span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png" alt="字符串拼接"></p>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<h3 id="4-2-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#4-2-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="[4.2 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？]"></a>[4.2 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？]</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<p><strong>验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 trueCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">trueCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="4-3-8-种基本类型的包装类和常量池"><a href="#4-3-8-种基本类型的包装类和常量池" class="headerlink" title="[4.3 8 种基本类型的包装类和常量池]"></a>[4.3 8 种基本类型的包装类和常量池]</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/461">参见issue&#x2F;461</a>）性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;         </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>Integer 缓存源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1&#x3D;40；Java 在编译的时候会直接将代码封装成 Integer i1&#x3D;Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 &#x3D; new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>Integer 比较更丰富的一个例子:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));     Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1=i2   true</span><br><span class="line">i1=i2+i3   true</span><br><span class="line">i1=i4   false</span><br><span class="line">i4=i5   false</span><br><span class="line">i4=i5+i6   true</span><br><span class="line">40=i5+i6   trueCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>语句 i4 &#x3D;&#x3D; i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 &#x3D;&#x3D; 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 &#x3D;&#x3D; 40 进行数值比较。</p>
<h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="[1 揭开 JVM 内存分配与回收的神秘面纱"></a>[1 揭开 JVM 内存分配与回收的神秘面纱</h2><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="[1.1 对象优先在 eden 区分配]"></a>[1.1 对象优先在 eden 区分配]</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>通过以下方式运行： <img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25178350.png" alt="img"></p>
<p>添加的参数：<code>-XX:+PrintGCDetails</code> <img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10317146.png" alt="img"></p>
<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg" alt="img"></p>
<p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg" alt="img"></p>
<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="[1.2 大对象直接进入老年代]"></a>[1.2 大对象直接进入老年代]</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="[1.3 长期存活的对象将进入老年代]"></a>[1.3 长期存活的对象将进入老年代]</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="[1.4 动态对象年龄判定"></a>[1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">    <span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">    <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    uint age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">        <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">        total += sizes[age];</span><br><span class="line">        <span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>额外补充说明(<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong> 如果你去 Oracle 的官网阅读<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>
<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p>
</blockquote>
<h3 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="[1.5 主要进行 gc 的区域"></a>[1.5 主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p>
<blockquote>
<p><del><em>“老年代 GC（Major GC&#x2F;Full GC），指发生在老年代的 GC……”</em></del></p>
</blockquote>
<p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/b48228c2-ac00-4668-a78f-6f221f8563b5.png" alt="img"></p>
<p><strong>总结：</strong></p>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="[2 对象已经死亡？"></a>[2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11034259.png" alt="img"></p>
<h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="[2.1 引用计数法"></a>[2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="[2.2 可达性分析算法]"></a>[2.2 可达性分析算法]</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/72762049.png" alt="可达性分析算法 "></p>
<p>可作为 GC Roots 的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="[2.3 再谈引用"></a>[2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="[2.4 不可达的对象并非“非死不可”"></a>[2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h3 id="2-5-如何判断一个常量是废弃常量？"><a href="#2-5-如何判断一个常量是废弃常量？" class="headerlink" title="[2.5 如何判断一个常量是废弃常量？"></a>[2.5 如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>
<p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p>
<blockquote>
<p>修正(<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>)：</p>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="[2.6 如何判断一个类是无用的类"></a>[2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="二-Class-文件结构总结"><a href="#二-Class-文件结构总结" class="headerlink" title="[二 Class 文件结构总结"></a>[二 Class 文件结构总结</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p>
<p><strong>Class文件字节码结构组织示意图</strong> （之前在网上保存的，非常不错，原出处不明）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类文件字节码结构组织示意图"></p>
<h3 id="2-1-魔数"><a href="#2-1-魔数" class="headerlink" title="[2.1 魔数"></a>[2.1 魔数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p>
<p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p>
<h3 id="2-2-Class-文件版本"><a href="#2-2-Class-文件版本" class="headerlink" title="[2.2 Class 文件版本"></a>[2.2 Class 文件版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="[2.3 常量池"></a>[2.3 常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志（tag）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>
<h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="[2.4 访问标志"></a>[2.4 访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p>
<p>我们定义了一个 Employee 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p>
<h3 id="2-5-当前类索引-父类索引与接口索引集合"><a href="#2-5-当前类索引-父类索引与接口索引集合" class="headerlink" title="[2.5 当前类索引,父类索引与接口索引集合"></a>[2.5 当前类索引,父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>
<h3 id="2-6-字段表集合"><a href="#2-6-字段表集合" class="headerlink" title="[2.6 字段表集合"></a>[2.6 字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p><strong>字段的 access_flag 的取值:</strong></p>
<h3 id="2-7-方法表集合"><a href="#2-7-方法表集合" class="headerlink" title="[2.7 方法表集合]"></a>[2.7 方法表集合]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>方法表的 access_flag 取值：</strong></p>
<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<h3 id="2-8-属性表集合"><a href="#2-8-属性表集合" class="headerlink" title="[2.8 属性表集合"></a>[2.8 属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h2 id="回顾一下类加载过程"><a href="#回顾一下类加载过程" class="headerlink" title="[回顾一下类加载过程]"></a>[回顾一下类加载过程]</h2><p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<p>所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。</p>
<h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="[类加载器总结]"></a>[类加载器总结]</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ol>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="[双亲委派模型]"></a>[双亲委派模型]</h3><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="[双亲委派模型介绍]"></a>[双亲委派模型介绍]</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p>
<p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#x27;s ClassLoader is null</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code> <code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p>
<p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方API文档对这部分的描述如下:</p>
<blockquote>
<p>The Java platform uses a delegation model for loading classes. <strong>The basic idea is that every class loader has a “parent” class loader.</strong> When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p>
</blockquote>
<h3 id="双亲委派模型实现源码分析"><a href="#双亲委派模型实现源码分析" class="headerlink" title="[双亲委派模型实现源码分析"></a>[双亲委派模型实现源码分析</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="[双亲委派模型的好处"></a>[双亲委派模型的好处</h3><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h3 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="[如果我们不想用双亲委派模型怎么办？"></a>[如果我们不想用双亲委派模型怎么办？</h3><p><del>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</del></p>
<p>完善修正（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/871">issue871</a>：类加载器一问的补充说明）：</p>
<p><strong>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</strong></p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="[自定义类加载器"></a>[自定义类加载器</h3><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="[类的生命周期]"></a>[类的生命周期]</h2><p>一个类的完整生命周期如下：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt="img"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="[类加载过程]"></a>[类加载过程]</h3><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p>
<p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="[加载"></a>[加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为<strong>方法区</strong>的运行时数据结构</li>
<li>在内存（<strong>堆）中生成一个代表该类的 Class 对象</strong>,作为方法区这些数据的访问入口</li>
</ol>
<p>虚拟机规范上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p>
<p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="[验证"></a>[验证</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" alt="验证阶段示意图"></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="[准备]"></a>[准备]</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<p><strong>基本数据类型的零值：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="[解析]"></a>[解析]</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="[初始化]"></a>[初始化]</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程。</p>
<p>对于<code>&lt;clinit&gt;（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul>
<li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li>
<li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li>
<li><strong>「补充，来自<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="[卸载]"></a>[卸载]</h3><p>卸载类即该类的Class对象被GC。</p>
<p>卸载类需要满足3个要求:</p>
<ol>
<li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被GC</li>
</ol>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210801144758528.png" alt="image-20210801144758528"></p>
<h2 id="4-Spring-IOC-amp-AOP"><a href="#4-Spring-IOC-amp-AOP" class="headerlink" title="4. Spring IOC &amp; AOP"></a>4. Spring IOC &amp; AOP</h2><p>Spring Cloud 其实是一套规范，是一套用于构建微服务架构的规范，而不是一个可以拿来即用的框架（所谓规范就是应该有哪些功能组件，然后组件之间怎么配合，共同完成什么事情）。在这个规范之下第三方的 Netflix 公司开发了一些组件、Spring 官方开发了一些框架&#x2F;组件，包括第三方的阿里巴巴开发了一套框架&#x2F;组件集合 Spring Cloud Alibaba，这些才是 Spring Cloud 规范的实现。<br>利用 Spring Boot 的开发便利性简化了微服务架构的开发（自动装配）</p>
<h2 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a>Spring自动装配</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422180734009.png" alt="image-20210422180734009"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422181023674.png" alt="image-20210422181023674"></p>
<h3 id="4-1-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#4-1-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="4.1 谈谈自己对于 Spring IoC 和 AOP 的理解"></a>4.1 谈谈自己对于 Spring IoC 和 AOP 的理解</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=ioc">IoC</a></h4><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521110443084.png" alt="image-20210521110443084"></p>
<h2 id="APPlicationContext和BeanFacotry的区别"><a href="#APPlicationContext和BeanFacotry的区别" class="headerlink" title="APPlicationContext和BeanFacotry的区别"></a>APPlicationContext和BeanFacotry的区别</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422170256672.png" alt="image-20210422170256672"></p>
<h3 id="Spring-IoC有什么好处呢？"><a href="#Spring-IoC有什么好处呢？" class="headerlink" title="Spring IoC有什么好处呢？"></a>Spring IoC有什么好处呢？</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<p>IoC源码阅读</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
</li>
<li><p>&#96;&#96;&#96;java<br>public void refresh() throws BeansException, IllegalStateException {<br>   &#x2F;&#x2F; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛<br>   synchronized (this.startupShutdownMonitor) {</p>
<pre><code>  // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符
  prepareRefresh();

  // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，
  // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，
  // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)
  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

  // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean
  // 这块待会会展开说
  prepareBeanFactory(beanFactory);

  try &#123;
     // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，
     // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】

     // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化
     // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事
     postProcessBeanFactory(beanFactory);
     // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法
     invokeBeanFactoryPostProcessors(beanFactory);          



     // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别
     // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
     // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机
     registerBeanPostProcessors(beanFactory);

     // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了
     initMessageSource();

     // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了
     initApplicationEventMulticaster();

     // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说
     // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）
     onRefresh();

     // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过
     registerListeners();

     // 重点，重点，重点
     // 初始化所有的 singleton beans
     //（lazy-init 的除外）
     finishBeanFactoryInitialization(beanFactory);

     // 最后，广播事件，ApplicationContext 初始化完成，不展开
     finishRefresh();
  &#125;

  catch (BeansException ex) &#123;
     if (logger.isWarnEnabled()) &#123;
        logger.warn(&quot;Exception encountered during context initialization - &quot; +
              &quot;cancelling refresh attempt: &quot; + ex);
     &#125;

     // Destroy already created singletons to avoid dangling resources.
     // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
     destroyBeans();

     // Reset &#39;active&#39; flag.
     cancelRefresh(ex);

     // 把异常往外抛
     throw ex;
  &#125;

  finally &#123;
     // Reset common introspection caches in Spring&#39;s core, since we
     // might not ever need metadata for singleton beans anymore...
     resetCommonCaches();
  &#125;
</code></pre>
<p>   }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- 创建 Bean 容器，加载并注册 Bean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![创建 Bean 容器，加载并注册 Bean](工作面试/创建 Bean 容器，加载并注册 Bean.png)</span><br><span class="line"></span><br><span class="line">### 初始化所有的 singleton beans</span><br><span class="line"></span><br><span class="line">我们的重点当然是 `finishBeanFactoryInitialization(beanFactory);` 这个巨头了，这里会负责初始化所有的 singleton beans。</span><br><span class="line"></span><br><span class="line">注意，后面的描述中，我都会使用**初始化**或**预初始化**来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</span><br><span class="line"></span><br><span class="line">我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 `environment`、`systemProperties` 等。</span><br><span class="line"></span><br><span class="line">剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</span><br><span class="line"></span><br><span class="line">![Bean实例生成](工作面试/Bean实例生成.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### AOP</span><br><span class="line"></span><br><span class="line">AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。</span><br><span class="line"></span><br><span class="line">**Spring AOP就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：</span><br><span class="line"></span><br><span class="line">![SpringAOPProcess](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg)</span><br><span class="line"></span><br><span class="line">当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</span><br><span class="line"></span><br><span class="line">使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</span><br><span class="line"></span><br><span class="line">### 4.2 Spring AOP 和 AspectJ AOP 有什么区别？</span><br><span class="line"></span><br><span class="line">**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</span><br><span class="line"></span><br><span class="line">Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</span><br><span class="line"></span><br><span class="line">如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</span><br><span class="line"></span><br><span class="line">## 5. Spring bean</span><br><span class="line"></span><br><span class="line">### 5.1 Spring 中的 bean 的作用域有哪些?</span><br><span class="line"></span><br><span class="line">- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</span><br><span class="line">- prototype : 每次请求都会创建一个新的 bean 实例。</span><br><span class="line">- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</span><br><span class="line">- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</span><br><span class="line">- global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</span><br><span class="line"></span><br><span class="line">### 5.2 Spring 中的单例 bean 的线程安全问题了解吗？</span><br><span class="line"></span><br><span class="line">的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</span><br><span class="line"></span><br><span class="line">但是，一般情况下，我们常用的 `Controller`、`Service`、`Dao` 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</span><br><span class="line"></span><br><span class="line">常见的有 2 种解决办法：</span><br><span class="line"></span><br><span class="line">1. 在类中定义一个 `ThreadLocal` 成员变量，将需要的可变成员变量保存在 `ThreadLocal` 中（推荐的一种方式）。</span><br><span class="line">2. 改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</span><br><span class="line"></span><br><span class="line">### 5.3 @Component 和 @Bean 的区别是什么？</span><br><span class="line"></span><br><span class="line">1. 作用对象不同: `@Component` 注解作用于类，而`@Bean`注解作用于方法。</span><br><span class="line">2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</span><br><span class="line">3. `@Bean` 注解比 `Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。</span><br><span class="line"></span><br><span class="line">`@Bean`注解使用示例：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="5-4-将一个类声明为Spring的-bean-的注解有哪些"><a href="#5-4-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="5.4 将一个类声明为Spring的 bean 的注解有哪些?"></a>5.4 将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="5-5-Spring-中的-bean-生命周期"><a href="#5-5-Spring-中的-bean-生命周期" class="headerlink" title="5.5 Spring 中的 bean 生命周期?"></a>5.5 Spring 中的 bean 生命周期?</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422170916735.png" alt="image-20210422170916735"></p>
<p>这部分网上有很多文章都讲到了，下面的内容整理自： <del><a target="_blank" rel="noopener" href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a></del> (原作者可能不再维护这个博客，连接无法访问，可通过其 Github 仓库访问 <a target="_blank" rel="noopener" href="https://github.com/giraffe0813/giraffe0813.github.io">https://github.com/giraffe0813/giraffe0813.github.io</a>) ，除了这篇文章，再推荐一篇很不错的文章 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
<h3 id="5-6循环依赖"><a href="#5-6循环依赖" class="headerlink" title="5.6循环依赖"></a>5.6循环依赖</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8bb67ca11831">https://www.jianshu.com/p/8bb67ca11831</a></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521115128603.png" alt="image-20210521115128603"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521120726613.png" alt="image-20210521120726613"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521121152984.png" alt="image-20210521121152984"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521121806753.png" alt="image-20210521121806753"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521122411638.png" alt="image-20210521122411638"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521141713835.png" alt="image-20210521141713835"></p>
<h2 id="6-Spring-MVC"><a href="#6-Spring-MVC" class="headerlink" title="6. Spring MVC"></a>6. Spring MVC</h2><h3 id="6-1-说说自己对于-Spring-MVC-了解"><a href="#6-1-说说自己对于-Spring-MVC-了解" class="headerlink" title="6.1 说说自己对于 Spring MVC 了解?"></a>6.1 说说自己对于 Spring MVC 了解?</h3><p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。</p>
<ul>
<li><strong>Model1 时代</strong> : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 既是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</li>
<li><strong>Model2 时代</strong> ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p>Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><strong>Spring MVC 的简单原理图如下：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg" alt="img"></p>
<h3 id="6-2-SpringMVC-工作原理了解吗"><a href="#6-2-SpringMVC-工作原理了解吗" class="headerlink" title="6.2 SpringMVC 工作原理了解吗?"></a>6.2 SpringMVC 工作原理了解吗?</h3><p><strong>原理如下图所示：</strong> <img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt="SpringMVC运行原理"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
<li><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190039560.png" alt="image-20210422190039560"></li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190523421.png" alt="image-20210422190523421"></p>
<h2 id="7-Spring-框架中用到了哪些设计模式？"><a href="#7-Spring-框架中用到了哪些设计模式？" class="headerlink" title="7. Spring 框架中用到了哪些设计模式？"></a>7. Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422172222211.png" alt="image-20210422172222211"></p>
<h2 id="8-Spring-事务"><a href="#8-Spring-事务" class="headerlink" title="8. Spring 事务"></a>8. Spring 事务</h2><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521143731489.png" alt="image-20210521143731489"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521143152127.png" alt="image-20210521143152127"></p>
<h3 id="8-1-Spring-管理事务的方式有几种？"><a href="#8-1-Spring-管理事务的方式有几种？" class="headerlink" title="8.1 Spring 管理事务的方式有几种？"></a>8.1 Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="8-2-Spring-事务中的隔离级别有哪几种"><a href="#8-2-Spring-事务中的隔离级别有哪几种" class="headerlink" title="8.2 Spring 事务中的隔离级别有哪几种?"></a>8.2 Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="8-3-Spring-事务中哪几种事务传播行为"><a href="#8-3-Spring-事务中哪几种事务传播行为" class="headerlink" title="8.3 Spring 事务中哪几种事务传播行为?"></a>8.3 Spring 事务中哪几种事务传播行为?</h3><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521144952344.png" alt="image-20210521144952344"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521145400914.png" alt="image-20210521145400914"></p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="8-4-Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#8-4-Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="8.4 @Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>8.4 @Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<p>关于 <code>@Transactional </code> 注解推荐阅读的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">透彻的掌握 Spring 中@transactional 的使用</a></li>
</ul>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422175123464.png" alt="image-20210422175123464"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422175400373.png" alt="image-20210422175400373"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422180219119.png" alt="image-20210422180219119"></p>
<h3 id="9JPA"><a href="#9JPA" class="headerlink" title="9JPA"></a>9JPA</h3><h3 id="9-1-如何使用JPA在数据库中非持久化一个字段？"><a href="#9-1-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="9.1 如何使用JPA在数据库中非持久化一个字段？"></a>9.1 如何使用JPA在数据库中非持久化一个字段？</h3><p>假如我们有有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @TransientCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h2 id="SpringBoot入门指南："><a href="#SpringBoot入门指南：" class="headerlink" title="SpringBoot入门指南："></a>SpringBoot入门指南：</h2><p><a target="_blank" rel="noopener" href="https://github.com/CodingDocs/springboot-guide">https://github.com/CodingDocs/springboot-guide</a></p>
<ol>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javaguide/p/springboot-auto-config.html">面试常问：“讲述一下 SpringBoot 自动装配原理？”</a></strong></li>
</ol>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422190844163.png" alt="image-20210422190844163"></p>
<p><strong>重要知识点详解：</strong></p>
<ol>
<li><strong><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/./docs/system-design/framework/spring/SpringBoot+Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93">Spring&#x2F;Spring Boot 常用注解总结！安排！</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93">Spring 事务总结</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns">Spring 中都用到了那些设计模式?</a></li>
</ol>
<p>在我们写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口，这时候就会写很多的@AutoWired注解，代码看起来很乱<br>lombok提供了一个注解：</p>
<p>@RequiredArgsConstructor(onConstructor &#x3D;@_(@Autowired))<br>写在类上可以代替@AutoWired注解，需要注意的是在注入时需要用final定义，或者使用@notnull注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.springsecurityjwtguide.system.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableMap;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.entity.Role;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.entity.User;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.entity.UserRole;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.enums.RoleType;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.exception.RoleNotFoundException;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.exception.UserNameAlreadyExistException;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.exception.UserNameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.repository.RoleRepository;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.repository.UserRoleRepository;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.web.representation.UserRepresentation;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.web.request.UserRegisterRequest;</span><br><span class="line"><span class="keyword">import</span> github.javaguide.springsecurityjwtguide.system.web.request.UserUpdateRequest;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;username:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoleRepository roleRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRoleRepository userRoleRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(UserRegisterRequest userRegisterRequest)</span> &#123;</span><br><span class="line">        ensureUserNameNotExist(userRegisterRequest.getUserName());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRegisterRequest.toUser();</span><br><span class="line">        user.setPassword(bCryptPasswordEncoder.encode(userRegisterRequest.getPassword()));</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        <span class="comment">//给用户绑定两个角色：用户和管理者</span></span><br><span class="line">        <span class="type">Role</span> <span class="variable">studentRole</span> <span class="operator">=</span> roleRepository.findByName(RoleType.USER.getName()).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RoleNotFoundException</span>(ImmutableMap.of(<span class="string">&quot;roleName&quot;</span>, RoleType.USER.getName())));</span><br><span class="line">        <span class="type">Role</span> <span class="variable">managerRole</span> <span class="operator">=</span> roleRepository.findByName(RoleType.MANAGER.getName()).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RoleNotFoundException</span>(ImmutableMap.of(<span class="string">&quot;roleName&quot;</span>, RoleType.MANAGER.getName())));</span><br><span class="line">        userRoleRepository.save(<span class="keyword">new</span> <span class="title class_">UserRole</span>(user, studentRole));</span><br><span class="line">        userRoleRepository.save(<span class="keyword">new</span> <span class="title class_">UserRole</span>(user, managerRole));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUserName(userName).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UserNameNotFoundException</span>(ImmutableMap.of(USERNAME, userName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(UserUpdateRequest userUpdateRequest)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> find(userUpdateRequest.getUserName());</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(userUpdateRequest.getFullName())) &#123;</span><br><span class="line">            user.setFullName(userUpdateRequest.getFullName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(userUpdateRequest.getPassword())) &#123;</span><br><span class="line">            user.setPassword(bCryptPasswordEncoder.encode(userUpdateRequest.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(userUpdateRequest.getEnabled())) &#123;</span><br><span class="line">            user.setEnabled(userUpdateRequest.getEnabled());</span><br><span class="line">        &#125;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!userRepository.existsByUserName(userName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNameNotFoundException</span>(ImmutableMap.of(USERNAME, userName));</span><br><span class="line">        &#125;</span><br><span class="line">        userRepository.deleteByUserName(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Page&lt;UserRepresentation&gt; <span class="title function_">getAll</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll(PageRequest.of(pageNum, pageSize)).map(User::toUserRepresentation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String currentPassword, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bCryptPasswordEncoder.matches(currentPassword, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureUserNameNotExist</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> userRepository.findByUserName(userName).isPresent();</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNameAlreadyExistException</span>(ImmutableMap.of(USERNAME, userName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192719091.png" alt="image-20210422192719091"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192819513.png" alt="image-20210422192819513"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;</span></span><br><span class="line"><span class="comment"> * any candidates are then enhanced by a &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer&#125;.</span></span><br><span class="line"><span class="comment"> * Candidate status is determined by BeanDefinition attribute metadata.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="comment">//省略部分代码</span></span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ConfigurationClassEnhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassEnhancer</span>();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">            Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">                <span class="comment">//省略部分代码</span></span><br><span class="line">                beanDef.setBeanClass(enhancedClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">              <span class="string">&quot;Cannot load configuration class: &quot;</span> + beanDef.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422192956109.png" alt="image-20210422192956109"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193112324.png" alt="image-20210422193112324"></p>
<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193252893.png" alt="image-20210422193252893"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先通过反射从增强的 Configuration 注解类中获取 beanFactory</span></span><br><span class="line"><span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory(enhancedConfigInstance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过方法获取 beanName，默认为方法名，可以通过 @Bean 注解指定</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定这个 bean 是否指定了代理的范围</span></span><br><span class="line"><span class="comment">//默认下面 if 条件 false 不会执行</span></span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);</span><br><span class="line"><span class="keyword">if</span> (scope != <span class="literal">null</span> &amp;&amp; scope.proxyMode() != ScopedProxyMode.NO) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">scopedBeanName</span> <span class="operator">=</span> ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">        beanName = scopedBeanName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跳过一段 Factorybean 相关代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前执行的方法是否为正在执行的 @Bean 方法</span></span><br><span class="line"><span class="comment">//因为存在在 userInfo() 方法中调用 country() 方法</span></span><br><span class="line"><span class="comment">//如果 country() 也有 @Bean 注解，那么这个返回值就是 false.</span></span><br><span class="line"><span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">    <span class="comment">// 判断返回值类型，如果是 BeanFactoryPostProcessor 就写警告日志</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp;</span><br><span class="line">            BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">        logger.warn(String.format(</span><br><span class="line">            <span class="string">&quot;@Bean method %s.%s is non-static and returns an object &quot;</span> +</span><br><span class="line">            <span class="string">&quot;assignable to Spring&#x27;s BeanFactoryPostProcessor interface. This will &quot;</span> +</span><br><span class="line">            <span class="string">&quot;result in a failure to process annotations such as @Autowired, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;@Resource and @PostConstruct within the method&#x27;s declaring &quot;</span> +</span><br><span class="line">            <span class="string">&quot;@Configuration class. Add the &#x27;static&#x27; modifier to this method to avoid &quot;</span> +</span><br><span class="line">            <span class="string">&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;</span>,</span><br><span class="line">            beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接调用原方法创建 bean</span></span><br><span class="line">    <span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不满足上面 if，也就是在 userInfo() 中调用的 country() 方法</span></span><br><span class="line"><span class="keyword">return</span> obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210422193415068.png" alt="image-20210422193415068"></p>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><h3 id="1-为什么使用Redis存储token"><a href="#1-为什么使用Redis存储token" class="headerlink" title="1.为什么使用Redis存储token"></a>1.为什么使用Redis存储token</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，引入一个中间件管理token就避免了单点问题，对于分布式系统来说，不管你是哪一台服务处理的用户请求，我都是从redis获取的token。其次，redis的响应速度非常快，如果不出现网络问题，基本上是毫秒级别相应。第三，对于token来说，是有时效性的，redis天然支持设置过期时间以及通过一些二方包提供的API到达自动续时效果。个人感觉，主要就三方面原因吧。</span><br></pre></td></tr></table></figure>

<h1 id="SSO单点登录"><a href="#SSO单点登录" class="headerlink" title="SSO单点登录"></a>SSO单点登录</h1><p><img src="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/image-20210521175630355.png" alt="image-20210521175630355"></p>
<p>注销：一开始登录时，用一个List存入目前每个客户端登录过来的sessionid与登录的地址url.存入数据库。  登出时，在认证中心这一服务端建立监听器，删除掉认证中心的Session后，监听器取出数据库中，目前已经登录的对应的url,拼接url,发出HTTP请求到对应客户端服务接口，让客户端删除Session，完成单点登出。</p>
<h1 id="消息队列部分：幂等性和重复消息问题"><a href="#消息队列部分：幂等性和重复消息问题" class="headerlink" title="消息队列部分：幂等性和重复消息问题"></a>消息队列部分：幂等性和重复消息问题</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzhou86/article/details/79156458">https://blog.csdn.net/yzhou86/article/details/79156458</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/blackdd/p/12377563.html">https://www.cnblogs.com/blackdd/p/12377563.html</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>
<p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>
<blockquote>
<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p>
<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>
<p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p>
<p>这个时候的客户端调用是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure>

<p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>
<p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
<p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p>
<p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">      <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">      <span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p>
<p>饿汉模式最简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(String mode)</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>
</blockquote>
<p>饱汉模式最容易出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。</p>
<p>volatile 在这里是需要的，希望能引起读者的关注。</p>
<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>

<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>
<p>来一个中规中矩的建造者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">              <span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p>
<p>看看客户端的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pAss12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>
<blockquote>
<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p>
</blockquote>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p>
<p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p>
<p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
</blockquote>
<p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p>
<p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p>
<p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p>
<h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p>
<p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>
<p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用很简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">      <span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">      <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">      <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>
<p>我们用一个图来简单说明下：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p>
<p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>
<h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p>
<p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol>
<li><p>类适配和对象适配的异同</p>
<blockquote>
<p>一个采用继承，一个采用组合；</p>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
</li>
<li><p>适配器模式和代理模式的异同</p>
<p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p>
</li>
</ol>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p>
<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p>
<blockquote>
<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p>
</blockquote>
<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator*</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p>
<blockquote>
<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>
</blockquote>
<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>
<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>
<p>不说废话了，上代码。</p>
<p>首先，定义饮料抽象基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">      <span class="comment">// 返回描述</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">// 返回价格</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure>

<p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Condiment</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lemon</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lemon</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加柠檬&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mango</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mango</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure>

<p>看客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreenTea</span>();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">&quot; 价格：￥&quot;</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mongo</span>(<span class="keyword">new</span> <span class="title class_">Pearl</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">BlackTea</span>()))));</span><br></pre></td></tr></table></figure>

<p>是不是很变态？</p>
<p>看看下图可能会清晰一些：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p>
<p>到这里，大家应该已经清楚装饰模式了吧。</p>
<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p>
<p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
<p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>
<p>我们应该像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/" data-id="cl2yds3zh00012gg05f0g4aic" data-title="面试基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/">面试基础</a>
          </li>
        
          <li>
            <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/05/05/%E9%9D%A2%E7%BB%8F/">面经</a>
          </li>
        
          <li>
            <a href="/2022/05/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>