<h2 id="1、你管这破玩意叫-IO-多路复用？"><a href="#1、你管这破玩意叫-IO-多路复用？" class="headerlink" title="1、你管这破玩意叫 IO 多路复用？"></a>1、你管这破玩意叫 IO 多路复用？</h2><p><a href="https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA">https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA</a></p>
<h2 id="2、请谈一谈，系统如何提高并发性？"><a href="#2、请谈一谈，系统如何提高并发性？" class="headerlink" title="2、请谈一谈，系统如何提高并发性？"></a>2、请谈一谈，系统如何提高并发性？</h2><p>考察：操作系统综合性</p>
<h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、提高CPU并发计算能力</p>
<p>（1）多进程&amp;多线程</p>
<p>（2）减少进程切换，使用线程，考虑进程绑定CPU</p>
<p>（3）减少使用不必要的锁，考虑无锁编程</p>
<p>（4）考虑进程优先级</p>
<p>（5）关注系统负载</p>
<p>2、改进I&#x2F;O模型</p>
<p>(1)DMA技术</p>
<p>(2)异步I&#x2F;O</p>
<p>(3)改进多路I&#x2F;O就绪通知策略，epoll</p>
<p>(4)Sendfile</p>
<p>(5)内存映射</p>
<p>(6)直接I&#x2F;O</p>
<h2 id="3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？"><a href="#3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？" class="headerlink" title="3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？"></a>3、请谈一谈，什么情况下会发生死锁？解决死锁的策略有哪些？</h2><p>考察点：死锁</p>
<h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。</p>
<p>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。</p>
<p>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。</p>
<p>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。</p>
<h2 id="4、介绍一下，什么是hashmap"><a href="#4、介绍一下，什么是hashmap" class="headerlink" title="4、介绍一下，什么是hashmap?"></a>4、介绍一下，什么是hashmap?</h2><p>考察点：哈希表</p>
<h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<p>hashmap共有4个构造函数：</p>
<p>&#x2F;&#x2F; 默认构造函数。HashMap()</p>
<p>&#x2F;&#x2F; 指定“容量大小”的构造函数</p>
<p>HashMap(int capacity)</p>
<p>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</p>
<p>HashMap(int capacity, float loadFactor)</p>
<p>&#x2F;&#x2F; 包含“子Map”的构造函数</p>
<p>HashMap(Map&lt;? extends K, ? extends V&gt; map)</p>
<h2 id="5、现在有十万个单词，请你找出重复次数最多的十个。"><a href="#5、现在有十万个单词，请你找出重复次数最多的十个。" class="headerlink" title="5、现在有十万个单词，请你找出重复次数最多的十个。"></a>5、现在有十万个单词，请你找出重复次数最多的十个。</h2><p>文件太大的话，先对存单词的文件进行分流，这里是十个，那就分成十份，分流采用hash，这样相同的单词必然是分到同一台机器上，然后分别统计每一台机器上每个单词出现的次数并分别排序，这样就有了每一台机器上单词出现次数的有序列表。剩下的就是算法了，大家有没有做过一个算法题，N个排好序的数组，求这N个数组中最大的N个数？思路是先建一个大小为N的大顶堆，堆中的元素是这N个数组中的最大值，也就是每个数组的最右边（或者最左边，看排序方式）的值，那么堆顶的元素必然是所有数组中最大的那个，取出来存着，然后这个最大值来自哪个数组，将这个数组的次大值拿来放入堆中，重新调整，然后继续将堆顶元素取出，看堆顶元素属于哪个数组，取其次大值，放入堆中继续调整……..如此循环，取出N个数后，停止。最后就得到了最大的N个数，套到这个题目来就是出现次数最多的单词的次数，对应的单词是什么设计数组结构的时候存一下就行了。</p>
<h2 id="6、现在，有一个组合索引（A-B-C），可以有哪几种查询方式？"><a href="#6、现在，有一个组合索引（A-B-C），可以有哪几种查询方式？" class="headerlink" title="6、现在，有一个组合索引（A,B,C），可以有哪几种查询方式？"></a>6、现在，有一个组合索引（A,B,C），可以有哪几种查询方式？</h2><p>优: select * from test order by a</p>
<p>差: select * from test order by b</p>
<p>差: select * from test order by c</p>
<p>怎么看出优差之分？</p>
<p>​	</p>
<p>MySql索引底层采用B+树的数据结构，仅在叶子节点存储数据，并且从左到右串联起来便于范围查询。这样的结构导致复合索引的查询符合“最左原则”，也就是当建立（a,b,c）复合索引时，查询条件中必须有a才能走索引，a,ab,ac,abc均;但是b,bc,c都不能走索引。</p>
<h2 id="7、请你讲解一下数据连接池的工作机制"><a href="#7、请你讲解一下数据连接池的工作机制" class="headerlink" title="7、请你讲解一下数据连接池的工作机制?"></a>7、请你讲解一下数据连接池的工作机制?</h2><p>考察点：连接池</p>
<h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<h2 id="8、请介绍一些你了解的数据库优化方法"><a href="#8、请介绍一些你了解的数据库优化方法" class="headerlink" title="8、请介绍一些你了解的数据库优化方法"></a>8、请介绍一些你了解的数据库优化方法</h2><p>考察点：数据库</p>
<h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>（1）选取最适用的字段属性</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>（2）使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询</p>
<p>（3）使用联合(UNION)来代替手动创建的临时表</p>
<p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p>
<p>（4）事务</p>
<p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p>
<h2 id="9、-讲一讲，数据库ACID的特性。"><a href="#9、-讲一讲，数据库ACID的特性。" class="headerlink" title="9、 讲一讲，数据库ACID的特性。"></a>9、 讲一讲，数据库ACID的特性。</h2><p>考察点：数据库</p>
<h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性指事务前后数据的完整性必须保持一致。</p>
<p>隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离。</p>
<p>持久性是指一个事务一旦提交，它对数据库中数据的改变就是永久性的，即便数据库发生故障也不应该对其有任何影响。</p>
<h2 id="10、请你介绍一下，数据库乐观锁和悲观锁"><a href="#10、请你介绍一下，数据库乐观锁和悲观锁" class="headerlink" title="10、请你介绍一下，数据库乐观锁和悲观锁"></a>10、请你介绍一下，数据库乐观锁和悲观锁</h2><p>考察点：数据库</p>
<h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>悲观锁</p>
<p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<p>乐观锁</p>
<p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>乐观锁一般来说有以下2种方式：</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<p>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>
<h2 id="11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效"><a href="#11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效" class="headerlink" title="11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效"></a>11、简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效</h2><p>考察点：数据库索引</p>
<h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>B+树实现的。</p>
<p>没有遵循最左匹配原则。</p>
<p>一些关键字会导致索引失效，例如 or， ！&#x3D; ， not in，is null ,is not unll</p>
<p>like查询是以%开头</p>
<p>隐式转换会导致索引失效。</p>
<p>对索引应用内部函数，索引字段进行了运算。</p>
<h2 id="12、-请你说一说，mysql数据库的两种引擎-区别"><a href="#12、-请你说一说，mysql数据库的两种引擎-区别" class="headerlink" title="12、 请你说一说，mysql数据库的两种引擎 区别"></a>12、 请你说一说，mysql数据库的两种引擎 区别</h2><p>考察点：数据库存储引擎</p>
<h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>InnoDB是聚集索引，支持事务，支持行级锁；MyISAM是非聚集索引，不支持事务，只支持表级锁。</p>
<h2 id="13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。"><a href="#13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。" class="headerlink" title="13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。"></a>13、请介绍一下，数据库索引，以及，什么时候用Innodb什么时候用MyISAM。</h2><p>考察点：数据库</p>
<h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>存储引擎</p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。InnoDB主要面向在线事务处理（OLTP）的应用。MyISAM主要面向一些OLAP的应用。</p>
<h2 id="14、请你讲讲-Statement-和-PreparedStatement-的区别？哪个性能更好？"><a href="#14、请你讲讲-Statement-和-PreparedStatement-的区别？哪个性能更好？" class="headerlink" title="14、请你讲讲 Statement 和 PreparedStatement 的区别？哪个性能更好？"></a>14、请你讲讲 Statement 和 PreparedStatement 的区别？哪个性能更好？</h2><p>考察点：Statement</p>
<h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<p>为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
<h2 id="15、-请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"><a href="#15、-请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？" class="headerlink" title="15、 请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？"></a>15、 请回答一下servlet的生命周期是什么。servlet是否为单例以及原因是什么？</h2><p>考察点：servlet</p>
<h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<p>Servlet 通过调用 init () 方法进行初始化。</p>
<p>Servlet 调用 service() 方法来处理客户端的请求。</p>
<p>Servlet 通过调用 destroy() 方法终止（结束）。</p>
<p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>
<p>Servlet单实例，减少了产生servlet的开销；</p>
<h2 id="16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>16、请问什么是IoC和DI？并且简要说明一下DI是如何实现的？</h2><p>考察点：控制反转</p>
<h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h2 id="17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"><a href="#17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？" class="headerlink" title="17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"></a>17、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？</h2><p>考察点：spring</p>
<h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>①IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</p>
<p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>举个简单的例子，我们找女朋友常见的情况是，我们到处去看哪里有长得漂亮身材又好的女孩子，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
<p>②实现IOC的步骤</p>
<p>定义用来描述bean的配置的Java类</p>
<p>解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术</p>
<p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可</p>
<h1 id="18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired-和resource区别是什么？"><a href="#18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired-和resource区别是什么？" class="headerlink" title="18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired 和resource区别是什么？"></a>18、请问在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired 和resource区别是什么？</h1><p>考察点：Spring</p>
<h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、共同点</p>
<p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<p>2、不同点</p>
<p>（1）@Autowired</p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p>
<p>（2）@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h1 id="19、请问AOP的原理是什么？"><a href="#19、请问AOP的原理是什么？" class="headerlink" title="19、请问AOP的原理是什么？"></a>19、请问AOP的原理是什么？</h1><p>考察点：动态代理</p>
<h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>AOP（Aspect Orient Programming），指面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<h1 id="20、请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？"><a href="#20、请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？" class="headerlink" title="20、请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？"></a>20、请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</h1><p>考察点：锁机制</p>
<h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>主要相同点：Lock能完成synchronized所实现的所有功能<br>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<h1 id="21-请说明一下锁和同步的区别。"><a href="#21-请说明一下锁和同步的区别。" class="headerlink" title="21 请说明一下锁和同步的区别。"></a>21 请说明一下锁和同步的区别。</h1><p>考察点：锁</p>
<h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>用法上的不同：<br>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br>synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br>性能上的不同：<br>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。<br>锁机制不同：<br>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。</p>
<h1 id="22、请说明一下synchronized的可重入怎么实现。"><a href="#22、请说明一下synchronized的可重入怎么实现。" class="headerlink" title="22、请说明一下synchronized的可重入怎么实现。"></a>22、请说明一下synchronized的可重入怎么实现。</h1><p>考察点：锁</p>
<h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法&#x2F;块时，计数器会递减，如果计数器为0则释放该锁。</p>
<h1 id="23、-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"><a href="#23、-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。" class="headerlink" title="23、 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"></a>23、 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。</h1><p>考察点：锁</p>
<h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<h2 id="24、GC中如何判断对象是否需要被回收？"><a href="#24、GC中如何判断对象是否需要被回收？" class="headerlink" title="24、GC中如何判断对象是否需要被回收？"></a>24、GC中如何判断对象是否需要被回收？</h2><p>考察点：JAVA虚拟机</p>
<h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>即使在可达性分析算法中不可达的对象,也并非是“非回收不可”的,这时候它们暂时处于“等待”阶段,要真正宣告一个对象回收,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</p>
<p>如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。</p>
<p>finalize()方法是对象逃脱回收的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中跳出回收——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。</p>
<h1 id="25-、假设一个场景，要求stop-the-world时间非常短，你会怎么设计垃圾回收机制？"><a href="#25-、假设一个场景，要求stop-the-world时间非常短，你会怎么设计垃圾回收机制？" class="headerlink" title="25 、假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？"></a>25 、假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？</h1><p>绝大多数新创建的对象分配在Eden区。</p>
<p>在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。</p>
<p>在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。</p>
<p>一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。</p>
<p>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p>
<h1 id="26、-请说明一下eden区和survial区的含义以及工作原理？"><a href="#26、-请说明一下eden区和survial区的含义以及工作原理？" class="headerlink" title="26、 请说明一下eden区和survial区的含义以及工作原理？"></a>26、 请说明一下eden区和survial区的含义以及工作原理？</h1><p>考察点：JVM</p>
<h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。</p>
<p>我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；<br>2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p>
<h1 id="27、-请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？"><a href="#27、-请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？" class="headerlink" title="27、 请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？"></a>27、 请简单说明一下JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算1法？使用CMS怎样解决内存碎片的问题呢？</h1><p>考察点：JVM</p>
<h3 id="参考回答：-22"><a href="#参考回答：-22" class="headerlink" title="参考回答："></a>参考回答：</h3><p>垃圾回收算法</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p>
<p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<h3 id="增量算法"><a href="#增量算法" class="headerlink" title="增量算法"></a>增量算法</h3><p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。</p>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p>
<p>通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。</p>
<p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<p>-UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p>-UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：</p>
<p>初始标记(initial mark)</p>
<p>并发标记(concurrent mark)</p>
<p>重新标记(remark)</p>
<p>并发清除(concurrent sweep)</p>
<p>注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<p>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</p>
<p>分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。</p>
<p>空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。</p>
<p>可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<h3 id="CMS：采用标记清除算法"><a href="#CMS：采用标记清除算法" class="headerlink" title="CMS：采用标记清除算法"></a>CMS：采用标记清除算法</h3><p>解决这个问题的办法就是可以让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，CMS提供了以下参数来控制：</p>
<p>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction&#x3D;5</p>
<p>也就是CMS在进行5次Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。</p>
<h1 id="28、-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下"><a href="#28、-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下" class="headerlink" title="28、 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下"></a>28、 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下</h1><p>考察点：GC</p>
<h3 id="参考回答：-23"><a href="#参考回答：-23" class="headerlink" title="参考回答："></a>参考回答：</h3><p>可能是堆内存太小。</p>
<h1 id="29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"><a href="#29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？" class="headerlink" title="29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"></a>29、请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？</h1><h2 id="考察点：内存泄漏"><a href="#考察点：内存泄漏" class="headerlink" title="考察点：内存泄漏"></a>考察点：内存泄漏</h2><h3 id="参考回答：-24"><a href="#参考回答：-24" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</p>
<h1 id="30、进程间常用的通信方式有哪些"><a href="#30、进程间常用的通信方式有哪些" class="headerlink" title="30、进程间常用的通信方式有哪些"></a>30、进程间常用的通信方式有哪些</h1><ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服 这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁 盘⽂件的⽅式存在，可以实现本机任意两个进程通信。 </li>
<li><strong>信号(Signal)</strong> ：信号是⼀种⽐复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣； </li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息 队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在 于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字节流以及缓冲区⼤⼩受限等缺。</li>
<li><strong>信号量(Semaphores)</strong> ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。 </li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对 ⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。 </li>
<li><strong>套接字(Sockets)</strong> : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP&#x2F;IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</li>
</ol>
<h1 id="31、-操作系统中CPU调度算法有哪些？介绍下"><a href="#31、-操作系统中CPU调度算法有哪些？介绍下" class="headerlink" title="31、.操作系统中CPU调度算法有哪些？介绍下"></a>31、.操作系统中CPU调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>有哪些？介绍下</h1><h1 id="32、GET-和-POST-方法都是安全和幂等的吗？"><a href="#32、GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="32、GET 和 POST 方法都是安全和幂等的吗？"></a>32、GET 和 POST 方法都是安全和幂等的吗？</h1><p> 先说明下安全和幂等的概念： 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。</p>
<h1 id="33、HTTP-x2F-1-1-的性能如何？"><a href="#33、HTTP-x2F-1-1-的性能如何？" class="headerlink" title="33、HTTP&#x2F;1.1 的性能如何？"></a>33、HTTP&#x2F;1.1 的性能如何？</h1><h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1.长连接"></a>1.长连接</h2><p> 早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握 手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在 于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
