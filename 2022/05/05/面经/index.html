<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面经 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.操作系统接收到网卡数据后怎么处理https:&#x2F;&#x2F;www.sohu.com&#x2F;a&#x2F;437215957_100038287 Linux 接收网络包的流程 网卡是计算机里的一个硬件，专⻔负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包放入到 Ring Buffer，这个是一个环形缓冲区。 那接收到网络包后，应该怎么告诉操作系统这个网络包已经到达了呢? 最简单的一种方式就是">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.操作系统接收到网卡数据后怎么处理https:&#x2F;&#x2F;www.sohu.com&#x2F;a&#x2F;437215957_100038287 Linux 接收网络包的流程 网卡是计算机里的一个硬件，专⻔负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包放入到 Ring Buffer，这个是一个环形缓冲区。 那接收到网络包后，应该怎么告诉操作系统这个网络包已经到达了呢? 最简单的一种方式就是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082208144.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082605047.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082742670.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205003139748.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205005731502.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205005908149.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205010801163.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205013126457.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/2009040916453171.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/774371-20190716140620340-1681775116.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdzZW5saW4zNDE=,size_16,color_FFFFFF,t_7110">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdzZW5saW4zNDE=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/11">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/698434-20191111144738188-995471012.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204162938577.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/format,png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204183337019.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204190742189.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204192201427.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204215841989.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204221001146.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204223155099.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204224707733.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204231255806.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/webp">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211219002533934.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004020420.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004457328.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004956435.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215005803320.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_36,color_FFFFFF,t_70">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211222220843760.png">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/70">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l4ejgxMDI=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003305.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003309.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003313.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003316.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003319.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003322.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003325.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003328.jpg">
<meta property="og:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003331.jpg">
<meta property="article:published_time" content="2022-05-04T17:27:29.000Z">
<meta property="article:modified_time" content="2022-05-04T18:29:20.699Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082208144.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面经" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/05/%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time class="dt-published" datetime="2022-05-04T17:27:29.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面经
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-操作系统接收到网卡数据后怎么处理"><a href="#1-操作系统接收到网卡数据后怎么处理" class="headerlink" title="1.操作系统接收到网卡数据后怎么处理"></a>1.操作系统接收到网卡数据后怎么处理</h1><p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/437215957_100038287">https://www.sohu.com/a/437215957_100038287</a></p>
<h2 id="Linux-接收网络包的流程"><a href="#Linux-接收网络包的流程" class="headerlink" title="Linux 接收网络包的流程"></a>Linux 接收网络包的流程</h2><p> 网卡是计算机里的一个硬件，专⻔负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网<br>络包放入到 Ring Buffer，这个是一个环形缓冲区。 那接收到网络包后，应该怎么告诉操作系统这个网络包已经到达了呢? 最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。 </p>
<p>但是，这存在一个问题，在高性能网络场景下，网络包的数会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没玩没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体 效率。 </p>
<p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的 方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序， 然后 poll 的方法来轮询数据。<br>比如，当有网络包到达时，网卡发起硬件中断，于是会执行网卡硬件中断处理函数，中断处理函数处理完需要「暂 时屏蔽中断」，然后唤醒「软中断」来轮询处理数据，直到没有新数据时才恢复中断，这样一次中断处理多个网络 包，于是就可以降低网卡中断带来的性能开销。 </p>
<p>那软中断是怎么处理网络包的呢?它会从 Ring Buffer 中拷⻉数据到内核 struct sk_buff 缓冲区中，从而可以作为一 个网络包交给网络协议栈进行逐层处理。 </p>
<p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层 协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。 </p>
<p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要 发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p>
<p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据拷⻉到 Socket 的接收缓冲区。 </p>
<p>最后，应用层程序调用 Socket 接口，从内核的 Socket 接收缓冲区读取新到来的数据到应用层。<br>至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过 来，它是网络包发送的流程。 </p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082208144.png" alt="image-20211015082208144"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082605047.png" alt="image-20211015082605047"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211015082742670.png" alt="image-20211015082742670"></p>
<h1 id="2-DMA方式"><a href="#2-DMA方式" class="headerlink" title="2.DMA方式"></a>2.DMA方式</h1><p>外设向cpu发出信号，接管总线权，CPU对某个设备接口响应DMA请求时，会让出总线控制权。于是在DMA控制器的管理下，外设和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>直接进行数据交换，而不需CPU干预。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81">数据传送</a>完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权。</p>
<h1 id="3-Java内部类使用外部类的成员方法以及成员变量"><a href="#3-Java内部类使用外部类的成员方法以及成员变量" class="headerlink" title="3.Java内部类使用外部类的成员方法以及成员变量"></a>3.Java内部类使用外部类的成员方法以及成员变量</h1><p>在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。<br>this$0就是内部类持有的外部类引用，通过构造方法传递引用并赋值。  所以内部类可以调用外部类的private属性方法等。但是外部类不可以随意调用内部类的方法属性。</p>
<h1 id="4-泛型的好处以及擦除泛型的作用"><a href="#4-泛型的好处以及擦除泛型的作用" class="headerlink" title="4.泛型的好处以及擦除泛型的作用"></a>4.泛型的好处以及擦除泛型的作用</h1><p>1.类型安全 泛型的主要目标是实现java的类型安全。 泛型可以使编译器知道一个对象的限定类型是什么，这样编译器就可以在一个高的程度上验证这个类型</p>
<p>2.消除了强制类型转换 使得代码可读性好，减少了很多出错的机会   例如：（如果最初没泛型时，引入后就不必再强转）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">cats</span> <span class="operator">=</span> loadCats();  <span class="comment">// 5之前没有范型哦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj : cats) &#123;</span><br><span class="line">  <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) obj;  <span class="comment">// 所以这里总是需要强转</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>伪泛型：Java中的泛型是伪泛型。泛型只在源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称裸类型）了，并且在相应的地方插入了强制转型代码。因此，在Java程序的运行期中，ArrayList&lt; Integer &gt;和ArrayList&lt; String &gt;就是同一个类。这种泛型实现方法称为类型擦除 ，基于这种方法实现的泛型称为伪泛型。</p>
<p>泛型的擦除本质：是用具体的类型来替换泛型的过程（擦除是将泛型类型以其父类代替，如String 变成了Object等。）</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2bfbe041e6b7">https://www.jianshu.com/p/2bfbe041e6b7</a></p>
<h1 id="5-强制类型转换是子类向父类准备的措施？"><a href="#5-强制类型转换是子类向父类准备的措施？" class="headerlink" title="5.强制类型转换是子类向父类准备的措施？"></a>5.强制类型转换是子类向父类准备的措施？</h1><h1 id="6-short-a-x3D-1-a-x3D-a-1-编译报错"><a href="#6-short-a-x3D-1-a-x3D-a-1-编译报错" class="headerlink" title="6.short a&#x3D;1; a&#x3D;a+1; 编译报错"></a>6.short a&#x3D;1; a&#x3D;a+1; 编译报错</h1><p>因为a+1会转型为Int。 赋给a会int转short  这是隐式转换不允许的.  只能显示强转。</p>
<h1 id="7-xml与json的区别"><a href="#7-xml与json的区别" class="headerlink" title="7.xml与json的区别"></a>7.xml与json的区别</h1><p>二者区别：</p>
<p>它们都是一种数据交换格式。</p>
<p>1，xml是重量级的，json是轻量级的。</p>
<p>2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。</p>
<p>3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。</p>
<p>4，json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析</p>
<h1 id="8-死锁的解决和预防"><a href="#8-死锁的解决和预防" class="headerlink" title="8 死锁的解决和预防"></a>8 死锁的解决和预防</h1><p>首先死锁有4个条件。 第一个：互斥条件：某一个资源被一个线程获取后，其他资源不能够再获取。  </p>
<p>第二个：等待与保持条件、 是指，获取到资源的线程想获取另一个新的资源，但是这个资源被其他线程获取了，此时他将保持持有自己现有的资源。阻塞等待下去。</p>
<p>第三个：不抢占：是指线程不会强行剥夺抢占其他线程已经持有的资源。</p>
<p>第四个条件：循环等待条件。 资源的获取已经成了一个环形。</p>
<p>预防避免：就是破环期中任意一个条件就行。</p>
<p>(1)破坏“互斥使用&#x2F;资源独占”条件<br>资源本身的特性是独占的，是排他性使用的，所以要使用一种资源转换技术，把独占资源变为共享资源。例如针对于打印机，SPOOLing技术的引入解决不允许任何进程直接占有打印机的问题。设计一个“守护进程&#x2F;线程”负责管理打印机，进程需要打印时，将请求发给该daemon，由它完成打印任务。</p>
<p>(2)破坏“占有且等待”条件<br>指一个进程占有了一部分资源，在申请其他资源的时候由于得不到满足而进入等待状态。有下面两种方案实现：</p>
<ul>
<li>实现方案1：要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。这种实现会使得资源的利用率很低，当一个进程所需要的资源不能同时满足的情况下可能一直处于等待状态，会产生饥饿现象。</li>
<li>实现方案2：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请。</li>
</ul>
<p>(3)破坏“不可抢占”条件<br>实现方案是当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源(两个进程优先级不同)。这种方法具有局限性，适用于状态易于保存和恢复的资源，如CPU、内存资源。</p>
<p>(4)破坏“循环等待”条件<br>主要思想是通过定义资源类型的线性顺序实现，实现方案是资源有序分配法，把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。实现资源的有序分配时需要考虑如何对资源进行编号，通常可以利用资源使用的频繁性进行排序。</p>
<p>处理死锁的方法：1、直接无视掉，因为处理代价太大、  2.将某一进程停止，重新运行。释放这个进程已经持有的资源。 3.撤销死锁的所有进程(4)按照某种原则逐一撤消死锁进程，直到没有死锁；(5)按照某种原则逐一抢占资源（资源被抢占的进程必须回退到之前的对应状态），直到没有死锁。</p>
<h1 id="9-堆排序（此处为原地堆排序算法）"><a href="#9-堆排序（此处为原地堆排序算法）" class="headerlink" title="9.堆排序（此处为原地堆排序算法）"></a>9.堆排序（此处为原地堆排序算法）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heapsort</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heapsort</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span>&#123;</span><br><span class="line">        lenth = a.length;</span><br><span class="line">        <span class="comment">//调整成大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lenth/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            adjustHeap(array,i,lenth)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行堆排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;lenth;i++)&#123;</span><br><span class="line">            swap(a,<span class="number">0</span>,lenth-i)</span><br><span class="line">            adjustHeap(array,<span class="number">0</span>,lenth-i)   <span class="comment">//也可以倒着从lenth-1到1  注意每次调整第一个为0，只需要调整第一个元素。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整堆结构（这里相当于下沉操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> i,<span class="type">int</span> lenth)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>,k&lt;lenth;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k+<span class="number">1</span>&lt;lenth&amp;&amp; arr[k]&lt;Arr[k+<span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k]&gt;temp)&#123;</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要删除元素时，头元素和尾元素更换，删除尾，然后调用调整函数，adjust(array,0,lenth-1),这里堆排序的过程就是删除元素的过程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素时，就需要上浮，上浮就是父元素和自己进行比较，自己比父元素大，就交换，直到父元素比自己大,或者到达根节点。</span></span><br></pre></td></tr></table></figure>



<h1 id="10-Redis分布式锁怎么续期的"><a href="#10-Redis分布式锁怎么续期的" class="headerlink" title="10.Redis分布式锁怎么续期的"></a>10.Redis分布式锁怎么续期的</h1><p>获取锁成功就会开启一个定时任务,也就是<code>watchdog</code>,定时任务会定期检查去续期<code>renewExpirationAsync(threadId).</code></p>
<p>通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 &#x3D; 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p>
<p>redis分布式锁的可重入在于，有一个hash记住了加锁客户端（线程）的唯一id,如果有这个客户端加了锁，就继续加锁，value为加的锁的数量。</p>
<h1 id="11-为什么要有锁重入"><a href="#11-为什么要有锁重入" class="headerlink" title="11.为什么要有锁重入"></a>11.为什么要有锁重入</h1><p>看下面这个场景就知道了<br>LoggingWidget 继承了 Widget,并且重写了父类的方法 doSomething(),在线程访问子类的 doSomething() 方法时需要持有锁，然后子类的方法又调用了父类的方法且父类的方法上也标记了 synchronized,如果不能锁重入的话，此时会造成死锁 (deadlock),锁重入就是为了支持这类场景的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingWidget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(toString() + <span class="string">&quot;: calling doSomething&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-抛硬币问题"><a href="#12-抛硬币问题" class="headerlink" title="12.抛硬币问题"></a>12.抛硬币问题</h1><p>两人抛硬币，谁先扔出来正面谁赢，假如是你先扔硬币，那么赢的概率是多少？</p>
<p>根据概率算，等比数列，第一个扔的是第二个的两倍，所以2&#x2F;3</p>
<h1 id="13-布隆过滤器如何支持删除元素"><a href="#13-布隆过滤器如何支持删除元素" class="headerlink" title="13 布隆过滤器如何支持删除元素"></a>13 布隆过滤器如何支持删除元素</h1><p>将位数组进行修改，每一位不再是1bit，而是视情况而定，所以每一个位置可能不止是1，当需要删除元素时，将计数-1即可、</p>
<h1 id="14-键盘敲一个字符，显示到word里，操作系统完成了什么工作？-（文章里同样解释了显示器为什么显示字符）"><a href="#14-键盘敲一个字符，显示到word里，操作系统完成了什么工作？-（文章里同样解释了显示器为什么显示字符）" class="headerlink" title="14 键盘敲一个字符，显示到word里，操作系统完成了什么工作？  （文章里同样解释了显示器为什么显示字符）"></a>14 键盘敲一个字符，显示到word里，操作系统完成了什么工作？  （文章里同样解释了显示器为什么显示字符）</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/195701027">https://zhuanlan.zhihu.com/p/195701027</a> </p>
<p>简单来说，设备控制器屏蔽了io设备的不同，里面有对应的命令寄存器，数据寄存器，状态寄存器等。输入字符就是出发一次中断，然后cup保存上下文，来接收Io设备键入的字符进缓冲区。 （估计word进程读取这个缓冲区？）</p>
<p>显示器有一个读缓冲区，从上面的缓冲区读取字符进自身缓冲区显示字符。</p>
<p>那当用户输入了键盘字符，键盘控制器就会产生扫描码数据，并将其缓冲在键盘控制器的寄 存器中，紧接着键盘控制器通过总线给 CPU 发送中断请求。<br>CPU 收到中断请求后，操作系统会保存被中断进程的 CPU 上下文，然后调用键盘的中断处 理程序。<br>键盘的中断处理程序是在键盘驱动程序初始化时注册的，那键盘中断处理函数的功能就是从 键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符，如果 输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码，比如用户在键盘 输入的是字母 A，是显示字符，于是就会把扫描码翻译成 A 字符的 ASCII 码。<br>得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显 示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲 区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的 数据缓冲区，最后将这些数据显示在屏幕里。<br>显示出结果后，恢复被中断进程的上下文。</p>
<h1 id="15-硬中断和软中断的区别"><a href="#15-硬中断和软中断的区别" class="headerlink" title="15 硬中断和软中断的区别"></a>15 硬中断和软中断的区别</h1><p><strong>(5)硬中断和软中断的区别</strong></p>
<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。</p>
<p>硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。</p>
<p>硬中断是可屏蔽的，软中断不可屏蔽。</p>
<p>硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。</p>
<p>软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。 </p>
<h1 id="16-能把某个用户进程，线程锁定在某个cpu核心上执行吗？"><a href="#16-能把某个用户进程，线程锁定在某个cpu核心上执行吗？" class="headerlink" title="16 能把某个用户进程，线程锁定在某个cpu核心上执行吗？"></a>16 能把某个用户进程，线程锁定在某个cpu核心上执行吗？</h1><p>答案是在Linux中可以。  有一个命令为taskset. </p>
<h1 id="17-手写arrayqueue-并且改造为并发时的生产者消费者队列"><a href="#17-手写arrayqueue-并且改造为并发时的生产者消费者队列" class="headerlink" title="17 .  手写arrayqueue,并且改造为并发时的生产者消费者队列"></a>17 .  手写arrayqueue,并且改造为并发时的生产者消费者队列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/z892144672/article/details/104569682">https://blog.csdn.net/z892144672/article/details/104569682</a>   这是生产者消费者队列。(可用await,notifyall)   或者RetreentLock的lock 去 lock.newCondition.   一个代表不空，一个代表不满。  从队列消费，插入数据就通过对这两个condition操作 来实现并发同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">待本人手写一次。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerQueue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxCapcity</span> <span class="operator">=</span> INT_MAX;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">capcity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">static</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">static</span> <span class="variable">notNull</span> <span class="operator">=</span> lock.NewCoindition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">static</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.NewCoindition();</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">ProducerConsumerQueue</span><span class="params">(<span class="type">int</span> lenth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lenth &gt; maxCapcity)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;overflow the Maxcapcity&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lenth &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;the capcity can&#x27;t less than 0&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[lenth];</span><br><span class="line">        <span class="built_in">this</span>.size = lenth-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.capcity = lenth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">ProducerConsumerQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capcity = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object x)</span>&#123;</span><br><span class="line">        <span class="comment">//主要逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (size== capcity)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;队列已满，暂不能插入&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">if</span> (tail == capcity)&#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[tail] = x;  </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size ==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;队列已空，无元素可弹出&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">if</span> (head == capcity)&#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> queue[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//改造成并发的消费生产者；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push1</span><span class="params">(Object x)</span>&#123;</span><br><span class="line">        <span class="comment">//主要逻辑</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (size == capcity)&#123;</span><br><span class="line">                notFull.wait()</span><br><span class="line">       		 &#125;</span><br><span class="line">        	tail++;</span><br><span class="line">        	<span class="keyword">if</span> (tail == capcity)&#123;</span><br><span class="line">            	tail = <span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	queue[tail] = x;  </span><br><span class="line">        	size++;</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        	<span class="keyword">while</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            	notEmpty.wait();</span><br><span class="line">        	&#125;</span><br><span class="line">          	  head++;</span><br><span class="line">        	<span class="keyword">if</span> (head == capcity)&#123;</span><br><span class="line">            	head = <span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	size--;</span><br><span class="line">        	notFull.signalAll();</span><br><span class="line">        	<span class="keyword">return</span> queue[head];</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-对称的二叉树。"><a href="#18-对称的二叉树。" class="headerlink" title="18.对称的二叉树。"></a>18.对称的二叉树。</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> R <span class="keyword">or</span> <span class="keyword">not</span> L <span class="keyword">or</span> L.val != R.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> recur(L.left,R.right) <span class="keyword">and</span> recur(L.right,R.left)</span><br></pre></td></tr></table></figure>

<h1 id="19-关于MVCC在读取已提交和可重复读的区别，以及快照读，当前读的概念区别，与应用举例："><a href="#19-关于MVCC在读取已提交和可重复读的区别，以及快照读，当前读的概念区别，与应用举例：" class="headerlink" title="19.关于MVCC在读取已提交和可重复读的区别，以及快照读，当前读的概念区别，与应用举例："></a>19.关于MVCC在读取已提交和可重复读的区别，以及快照读，当前读的概念区别，与应用举例：</h1><p>快照读是指MVCC版本链上已经提交的版本。</p>
<p>当前读是要读取最新版本，如果最新版本没有提交，就会阻塞。</p>
<p>可重复读是建立一次快照就不建立新的。</p>
<p>读取已提交则是每次建立一次新的快照。读取的是已提交事务的数据。</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205003139748.png" alt="image-20211205003139748"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205005731502.png" alt="image-20211205005731502"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205005908149.png" alt="image-20211205005908149"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205010801163.png" alt="image-20211205010801163"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211205013126457.png" alt="image-20211205013126457"></p>
<h1 id="20-redolog-与undolog这些的区别"><a href="#20-redolog-与undolog这些的区别" class="headerlink" title="20.redolog 与undolog这些的区别"></a>20.redolog 与undolog这些的区别</h1><p>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：<br><strong>1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</strong><br><strong>2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng629/article/details/106310027/">https://blog.csdn.net/suifeng629/article/details/106310027/</a> 涉及到两阶段提交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">写入：redo log（prepare）</span><br><span class="line"></span><br><span class="line">写入：binlog</span><br><span class="line"></span><br><span class="line">写入：redo log（commit）</span><br><span class="line"></span><br><span class="line">而两阶段提交，就解决这个问题，crash recovery 时：</span><br><span class="line"></span><br><span class="line">如果 redo log 已经 commit，那毫不犹豫的，把事务提交</span><br><span class="line"></span><br><span class="line">如果 redo log 处于 prepare，则去判断事务对应的 binlog 是不是完整的</span><br><span class="line"></span><br><span class="line">是，则把事务提交</span><br><span class="line"></span><br><span class="line">否，则事务回滚</span><br><span class="line"></span><br><span class="line">两阶段提交，其实是为了保证 redo log 和 binlog 的逻辑一致性。</span><br></pre></td></tr></table></figure>

<p><strong>bin log</strong></p>
<p>bin log中记录的是整个mysql数据库的操作内容，对所有的引擎都适用，包括执行的DDL、DML，可以用来进行数据库的恢复及复制。bin log有三种形式：statement、row、mixed，statement是基于语句的，也就是执行的sql语句，该种形式的文件比较小，例，update t1 set age&#x3D;’24’ where name like ‘%王%’，这样一条语句，在statement下就会记录这样一条sql；row是基于数据行的，会记录变化的所有数据，一般文件较大。例，update t1 set age&#x3D;’24’ where name like ‘%王%’，这条语句，在row的形式下，则会记录该条sql影响的所有数据记录；mixed是混合格式，是statement和row的组合；</p>
<p><strong>redo log</strong></p>
<p>redo log中记录的是要更新的数据，比如一条数据已提交成功，并不会立即同步到磁盘，而是先记录到redo log中，等待合适的时机再刷盘，为了实现事务的持久性</p>
<p><strong>undo log</strong></p>
<p>undo log中记录的是当前操作中的相反操作，一条insert语句在undo log中会对应一条delete语句，update语句会在undo log中对应相反的update语句，在事务回滚时会用到undo log，实现事务的原子性，同时会用在MVCC中，undo中会有一条记录的多个版本，用在快照读中；</p>
<p><strong>innodb_flush_log_at_trx_commit</strong></p>
<p>0: 每隔1s，系统后台线程刷log buffer,也就是把redo日志刷盘，这里会调用fsync，所以可能丢失最后1s的事务。</p>
<p>1: 每次commit时，刷redo日志，确定fsync刷盘</p>
<p>2: 每次提交时，刷redo日志到文件系统，不调用fsync刷盘，5.6.6之前是每隔1s刷盘，之后的版本是通过参数innodb_flush_log_at_timeout设置，默认也是1s。所以也可能丢最后一秒的事务。如果有掉电保护组件的话，可以开启。</p>
<p><strong>sync_binlog</strong></p>
<p>表示每多少个sync事件触发一次真正的binlog fsync刷盘，默认是1，表示每次commit时binlog都会fsync。</p>
<p><strong>什么情况下会出现binlog写入了，但是实际这条数据不存在库中？</strong></p>
<p>innodb_flush_log_at_trx_commit 为0， sync_binlog&#x3D;1，此时redo log没有刷盘，binlog刷盘了，recover的时候不会根据binlog恢复。</p>
<p><strong>所以强烈建议这两个参数都设置成1.</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/teach/p/14730608.html">https://www.cnblogs.com/teach/p/14730608.html</a></p>
<h1 id="21-关于redolog-的疑问，断电到底会不会丢失数据-，能不能保证持久性。"><a href="#21-关于redolog-的疑问，断电到底会不会丢失数据-，能不能保证持久性。" class="headerlink" title="21 关于redolog 的疑问，断电到底会不会丢失数据 ，能不能保证持久性。"></a>21 关于redolog 的疑问，断电到底会不会丢失数据 ，能不能保证持久性。</h1><p>实际上要严格保证数据不丢失，必须得保证 innodb_flush_log_at_trx_commit 配置为 1。</p>
<p>如果配置成 0，则 redo log 即使标记为 commit 状态了，由于此时 redo log 处于 redo log buffer 中，如果断电，redo log buffer 内存中的数据会丢失，此时如果恰好 buffer pool 中的脏页也还没有刷新到磁盘，而 redo log 也丢失了，所以在 MySQL 重启后，由于丢失了一条 redo log，因此就会丢失一条 redo log 对应的重做日志，这样断电前提交的那一次事务的数据也就丢失了。</p>
<p>如果配置成 2，则事务提交时，会将 redo log buffer（实际上是此次事务所对应的那条 redo log 所在的 redo log block ）写入磁盘，但是操作系统通常都会存在 os cache，所以这时候的写只是将数据写入到了 os cache，如果机器断电，数据依然会丢失。</p>
<p>而如果配置成 1，则表示事务提交时，就将对应的 redo log block 写入到磁盘，同时调用 fsync，fsync 会将数据强制从 os cache 中刷入到磁盘中，因此数据不会丢失。</p>
<p>从效率上来说，0 的效率最高，因为不涉及到磁盘 IO，但是会丢失数据；而 1 的效率最低，但是最安全，不会丢失数据。2 的效率居中，会丢失数据。在实际的生产环境中，通常要求是的是“双 1 配置”，即将 innodb_flush_log_at_trx_commit 设置为 1，另外一个 1 指的是写 binlog 时，将 sync_binlog 设置为 1，这样 binlog 的数据就不会丢失（后面的文章中会分析 binlog 相关的内容）。</p>
<h1 id="22、spring的controller是不是单例安全的"><a href="#22、spring的controller是不是单例安全的" class="headerlink" title="22、spring的controller是不是单例安全的"></a>22、spring的controller是不是单例安全的</h1><p>Spring的controller默认是单例，所以不是线程安全的，如果有非静态属性，不安全。  可以设置为其他的prototype，Request等类型。</p>
<p>由此可以得出，如果单例出现并发混乱，可以一开始不设置非静态属性。 或者使用threadlocal变量，来避免并发混乱。</p>
<h1 id="23-无重复最长字串"><a href="#23-无重复最长字串" class="headerlink" title="23 无重复最长字串"></a>23 无重复最长字串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># //如果输入为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># //采用双指针法,通过字典查看是否有重复字符</span></span><br><span class="line">        lenth = <span class="built_in">len</span>(s)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res =[]</span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,lenth):</span><br><span class="line">            <span class="comment"># //i是后面的指针，当无重复直接下一个循环，重复时，前面的指针开始移动，减少字典中对应字母的次数，直到目标字母降为1</span></span><br><span class="line">            dic[s[i]] = dic.get(s[i],<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dic[s[i]] &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (i-j&gt;last):</span><br><span class="line">    </span><br><span class="line">                last = i-j</span><br><span class="line">            <span class="keyword">while</span> dic[s[i]] == <span class="number">2</span> :</span><br><span class="line">                dic[s[j]] = dic[s[j]]-<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenth-j &gt; last:</span><br><span class="line">            last = lenth-j</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<h1 id="24-寻找最近的回文数"><a href="#24-寻找最近的回文数" class="headerlink" title="24 寻找最近的回文数"></a>24 寻找最近的回文数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">nearestPalindromic</span><span class="params">(string n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> len = n.<span class="built_in">size</span>(), num = <span class="built_in">stol</span>(n), res, minDiff = LONG_MAX;</span><br><span class="line">        unordered_set&lt;<span class="type">long</span>&gt; s;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">pow</span>(<span class="number">10</span>, len) + <span class="number">1</span>);</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">pow</span>(<span class="number">10</span>, len - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> prefix = <span class="built_in">stol</span>(n.<span class="built_in">substr</span>(<span class="number">0</span>, (len + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            string pre = <span class="built_in">to_string</span>(prefix + i);</span><br><span class="line">            string str = pre + <span class="built_in">string</span>(pre.<span class="built_in">rbegin</span>() + (len%<span class="number">2</span>), pre.<span class="built_in">rend</span>());</span><br><span class="line">            s.<span class="built_in">insert</span>(<span class="built_in">stol</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : s) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> diff = <span class="built_in">abs</span>(a - num);</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; minDiff) </span><br><span class="line">            &#123;</span><br><span class="line">                minDiff = diff;</span><br><span class="line">                res = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff == minDiff) </span><br><span class="line">                res = <span class="built_in">min</span>(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">可以证明以下结论： 如果n 的前半部分是整数N，那么它的解一定是 以下三者之一：</span><br><span class="line">N<span class="number">-1</span> 和 N<span class="number">-1</span>的回文组成的数字。</span><br><span class="line">N 和 N的回文组成的数字</span><br><span class="line">N+<span class="number">1</span> 和 N+<span class="number">1</span> 的回文组成的数字</span><br><span class="line">利用这个结论生成<span class="number">3</span>个解，取最小就行。 例 <span class="number">1230</span>XXX的解 是 <span class="number">1230321</span>, <span class="number">1229221</span>, <span class="number">1231321</span> 中的一个。 过程中处理下奇偶数长度，N是<span class="number">9999</span> N是<span class="number">10000</span>等等特殊值.</span><br><span class="line">    </span><br><span class="line">可以发现特殊情况是，位数增加时，是<span class="number">1</span>+<span class="number">1</span>e(n+<span class="number">1</span>)  位数减少时，是 <span class="number">1</span>e(n<span class="number">-1</span>)<span class="number">-1</span>。 所以最开始插入他们进Map</span><br></pre></td></tr></table></figure>

<h1 id="25-Autowired-怎么实现的"><a href="#25-Autowired-怎么实现的" class="headerlink" title="25 @Autowired 怎么实现的"></a>25 @Autowired 怎么实现的</h1><p>AutowiredAnnotationBeanPostProcessor 类 中查出了目标处理类中带有这个注释的 字段，方法等，最后返回InjectionMetadata类，这个类由一是我们处理的目标类，二就是上述方法获取到的所以elements集合。 然后调用这个类的inject方法。里面遍历element再调用一个inject方法</p>
<p>对于字段的话，本质上就是去set这个字段的值，即对对象进行实例化和赋值，</p>
<p>对于方法的话，本质就是去调用这个方法，因此这里调用的是method.invoke.</p>
<p>完成注入。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/topdeveloperr/article/details/87971446">https://blog.csdn.net/topdeveloperr/article/details/87971446</a></p>
<h1 id="26-循环依赖问题"><a href="#26-循环依赖问题" class="headerlink" title="26 循环依赖问题"></a>26 循环依赖问题</h1><ul>
<li>属性和setter方法循环依赖。</li>
</ul>
<p>解决方案：<br>1.spring将已经完成了构造注入但是未完成setter注入的bean暴露出来<br>2.当进行setter注入时，发现这个需被注入的bean已经被暴露出来（存在该bean的引用），直接注入即可，而不需要再次加载所需的bean(无需再经历从头开始加载一个bean的过程，也就不会报错了)。</p>
<ul>
<li>构造器循环依赖</li>
</ul>
<p>无解。出错。</p>
<h1 id="27-rand6-生产rand-9（投6面筛子选出9人中的两人。）"><a href="#27-rand6-生产rand-9（投6面筛子选出9人中的两人。）" class="headerlink" title="27 rand6 生产rand 9（投6面筛子选出9人中的两人。）"></a>27 rand6 生产rand 9（投6面筛子选出9人中的两人。）</h1><p>注意： 这样保证的是每个数的概率一样。</p>
<p>思路就是 n进制。  两次rand6， 一个放在十位，一个放在个位。 结果是00，01，02….06,10,…   明显是7进制。 所以可以表示为 rand6*7+rand6 . 此时最高显示48.后续根据需求，舍弃一部分数字，然后按照除以某一个数，作为结果。</p>
<p>在投6面筛子选出9人中的两人。 就是可以认为 rand5 实现rand8 .  所以是6进制。 最大36.。  我们舍弃36，剩下的除以4。0-3，4-7，…总共分成了9部分。 完成结果</p>
<h1 id="28-服务注册与发现的流程"><a href="#28-服务注册与发现的流程" class="headerlink" title="28 服务注册与发现的流程"></a>28 服务注册与发现的流程</h1><p>1、流程说明：</p>
<p>Provider(提供者)绑定指定端口并启动服务</p>
<p>指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储</p>
<p>Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</p>
<p>注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</p>
<p>Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</p>
<p>Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer</p>
<p>2、设计的原因：</p>
<p>Consumer 与Provider 解偶，双方都可以横向增减节点数。</p>
<p>注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</p>
<p>去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</p>
<p>服务提供者无状态，任意一台宕掉后，不影响使用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43217065/article/details/105389452?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-105389452.pc_agg_new_rank&amp;utm_term=%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E7%9A%84%E6%B5%81%E7%A8%8B&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_43217065/article/details/105389452?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-105389452.pc_agg_new_rank&amp;utm_term=%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E7%9A%84%E6%B5%81%E7%A8%8B&amp;spm=1000.2123.3001.4430</a></p>
<h2 id="实现RPC框架"><a href="#实现RPC框架" class="headerlink" title="实现RPC框架"></a>实现RPC框架</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/endless-code/p/11235624.html">https://www.cnblogs.com/endless-code/p/11235624.html</a></p>
<h3 id="PostConstruct基本：（用于找到所有背注解rpcsetvice的类，注册信息进注册-中心）"><a href="#PostConstruct基本：（用于找到所有背注解rpcsetvice的类，注册信息进注册-中心）" class="headerlink" title="@PostConstruct基本：（用于找到所有背注解rpcsetvice的类，注册信息进注册 中心）"></a>@PostConstruct基本：（用于找到所有背注解rpcsetvice的类，注册信息进注册 中心）</h3><p>@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。</p>
<p>Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</p>
<p>通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：</p>
<p>Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</p>
<p>BeanPostProcessor有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct @PreDestroy注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;rpc server start scanning provider service...&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; beanMap = <span class="built_in">this</span>.applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != beanMap &amp;&amp; !beanMap.isEmpty()) &#123;</span><br><span class="line">        beanMap.entrySet().forEach(one -&gt; &#123;</span><br><span class="line">            initProviderBean(one.getKey(), one.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;rpc server scan over...&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果有服务的话才启动netty server</span></span><br><span class="line">    <span class="keyword">if</span> (!beanMap.isEmpty()) &#123;</span><br><span class="line">        startNetty(rpcProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer部分-BeanPostProcessor"><a href="#Consumer部分-BeanPostProcessor" class="headerlink" title="Consumer部分   BeanPostProcessor"></a>Consumer部分   BeanPostProcessor</h3><p><code>BeanPostProcessor</code>也称为Bean后置处理器，它是Spring中定义的接口，在Spring容器的创建过程中（具体为Bean初始化前后）会回调BeanPostProcessor中定义的两个方法。上面实现的<code>postProcessBeforeInitialization</code>是在Bean初始化之前调用的，还有一个<code>postProcessAfterInitialization</code>方法是在Bean初始化之后调用的。<br>如上面代码所示，我们会在每一个带有<code>@RpcConsumer</code>的实例初始化之前利用反射机制为其设置一个<code>RpcProxy</code>的代理，可以看到我们在创建这个动态代理的时候还需要服务提供者的名称，这是因为在动态代理的实现里面需要使用服务提供者的名称来查询服务提供者的地址信息。那么这个动态代理的实现又是怎样的呢？这就是我们下一步需要做的事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BeanPostProcessor <span class="title function_">beanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanPostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span><br><span class="line">                <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            Class&lt;?&gt; objClz = bean.getClass();</span><br><span class="line">            <span class="keyword">for</span> (Field field : objClz.getDeclaredFields()) &#123;</span><br><span class="line">                <span class="type">RpcConsumer</span> <span class="variable">rpcConsumer</span> <span class="operator">=</span> field.getAnnotation(RpcConsumer.class);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != rpcConsumer) &#123;</span><br><span class="line">                    Class&lt;?&gt; type = field.getType();</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        field.set(bean, rpcProxy.create(type, rpcConsumer.providerName()));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>无论客户端 还是服务端，通信使用Netty，使用到了 SimpleChannelInboundHandler类</p>
<p><strong>创建自定义处理器，通常继承SimpleChannelInboundHandler<T>,  该处理器覆写channelRead0方法，该方法负责请求接入，读取客户端请求，发送响应给客户端。</T></strong></p>
<h3 id="3-RpcAutoConfiguration"><a href="#3-RpcAutoConfiguration" class="headerlink" title="3 RpcAutoConfiguration"></a>3 <code>RpcAutoConfiguration</code></h3><p>除了<code>ProviderAutoConfiguration</code>和<code>ConsumerAutoConfiguration</code>两个配置类，我们还定义了一个<code>RpcAutoConfiguration</code>类来配置一些其他的东西，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDiscovery</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储服务提供者的信息。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;ProviderInfo&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceDiscovery</span><span class="params">(String registoryAddress)</span> <span class="keyword">throws</span> ZkConnectException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取zk连接。</span></span><br><span class="line">            <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(registoryAddress, <span class="number">2000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;consumer connect zk success!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            watchNode(zooKeeper);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZkConnectException</span>(<span class="string">&quot;connect to zk exception,&quot;</span> + e.getMessage(), e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听服务提供者的变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个服务提供者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ProviderInfo <span class="title function_">discover</span><span class="params">(String providerName)</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的构造方法里面，我们和ZK注册中心建立了一个连接，并且在<code>watchNode</code>方法中监听服务提供者节点的变化，当有服务提供者信息有变化时会去修改<code>dataList</code>里的内容，这样可以保证在服务本地维持一份可用的服务提供者的信息。而在远程调用发生的时候我们会通过<code>discover</code>方法（PS：前面有见到过哦）去<code>dataList</code>里面寻找一个可用的服务提供者来提供服务。</p>
<h1 id="29-mysql优化器决定不适用索引"><a href="#29-mysql优化器决定不适用索引" class="headerlink" title="29 mysql优化器决定不适用索引"></a>29 mysql优化器决定不适用索引</h1><p>由类似的参数，msyql的EXplain中有预估扫描数据行数rows。一旦超过全表百分之多少（按照配置），将启动全表扫描，而不使用索引。但是并不代表全表扫描比使用索引快，可以强制使用索引试试。比较两者谁更快。</p>
<h1 id="30-关于抽象类"><a href="#30-关于抽象类" class="headerlink" title="30 关于抽象类"></a>30 关于抽象类</h1><ul>
<li>抽象类不能被实例化</li>
<li>抽象类可以有抽象方法，抽象方法只需申明，无需实现</li>
<li>含有抽象方法的类必须申明为抽象类</li>
<li>抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</li>
<li>抽象方法不能被声明为静态</li>
<li>抽象方法不能用 private 修饰</li>
<li>抽象方法不能用 final 修饰</li>
</ul>
<h1 id="31-关于多态"><a href="#31-关于多态" class="headerlink" title="31 关于多态"></a>31 关于多态</h1><p>父类引用，引用子类实例，调用的是子类的方法（前提是子类真的继承了这个方法，一旦父类方法private，子类没有继承，那么就会报错）</p>
<p>Animal animal &#x3D; new Cat();<br>就以这个为例子。<br>你这里虽然声明的事Animal，但是它的实例对象使用Cat去实现的，所以当你调用animal.show();时，肯定是调用子类的实现方法。不过你这里父类采用的是私有的方法，那么你子类将无法继承，所以你这段代码执行时会报错</p>
<h1 id="32-一个环，有n个点-问从0点出发，经过k步回到原点有多少种方法（字节面试题，java解法）"><a href="#32-一个环，有n个点-问从0点出发，经过k步回到原点有多少种方法（字节面试题，java解法）" class="headerlink" title="32 一个环，有n个点, 问从0点出发，经过k步回到原点有多少种方法（字节面试题，java解法）"></a>32 一个环，有n个点, 问从0点出发，经过k步回到原点有多少种方法（字节面试题，java解法）</h1><p><strong>状态方程</strong>为：<code>d(k, j) = d(k-1, j-1) + d(k-1, j+1);</code><br>由于可能发生越界，故转换为<br><code>d(k, j) = d(k-1, (j-1+n)%n) + d(k-1, (j+1)%n);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//n为环数，k为步数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetSteps</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果只有2个环，则偶数有1个方法，奇数不能到达</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>][n];</span><br><span class="line">        <span class="comment">//0步到达0点有1种方法</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//0步到达任意点有0种方法,可java自赋0值，可省略</span></span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//    dp[0][i]=0</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="comment">//j步达到i点的问题，转化为j-1步从相邻的两个节点到达目标节点的方法数之和。</span></span><br><span class="line">                <span class="comment">//需要保证在0~n-1范围，故需要防止越界进行处理</span></span><br><span class="line">                dp[j][i]=dp[j-<span class="number">1</span>][(i-<span class="number">1</span>+n)%n]+dp[j-<span class="number">1</span>][(i+<span class="number">1</span>)%n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里的0对应的是回到0点，达到任意点可以通过将0改为目标点即可</span></span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Solution</span>().GetSteps(<span class="number">10</span>,<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="33-csrf攻击"><a href="#33-csrf攻击" class="headerlink" title="33 csrf攻击"></a>33 csrf攻击</h1><p>　　你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/2009040916453171.jpg" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html%E3%80%82">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html。</a></p>
<p>所以不使用cookie，使用token存在LocalStorage时，可以解决Csrf攻击。</p>
<h1 id="34-线程之间共享的资源与不共享的资源。"><a href="#34-线程之间共享的资源与不共享的资源。" class="headerlink" title="34  线程之间共享的资源与不共享的资源。"></a>34  线程之间共享的资源与不共享的资源。</h1><p>线程私有的：</p>
<p>所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。 线程Id，线程的信号屏蔽码，线程优先级。。。？</p>
<p>以上这些信息有一个统一的名字，就是<strong>线程上下文</strong>，thread context。</p>
<p>共享的：</p>
<ul>
<li><p>代码区      进程地址空间中的代码区，这里保存的是什么呢？从名字中有的同学可能已经猜到了，没错，这里保存的就是我们写的代码，<strong>更准确的是编译后的可执行机器指令</strong>。</p>
</li>
<li><p>数据区     进程地址空间中的数据区，这里存放的就是所谓的全局变量。</p>
</li>
<li><p>堆    因此堆区也是线程共享的属于进程的资源。</p>
</li>
<li><p><strong>栈区</strong>唉，等等！刚不是说栈区是线程私有资源吗，怎么这会儿又说起栈区了？</p>
<p>确实，从线程这个抽象的概念上来说，栈区是线程私有的，然而从实际的实现上看，<strong>栈区属于线程私有这一规则并没有严格遵守</strong>，这句话是什么意思？</p>
<p>通常来说，注意这里的用词是<strong>通常</strong>，通常来说栈区是线程私有，既然有通常就有不通常的时候。</p>
<p>不通常是因为不像进程地址空间之间的严格隔离，线程的栈区没有严格的隔离机制来保护，因此如果一个线程能拿到来自另一个线程栈帧上的指针，<strong>那么该线程就可以改变另一个线程的栈区</strong>，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量</p>
</li>
<li><p><strong>文件</strong></p>
<p>最后，如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p>
</li>
</ul>
<h1 id="35-快排的partiton"><a href="#35-快排的partiton" class="headerlink" title="35 快排的partiton"></a>35 快排的partiton</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[left];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; pivot)&#123;  (这里小于重要。没有等号)</span><br><span class="line">            j++;</span><br><span class="line">            swap(array,j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array,left,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(a,left,right);</span><br><span class="line">    quicksort(array,left,index-<span class="number">1</span>);</span><br><span class="line">    quicksort(array,index+<span class="number">1</span>，right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第K大</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickselect</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> lenth-k;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> lenth-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(array,left,right);</span><br><span class="line">        <span class="keyword">if</span> (index&lt;target)&#123;</span><br><span class="line">            left = index+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &gt; traget)&#123;</span><br><span class="line">            right = index-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[target];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="36-树中两个节点的最近的公共父节点"><a href="#36-树中两个节点的最近的公共父节点" class="headerlink" title="36 树中两个节点的最近的公共父节点"></a>36 树中两个节点的最近的公共父节点</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">二叉树。</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">二叉搜索树</span><br><span class="line"> <span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root   </span><br></pre></td></tr></table></figure>

<h1 id="37-NIO"><a href="#37-NIO" class="headerlink" title="37 NIO"></a>37 NIO</h1><h4 id="NIO："><a href="#NIO：" class="headerlink" title="NIO："></a>NIO：</h4><p>NIO是一种同步非阻塞IO, 基于Reactor模型来实现的。</p>
<p>其实相当于就是一个线程处理大量的客户端的请求，通过一个线程轮询大量的channel，每次就获取一批有事件的channel，然后对每个请求启动一个线程处理即可。</p>
<p> 这里的核心就是非阻塞，就那个selector一个线程就可以不停轮询channel，所有客户端请求都不会阻塞，直接就会进来，大不了就是等待一下排着队而已。</p>
<p>这里面<strong>优化BIO的核心</strong>就是，一个客户端并不是时时刻刻都有数据进行交互，没有必要死耗着一个线程不放，所以客户端选择了让线程歇一歇，只有客户端有相应的操作的时候才发起通知，创建一个线程来处理请求。</p>
<h4 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞:"></a>同步非阻塞:</h4><p>为什么说NIO为啥是同步非阻塞？ </p>
<p>因为无论多少客户端都可以接入服务端，客户端接入并不会耗费一个线程，只会创建一个连接然后注册到selector上去，这样你就可以去干其他你想干的其他事情了</p>
<p>一个selector线程不断的轮询所有的socket连接，发现有事件了就通知你，然后你就启动一个线程处理一个请求即可，这个过程的话就是非阻塞的。</p>
<p>但是这个处理的过程中，你还是要先读取数据，处理，再返回的，这是个同步的过程。</p>
<h4 id="多路复用机制实现Selector"><a href="#多路复用机制实现Selector" class="headerlink" title="多路复用机制实现Selector"></a>多路复用机制实现Selector</h4><p> 只有当莫个Channel有对应的请求的时候才会创建线程，可能说1000个请求， 只有100个请求是有数据交互的 </p>
<p>这个时候可能server端就提供10个线程就能够处理这些请求。这样的话就可以避免了创建大量的线程。</p>
<p>Channel是NIO中的数据通道，类似流，但是又有些不同</p>
<p>Channel既可从中读取数据，又可以从写数据到通道中，但是流的读写通常是单向的。</p>
<p> Channel可以异步的读写。Channel中的数据总是要先读到一个Buffer中，或者从缓冲区中将数据写到通道中。</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/774371-20190716140620340-1681775116.png" alt="img"></p>
<h1 id="38-操作系统堆栈都是干嘛的"><a href="#38-操作系统堆栈都是干嘛的" class="headerlink" title="38 操作系统堆栈都是干嘛的"></a>38 操作系统堆栈都是干嘛的</h1><p>*栈： 用户维护函数调用上下文。由高地址向低地址生长，通常以M为单位，由操作系统维护。</p>
<p>　　[不能申请占用过大的内存的局部变量，会导致栈爆掉而core.如果变量太大，可以考虑放到全局变量区或者使用堆]</p>
<p>*堆： 动态申请内存，即使用new or malloc等分配到的内存，可以比栈大很多，需用户自己释放</p>
<p>操作系统中的堆：</p>
<pre><code>  这里的堆是属于内存分配方式的一种：动态分配内存。

  实现的方式更接近于链表。堆内存中有很多块内存，可能不是连续的。所有需要用链表来组织在分配的时候，有多种策略。首先查找是否有空闲的并且满足大小的堆内存，然后把最大的那块给需求者。这里有点像数据结构中堆的优先权。
</code></pre>
<p>操作系统中堆和栈的区别：</p>
<pre><code>      1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

      2、堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
</code></pre>
<p>栈使用的是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/16882.htm">一级缓存</a>， 他们通常都是被调用时处于存储空间中，调用完毕立即释放</p>
<p>堆则是存放在<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/27650.htm">二级缓存</a>中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<h1 id="39、-给出IP地址和子网掩码-如何计算该网段的广播地址？"><a href="#39、-给出IP地址和子网掩码-如何计算该网段的广播地址？" class="headerlink" title="39、 给出IP地址和子网掩码,如何计算该网段的广播地址？"></a>39、 给出IP地址和子网掩码,如何计算该网段的广播地址？</h1><p>例如ip地址是190.168.1.5<br>子网掩码是255.255.255.128</p>
<p>从子网掩码中我们可以看出该ip的网络位、子网位、主机位分别是多少。190说明该地址是一个B类ip地址，所以网络位是16位<br>从子网掩码255.255.255.128可以看出这是一个&#x2F;25的网络所以子网位是25-16也就是9位，主机地址是7位。当主机位是全1时我们将该地址作为子网广播地址</p>
<ul>
<li>网络地址的主机位全部为1才是广播地址，网络地址是ip与子网掩码与运算。</li>
</ul>
<p>后边7位是主机位，将主机位全设为1则为子网广播地址所以广播地址为<br>190.168.1.0<br>1111111<br>化成十进制位190.168.1.127</p>
<p>使用子网掩码划分子网后，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91/1186929">子网</a>内可以通信，跨子网不能通信，子网间通信应该使用路由器，</p>
<ul>
<li><strong>所以所有非标准的的子网号，都是起到了划分子网的作用，借用了主机位来划分子网。此处，因为B类地址，所以除掉B类的16位，ip地址与子网掩码与运算的结果网络位总共还剩下9位。</strong></li>
</ul>
<h1 id="40-、子网掩码作用，广播地址作用"><a href="#40-、子网掩码作用，广播地址作用" class="headerlink" title="40 、子网掩码作用，广播地址作用"></a>40 、子网掩码作用，广播地址作用</h1><p>广播地址是给当前网段的所有主机发送消息&#x2F;包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子网掩码它有两个主要作用：一是屏蔽部分IP地址，区分网络标识和主机标识，解释IP地址是在局域网上还是在远程网络上，其次将一个大的IP网络划分为几个小的子网络。</span><br><span class="line">子网掩码可以减少IP浪费</span><br></pre></td></tr></table></figure>

<p>1.将ip地址与子网掩码转换成二进制；</p>
<p>2.将二进制形式的ip地址与子网掩码做’与’运算，将答案化为十进制便得到网络地址；</p>
<p>3.将二进制形式的子网掩码取’反’；</p>
<p>4.将取’反’后的子网掩码与ip地址做’与’运算，将答案化为十进制便得到主机地址。</p>
<p>网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址，<br>由此可以看出地址范围是： 网络地址+1 至 广播地址-1</p>
<ul>
<li>主机的数量&#x3D;2^二进制位数的主机-2</li>
</ul>
<p>减2是因为主机不包括网络地址和广播地址</p>
<h1 id="41-数据库三大范式"><a href="#41-数据库三大范式" class="headerlink" title="41 数据库三大范式"></a>41 数据库三大范式</h1><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>1<strong>、第一范式(确保每列保持原子性)</strong></p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p><strong>第二范式(确保表中的每列都和主键相关)</strong></p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言</p>
<p><strong>3****．第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<h1 id="42-String的hashcode和equal是怎么重写的-给你两个Object对象怎么重写equals方法？"><a href="#42-String的hashcode和equal是怎么重写的-给你两个Object对象怎么重写equals方法？" class="headerlink" title="42 String的hashcode和equal是怎么重写的 给你两个Object对象怎么重写equals方法？"></a>42 String的hashcode和equal是怎么重写的 给你两个Object对象怎么重写equals方法？</h1><p>String的 hashCode() 返回的是 int ( 通过String所有位的ASCII码计算生成，s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1] )。</p>
<p>hashcode有助于减少equal的调用。</p>
<ul>
<li><p>Java采用了hash表，能够根据数据的特征值当作地址，这样大大减少了数据访问。使用hash表法，存在相同的数据的特征值必定相等，而不同的数据不一定特征值不相等。String重写了hashCode减少了equal()的使用，大大提高了效率。</p>
</li>
<li><p>重写Equal必须重写hashcode，不然会出现Equal相等，hashcode不等，结果存入hashset因为hashcode问题存入重复数据。</p>
</li>
</ul>
<h1 id="43-hashSet的存储"><a href="#43-hashSet的存储" class="headerlink" title="43 hashSet的存储"></a>43 hashSet的存储</h1><p>1，如果hash码值不相同，说明是一个新元素，存；</p>
<p>如果没有元素和传入对象（也就是add的元素）的hash值相等，那么就认为这个元素在table中不存在，将其添加进table；</p>
<p>2（1），如果hash码值相同，且equles判断相等，说明元素已经存在，不存；</p>
<p>2（2），如果hash码值相同，且equles判断不相等，说明元素不存在，存；</p>
<p><strong>hashset的存方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当向 HashSet 中添加元素时，如果此时添加一个 HashSet 已存在的元素时<br>此时肯定会发生 Hash 冲突的<br>那么接下来，会进行该元素的 equals() 方法或 &#x3D;&#x3D; 的比较，如果它们的 equals() 方法或 &#x3D;&#x3D; 比较的结果为 true 即相等，则 HashMap 会使用新 value 值覆盖旧 value 值<br>而到此时，<strong>HashMap 的 put() 方法的返回值为一个 oldValue，故而 HashSet 的 add 方法的返回值为 false</strong>，即添加一个已存在的元素时会失败</p>
<h1 id="44-execute和submit的区别"><a href="#44-execute和submit的区别" class="headerlink" title="44** execute和submit的区别**"></a>44** execute和submit的区别**</h1><ul>
<li>execute只能提交Runnable类型的任务，无返回值。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。</li>
<li>execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。</li>
</ul>
<h1 id="45-OSI七层协议"><a href="#45-OSI七层协议" class="headerlink" title="45 OSI七层协议"></a>45 OSI七层协议</h1><p>1、物理层协议有bai：EIA&#x2F;TIA-232，du EIA&#x2F;TIA-499，V.35， V.24，RJ45， Ethernet， 802.3</p>
<p>2、数据链路zhi层协议dao有：Frame Relay，HDLC，PPP， IEEE 802.3&#x2F;802.2</p>
<p>3、网络层协议有：IP，IPX，AppleTalk DDP</p>
<p>4、传输层协议有：TCP，UDP，SPX</p>
<p>5、会话层协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk</p>
<p>6、表示层协议有：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption</p>
<p>7、应用层协议有：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP</p>
<table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>功能</th>
<th>对应的网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为为用户提供常用的应用程序，每个网络应用都对应着不同的协议</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
</tr>
<tr>
<td>表示层</td>
<td>主要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译</td>
<td>Telnet, Rlogin, SNMP, Gopher</td>
</tr>
<tr>
<td>会话层</td>
<td>负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信</td>
<td>SMTP, DNS</td>
</tr>
<tr>
<td>传输层</td>
<td>是整个网络关键的部分，是实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>进行逻辑地址寻址，实现不同网络之间的路径选择，IP就在网络层</td>
<td>IP, ICMP, ARP, RARP, AKP, UUCP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>物理地址（MAC地址），网络设备的唯一身份标识。建立逻辑连接、进行硬件地址寻址，相邻的两个设备间的互相通信</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
</tr>
<tr>
<td>物理层</td>
<td>七层模型中的最底层，主要是物理介质传输媒介（网线或者是无线），在不同设备中传输比特，将0&#x2F;1信号与电信号或者光信号互相转化</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802</td>
</tr>
</tbody></table>
<h1 id="46-二分"><a href="#46-二分" class="headerlink" title="46 二分"></a>46 二分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">k</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = lenth-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;j:</span><br><span class="line">        mid = i+j&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> array[mid]&lt;k:</span><br><span class="line">            i = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = mid   //最左边的target  ,target不存在，那么是大于target的第一个数</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">k</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = lenth-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;j:</span><br><span class="line">        mid = （i+j&gt;&gt;<span class="number">1</span>）+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> array[mid]&lt;=k:</span><br><span class="line">            i = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = mid-<span class="number">1</span>   //最右边的target  ,target不存在，那么是小于target的第一个数    </span><br></pre></td></tr></table></figure>

<h1 id="47-最长公共字符串-x2F-子序列"><a href="#47-最长公共字符串-x2F-子序列" class="headerlink" title="47 最长公共字符串&#x2F;子序列"></a>47 最长公共字符串&#x2F;子序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommnStr</span>(<span class="params">s1,s2</span>):</span><br><span class="line">  	<span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">    	dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>  //子字符串</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longestcommonSEq</span>(<span class="params">s1,s2</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h1 id="48-分页管理的优点-缺点"><a href="#48-分页管理的优点-缺点" class="headerlink" title="48 分页管理的优点 缺点"></a>48 分页管理的优点 缺点</h1><p><strong>二、页式存储管理</strong></p>
<p>　　优点： 没有外部碎片，最后一页可能有内碎片但不大;程序不必连续存放;便于改变程序占用空间大小。</p>
<p>　<em>*<em>*缺点： 程序仍需要全部装入内存（基本页式存储管理*</em>*<em>）。*</em>*</em></p>
<hr>
<p><strong>页大小固定，段大小不固定。</strong></p>
<p><strong>页是一维的，段是二维的；</strong></p>
<hr>
<h1 id="49-hashmap-jdk1-7死循环原因"><a href="#49-hashmap-jdk1-7死循环原因" class="headerlink" title="49 hashmap jdk1.7死循环原因"></a>49 hashmap jdk1.7死循环原因</h1><p>(扩容时的代码 )    另外hashmap线程不安全再1.7，1.8都有，多线程冲突会覆盖掉一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">      Entry[] src = table; </span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;<span class="comment">//两个线程都先进入if</span></span><br><span class="line">              src[j] = <span class="literal">null</span>; </span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//线程1 这里还没执行 停下</span></span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 线程1中 E变量指向a结点，next变量指向b结点。 </p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdzZW5saW4zNDE=,size_16,color_FFFFFF,t_7110" alt="img"></p>
<p> 然后切换成线程2，线程二完成了插入a,b</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdzZW5saW4zNDE=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>此时 切换为线程1，线程1从下方代码开始执行,变成死循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i]; <span class="comment">//线程1刚才在这里停下，所以现在从这一句代码开始执行</span></span><br><span class="line">            newTable[i] = e;  </span><br><span class="line">            e = next;          </span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/11" alt="在这里插入图片描述"></p>
<h1 id="50-为什么被final修饰"><a href="#50-为什么被final修饰" class="headerlink" title="50 为什么被final修饰:"></a>50 为什么被final修饰:</h1><p>一.被final修饰的类,不可以被继承,所以不会别其它类改变,这样会更加的安全.</p>
<p>二.string是共享在常量池中的,String str&#x3D;”abc”, char data[] &#x3D; {‘a’, ‘b’, ‘c’};是等价的,他们都放在了字符串常量池中</p>
<p>String的&#x3D;&#x3D; 和 equal不一样，因为equal重写过。</p>
<h1 id="51-为什么选择B-树做索引"><a href="#51-为什么选择B-树做索引" class="headerlink" title="51 为什么选择B+树做索引"></a>51 为什么选择B+树做索引</h1><h2 id="七、为什么说B-树比B树更适合数据库索引？"><a href="#七、为什么说B-树比B树更适合数据库索引？" class="headerlink" title="七、为什么说B+树比B树更适合数据库索引？"></a>七、为什么说B+树比B树更适合数据库索引？</h2><p>最首先是B类树的IO次数少，再在B树内中B+树有下列优点。</p>
<p>1、 <strong>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</strong></p>
<p>2、<strong>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<p>PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的：</p>
<p><strong>他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</strong></p>
<h1 id="52-最快的进程通信方式-共享内存，可以利用信号量来保证他的并发访问问题。"><a href="#52-最快的进程通信方式-共享内存，可以利用信号量来保证他的并发访问问题。" class="headerlink" title="52 最快的进程通信方式 共享内存，可以利用信号量来保证他的并发访问问题。"></a>52 最快的进程通信方式 共享内存，可以利用信号量来保证他的并发访问问题。</h1><h1 id="53-多路io复用"><a href="#53-多路io复用" class="headerlink" title="53 多路io复用"></a>53 多路io复用</h1><ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<h1 id="54-【虚拟地址到物理地址的转化过程】：-优势"><a href="#54-【虚拟地址到物理地址的转化过程】：-优势" class="headerlink" title="54 【虚拟地址到物理地址的转化过程】： 优势"></a>54 【虚拟地址到物理地址的转化过程】： 优势</h1><p>虚拟地址的高位3比特决定了对应的页（APR），APR的11-0位决定了物理地址基地址的块地址，加上虚拟地址的12-6比特得到物理内存的块地址，再加上作为块内偏移值的虚拟地址的5-0位，就得到了最后的地址。.</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/698434-20191111144738188-995471012.png" alt="img"></p>
<p>（1）<strong>实现对内存访问的管理</strong>。不同进程使用的虚拟地址彼此隔离。如果程序能直接访问物理地址，也就能访问其他进程正在使用的物理内存区域，进而可能是其他进程或者操作系统崩溃。一个进程中的代码无法更改正在由另一进程使用的物理内存。</p>
<p>（2）<strong>提高内存的使用效率</strong>。通过将不连续的物理内存区域映射到连续的虚拟内存区域，程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻（MMU完成相应的映射）的大内存缓冲区；程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区，当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件，数据或代码页会根据需要在物理内存与磁盘之间移动。</p>
<p>3）<strong>编程效率</strong>。虚拟地址是可重定位程序（ELF）实现的基础，对于每个程序来说是一块从0到2的N次方（这里N&#x3D;16）的“虚拟”内存，MMU会完成虚拟地址到内存物理地址的转化~</p>
<h1 id="55-最长连续序列（-O（n））"><a href="#55-最长连续序列（-O（n））" class="headerlink" title="55  最长连续序列（ O（n））"></a>55  最长连续序列（ O（n））</h1><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。它的长度为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">	使用<span class="built_in">hash</span>存储所有元素后，对于每一个数，暴力枚举他的下一个数，x+<span class="number">1</span>,x+<span class="number">2.</span>..是否在字典存在，这样，最坏的情况还是O(n^<span class="number">2</span>). 因为一个连续序列，会不断重复计算。 那么取第一个最小的数递增，后面的数不再递增，复杂度降低到O（n）,那么判断条件就是x-<span class="number">1</span>不存在、</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSeqeuence</span>:</span><br><span class="line">        a = <span class="built_in">set</span>()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            a.add(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">                first = i</span><br><span class="line">                now = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> first+<span class="number">1</span> <span class="keyword">in</span> a:</span><br><span class="line">                    first+=<span class="number">1</span></span><br><span class="line">                    now+=<span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,now)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="56-最长递增子序列-（O（nlogn）-）-序列长度-以及-序列"><a href="#56-最长递增子序列-（O（nlogn）-）-序列长度-以及-序列" class="headerlink" title="56 最长递增子序列 （O（nlogn） ） 序列长度 以及 序列"></a>56 最长递增子序列 （O（nlogn） ） 序列长度 以及 序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">tails, res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">pos = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">lenth = <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(lenth):</span><br><span class="line">    i, j = <span class="number">0</span>, res</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> tails[m] &lt; nums[k]: i = m + <span class="number">1</span> <span class="comment"># 如果要求非严格递增，将此行 &#x27;&lt;&#x27; 改为 &#x27;&lt;=&#x27; 即可。</span></span><br><span class="line">        <span class="keyword">else</span>: j = m</span><br><span class="line">    tails[i] = nums[k]</span><br><span class="line">    pos[k] = i </span><br><span class="line">    <span class="keyword">if</span> j == res: res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">j = res-<span class="number">1</span>						//这一部分</span><br><span class="line">res1 = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="built_in">range</span>(res)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> j == pos[i]:</span><br><span class="line">        res1[j] = nums[i]</span><br><span class="line">        j-=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="57hashmap选择红黑树，为啥hashmap不直接采用红黑树，为什么达到8个才转红黑树"><a href="#57hashmap选择红黑树，为啥hashmap不直接采用红黑树，为什么达到8个才转红黑树" class="headerlink" title="57	hashmap选择红黑树，为啥hashmap不直接采用红黑树，为什么达到8个才转红黑树"></a>57	hashmap选择红黑树，为啥hashmap不直接采用红黑树，为什么达到8个才转红黑树</h1><ol>
<li><p>为什么直接采用红黑树<br>因为红黑树需要进行左旋，右旋操作， 而<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</a>不需要，<br>主要考察链表和红黑树对比：<br>1）如果元素小于8个，查询成本高，新增成本低<br>2）如果元素大于8个，查询成本低，新增成本高</p>
</li>
<li><p>HashMap在jdk1.8之后引入了红黑树的概念，为什么采用6和8进行红黑树和链表转化</p>
<p><strong>表示若桶中链表元素超过8时，会自动转化成红黑树</strong>；<strong>若桶中元素小于等于6时，树结构还原成链表形式</strong>。<br>1）原因：<br>　　红黑树的平均查找长度是log(n)，长度为8，<strong>查找长度为log(8)&#x3D;3</strong>，<strong>链表</strong>的平均查找长度为n&#x2F;2，当长度为8时，<strong>平均查找长度为8&#x2F;2&#x3D;4</strong>，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p>
<p>2）选择6和8的原因是：<br>　　<strong>中间有个差值7可以防止链表和树之间频繁的转换</strong>。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>
</li>
</ol>
<h1 id="58-最长回文子串"><a href="#58-最长回文子串" class="headerlink" title="58 最长回文子串"></a>58 最长回文子串</h1><p>注意：边缘满足条件，代表dp[ i ] [ j ] &#x3D;  dp[ i-1 ] [ j+1 ]  （状态转移，true或者false    而不是直接使用dp存回文串进行转移。）</p>
<h1 id="59-sql题（表T-（id-name-salary-city）用SQL实现找到同时符合城市平均工资大于5000，单人工资大于10000的人的名字）"><a href="#59-sql题（表T-（id-name-salary-city）用SQL实现找到同时符合城市平均工资大于5000，单人工资大于10000的人的名字）" class="headerlink" title="59   sql题（表T （id,name,salary,city）用SQL实现找到同时符合城市平均工资大于5000，单人工资大于10000的人的名字）"></a>59   sql题（表T （id,name,salary,city）用SQL实现找到同时符合城市平均工资大于5000，单人工资大于10000的人的名字）</h1><p>所以执行顺序：from—where–group by—having—select—order by</p>
<p>select name from T where salary &gt;10000 group by city having avg(salary) &gt; 5000);</p>
<p>需要注意having和where的用法区别：</p>
<p>1.having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。</p>
<p>2.where肯定在group by 之前，即也在having之前。</p>
<p>3.where后的条件表达式里不允许使用聚合函数，而having可以。</p>
<p>四、当一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是：</p>
<p>1.执行where xx对全表数据做筛选，返回第1个结果集。</p>
<p>2.针对第1个结果集使用group by分组，返回第2个结果集。</p>
<p>4.针对第2个结集执行having xx进行筛选，返回第3个结果集。</p>
<p>3.针对第3个结果集中的每1组数据执行select xx，有几组就执行几次，返回第4个结果集。</p>
<p>5.针对第4个结果集排序。</p>
<h1 id="60-买卖股票"><a href="#60-买卖股票" class="headerlink" title="60 买卖股票"></a>60 买卖股票</h1><ul>
<li>买卖一次</li>
</ul>
<p>假设每天都打算卖出股票，当前能卖出的最多钱数就是当前天之前的最低价格买入时。所以时刻维护[1,n],n表示当前天数，的最小价格m，n依次增大，更新 s[n] -m为更大值时; </p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<ul>
<li>尽可能多次</li>
</ul>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i][j]   i表示一种状态，是持有态，还是空手，空手可以选择买入，持有可以卖出。  那么状态转移过程就是从持有dp[1][j1]到dp[0][j2]+profit</span></span><br><span class="line">        <span class="comment"># 以及从dp[0][j3] 到dp[1][j4]，那么dp[i][j]代表截至到第j天，处于i状态赚到的最大利润。  j是由小到大转化，所以列出循环主体,i一直对跳</span></span><br><span class="line">        </span><br><span class="line">        lenth = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenth)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,lenth):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j-<span class="number">1</span>][<span class="number">1</span>]+prices[j],dp[j-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> i ==<span class="number">1</span>:</span><br><span class="line">                    dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j-<span class="number">1</span>][<span class="number">1</span>],dp[j-<span class="number">1</span>][<span class="number">0</span>]-prices[j])</span><br><span class="line">        <span class="keyword">return</span> dp[lenth-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>特别注意：此处花了两个小时，问题在（<strong>1.数组的初始化问题，2.循环的起始位置问题，n应该从1，因为已经初始化了,3.if else判断条件问题，判断写错，写成循环中不会出现的样子</strong>） 一旦开始写代码，边写边想就会导致想到什么，写出什么，这样逻辑可能答题正确，细节上就会写错东西，提前写好整体思路，每步按照写下的思路写代码，同时检查两者相同性，来验证自己写错在哪儿。   <strong>那么要求写思路时就要把具体的细节给写好。（如上述导致花2h的问题）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j][k],i,j保持原样，j用0,1，表示是否持有，k表示自己还能交易次数。k最开始为2 还是 0。 交易成功一次，k-1. dp[i][j][k].</span></span><br><span class="line"><span class="comment"># 如果k为2  dp[0][1][2],dp[0][0][2],意义不冲突。不会出现意义冲突。每个状态唯一。</span></span><br><span class="line">n = <span class="built_in">len</span>(prices)</span><br><span class="line">  </span><br><span class="line">dp = [[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">  </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -<span class="built_in">float</span>(inf)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -<span class="built_in">float</span>(inf)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = -<span class="built_in">float</span>(inf)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -<span class="built_in">float</span>(inf)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j==<span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>][k] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>][k]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> k== <span class="number">2</span>:</span><br><span class="line">                    dp[i][<span class="number">0</span>][k] = dp[i-<span class="number">1</span>][<span class="number">0</span>][k]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][<span class="number">0</span>][k] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>][k],dp[i-<span class="number">1</span>][<span class="number">1</span>][k+<span class="number">1</span>]+prices[i])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(dp[n-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>],<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>股票四 设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 上一题的扩展版本</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<p><strong>还是同样的问题，编写循环时，判断条件时，初始化时，都可能因为想着一个东西（可能时字母，数字），写的时候写下来，但是实际上需要用的时另一个字母，数字！</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k1: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k1 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k1+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][k1] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][k1] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k1-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][i] = -<span class="built_in">float</span>(inf)</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = -<span class="built_in">float</span>(inf)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k1,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j==<span class="number">1</span>:</span><br><span class="line">                        dp[i][<span class="number">1</span>][k] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>][k]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][k])</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> k== k1:</span><br><span class="line">                            dp[i][<span class="number">0</span>][k] = dp[i-<span class="number">1</span>][<span class="number">0</span>][k]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            dp[i][<span class="number">0</span>][k] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>][k],dp[i-<span class="number">1</span>][<span class="number">1</span>][k+<span class="number">1</span>]+prices[i])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k1+<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">max</span>(dp[n-<span class="number">1</span>][<span class="number">0</span>][i],res)</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>含手续费</p>
</li>
</ul>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a></p>
<p>&#x2F;&#x2F;相比没有手续费，就单纯获得利润时，扣除手续费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    def <span class="title function_">maxProfit</span><span class="params">(self, prices: List[<span class="type">int</span>], fee: <span class="type">int</span>)</span> -&gt; <span class="type">int</span>:</span><br><span class="line">        lenth = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(lenth)</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j in <span class="title function_">range</span><span class="params">(<span class="number">1</span>,lenth)</span>:</span><br><span class="line">            <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">2</span>)</span>:</span><br><span class="line">                <span class="type">if</span> <span class="variable">i</span> <span class="operator">=</span>= <span class="number">0</span>:</span><br><span class="line">                    dp[j][<span class="number">0</span>] = max(dp[j-<span class="number">1</span>][<span class="number">1</span>]+prices[j]-fee,dp[j-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                <span class="type">if</span> <span class="variable">i</span> <span class="operator">=</span>=<span class="number">1</span>:</span><br><span class="line">                    dp[j][<span class="number">1</span>] = max(dp[j-<span class="number">1</span>][<span class="number">1</span>],dp[j-<span class="number">1</span>][<span class="number">0</span>]-prices[j])</span><br><span class="line">        <span class="keyword">return</span> dp[lenth-<span class="number">1</span>][<span class="number">0</span>] </span><br></pre></td></tr></table></figure>



<ul>
<li>含有冷冻期的买卖</li>
</ul>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:   </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># f[i][0]: 手上持有股票的最大收益</span></span><br><span class="line">        <span class="comment"># f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="comment"># f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span></span><br><span class="line">        f = [[-prices[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>]] + [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i])</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]</span><br><span class="line">            f[i][<span class="number">2</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>总结： 重要的是dp枚举状态，能够枚举完所有状态就行。  保证每个状态唯一，不会有歧义。且保证每个状态时最有状态，才能使用dp继续状态转移。</li>
</ul>
<h1 id="61-大端-小端"><a href="#61-大端-小端" class="headerlink" title="61 大端 小端"></a>61 大端 小端</h1><p>所谓的<strong>大端模式</strong>（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p>
<p>以unsigned int value &#x3D; 0x12345678为例</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>小端模式存放内容</th>
<th>大端模式存放内容</th>
</tr>
</thead>
<tbody><tr>
<td>0x4000</td>
<td>0x78</td>
<td>0x12</td>
</tr>
<tr>
<td>0x4001</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x4002</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x4003</td>
<td>0x12</td>
<td>0x78</td>
</tr>
</tbody></table>
<p><strong>小端模式</strong></p>
<p>所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</p>
<h1 id="62-Redis为什么这么快"><a href="#62-Redis为什么这么快" class="headerlink" title="62 Redis为什么这么快"></a>62 Redis为什么这么快</h1><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I&#x2F;O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p>以上几点都比较好理解，下边我们针对多路 I&#x2F;O 复用模型进行简单的探讨：</p>
<h2 id="那么为什么Redis是单线程的"><a href="#那么为什么Redis是单线程的" class="headerlink" title="那么为什么Redis是单线程的"></a>那么为什么Redis是单线程的</h2><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<h1 id="63-复原ip地址"><a href="#63-复原ip地址" class="headerlink" title="63 复原ip地址"></a>63 复原ip地址</h1><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x40;&#x31;&#x2e;&#49;">&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x40;&#x31;&#x2e;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses">https://leetcode-cn.com/problems/restore-ip-addresses</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="comment"># 使用dfs来进行Ip地址的划分，总共划分3次，划分出4段为位置，每一部分需要满足Ip条件（意思对应一个检查函数能过，需要检查的有是否有前置0，以及是否在范围内）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s</span>):</span><br><span class="line">            lenth = <span class="built_in">len</span>(s)</span><br><span class="line">            <span class="keyword">if</span> lenth&gt;=<span class="number">4</span> <span class="keyword">or</span> lenth==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> lenth&gt;<span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(s)&gt;<span class="number">255</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s,temp,counts</span>):</span><br><span class="line">            <span class="comment"># 对ip进行划分。因为一段最多占据三位，所以循环次数选择为3，依次增加下表位数，代表这段慢慢边长。先进行check再进入下一个dfs，最后需要拼接成完整ip，那么需要temp作为参数转入进去。 因为控制划分次数，所以还需要参数指定划分的次数。初始输入为0，每次代表已经划分的次数，那么为3时，直接判断整个s，是否满足要求，满足则添加上，加入统一结果中。</span></span><br><span class="line">            <span class="keyword">if</span> counts ==<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> check(s):</span><br><span class="line">                    temp = temp+s</span><br><span class="line">                    res.append(temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">                temp1 = s[:i]</span><br><span class="line">                <span class="keyword">if</span> check(temp1):</span><br><span class="line">                    dfs(s[i:],temp+temp1+<span class="string">&#x27;.&#x27;</span>,counts+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        dfs(s,<span class="string">&quot;&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="64二层交换机与三层交换机区别详解"><a href="#64二层交换机与三层交换机区别详解" class="headerlink" title="64	二层交换机与三层交换机区别详解"></a>64	二层交换机与三层交换机区别详解</h1><ul>
<li>二层交换技术是发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。</li>
</ul>
<p>二层交换技术发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：</p>
<p>（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；</p>
<p>（2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；</p>
<p>（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；</p>
<p>（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。</p>
<p>不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p>
<ul>
<li>而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。</li>
</ul>
<p>三层交换机就是具有部分路由器功能的交换机。</p>
<p>三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。</p>
<h1 id="65-setNx缺点"><a href="#65-setNx缺点" class="headerlink" title="65 setNx缺点"></a>65 setNx缺点</h1><ol>
<li><strong>setnx和expire不是原子操作</strong>。一旦redis宕机，expire没有设置成功，锁就无法释放。只有一个请求的setnx可以成功，任何一个请求的expire都可以成功。请求比较密集，过期时间一直刷新，导致锁一直有效。</li>
<li><strong>超时后，删除其他线程的锁</strong>。在线程A执行过程中，锁已释放，A还未在执行业务，但是还未删除锁。线程B获取锁执行业务，线程A执行完，A误删B的锁。</li>
<li><strong>多个线程并发获取锁、释放锁。</strong>同一时间有线程A、B在访问同一代码块。</li>
</ol>
<p>对于上面的隐患，Redis已改善。下面，我们针对隐患逐一改善。</p>
<ol>
<li><strong>Redis2.6.12以上版本，可以用set获取锁</strong>。set可以实现setnx和expire，这个是原子操作。</li>
<li><strong>Lua删除锁</strong>。Lua是原子操作。</li>
<li><strong>让获取锁的线程开启一个守护线程，给线程还没执行完，又快要过期的锁续航</strong>。大概是这样的，线程A还没执行完，守护线程每当快过期时，延时expire时间。当线程A执行完，显示关闭守护线程。如果中间宕机，锁超过超时，守护线程也不在了，自动释放锁。</li>
</ol>
<p>当一个客户端获得锁，但是redis的master还没有将这个结果同步到从节点，然后主机宕机，从节点变成主机，那么就可以再一次其他的客户端获取锁。导致重复获取不应该获取的锁。</p>
<h2 id="Redlock是一种算法，Redlock也就是-Redis-Distributed-Lock，可用实现多节点redis的分布式锁。"><a href="#Redlock是一种算法，Redlock也就是-Redis-Distributed-Lock，可用实现多节点redis的分布式锁。" class="headerlink" title="Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点redis的分布式锁。"></a>Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点redis的分布式锁。</h2><p>RedLock官方推荐，Redisson完成了对Redlock算法封装。<br>此种方式具有以下特性：<br>互斥访问：即永远只有一个 client 能拿到锁<br>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。<br>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</p>
<p>RedLock原理（了解）</p>
<ul>
<li><p>获取当前Unix时间，以毫秒为单位。</p>
</li>
<li><p>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p>
</li>
<li><p>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</p>
</li>
<li><p>如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</p>
</li>
</ul>
<h1 id="66-Reetrantlock底层加锁-以及-synchrnized底层实现原理"><a href="#66-Reetrantlock底层加锁-以及-synchrnized底层实现原理" class="headerlink" title="66  Reetrantlock底层加锁  以及  synchrnized底层实现原理"></a>66  Reetrantlock底层加锁  以及  synchrnized底层实现原理</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q610376681/article/details/100763607">https://blog.csdn.net/q610376681/article/details/100763607</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43383307/article/details/119712691">https://blog.csdn.net/qq_43383307/article/details/119712691</a></p>
<p>关键字锁的底层的是monitor锁，在在 JVM 中，是由 ObjectMonitor 实现的。</p>
<p>monitor锁的结构<img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204162938577.png" alt="image-20211204162938577"></p>
<h1 id="67-mysql与redis的数据一致性的问题"><a href="#67-mysql与redis的数据一致性的问题" class="headerlink" title="67 mysql与redis的数据一致性的问题"></a>67 mysql与redis的数据一致性的问题</h1><h6 id="对于写入："><a href="#对于写入：" class="headerlink" title="对于写入："></a>对于写入：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正确的操作是，先写入mysql，再同步写人redis</span><br></pre></td></tr></table></figure>

<h6 id="对于更新："><a href="#对于更新：" class="headerlink" title="对于更新："></a>对于更新：</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  正确的操作是，先更新数据库，再更新redis。</span><br><span class="line">  有部分人认为，假如redis更新失败，那怎么办，我问，为什么会失败，他说可能是因为服务器问题或者网络原因。提出的解决方案是，先删除缓存，再更新到mysql,最后异步更新到缓存。还有什么听不懂的jvm队列之类的。</span><br><span class="line">  这种先删除方案，看似很优雅，很合理，但却是本末倒置。</span><br><span class="line">  首先，要明白redis在项目中是干什么的？作为缓存。其次，谁才是最主要的？mysql。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>   第一点：服务器问题，那么怎么保证删除方案的第一步能成功执行？若第一步都操作失败了，返回false，该如何处理？如果不通过返回状态值去判断，那么又怎么确保是删除方案？后面的异步更新又怎么保证？如果失败，大量请求又将落地到mysql，redis形同虚设。所以说，要是服务器问题，应该去修复，或者建立redis集群保证高可用。</span><br><span class="line"><span class="bullet">2.</span>   第二点：网络原因，他们认为，在mysql更新后，若是redis有网络延迟，此时用户读取到的数据不是最新的，引发数据一致性问题。那么假设redis有网络延迟的现象，首先，删除方案的第一步将会是系统性能问题的潜在点，另外当删除键后，用户访问直接落地到mysql数据库，而且mysql的执行速度远慢于redis，此时用户访问的还是旧数据。</span><br><span class="line">所以当我们把redis作为一个缓存使用的时候，首先应该明白redis的位置，其次对于数据一致性，要根据业务场景，设置合理的过期时间来保证，不要假设一会儿连redis集群都不可用了，redis又有什么网络原因了，想太多，没屌用，因为我们不可能同时保证数据一致性，服务可用，网络延迟（CAP）。</span><br></pre></td></tr></table></figure>

<h1 id="68-三个线程交替打印数字。（使用condition数组作为参数传入线程类）"><a href="#68-三个线程交替打印数字。（使用condition数组作为参数传入线程类）" class="headerlink" title="68 三个线程交替打印数字。（使用condition数组作为参数传入线程类）"></a>68 三个线程交替打印数字。（使用condition数组作为参数传入线程类）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumber</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个线程共享这一个sequence数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEQUENCE_END</span> <span class="operator">=</span><span class="number">75</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition[] conditions = &#123;lock.newCondition(),lock.newCondition(),lock.newCondition()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PrintNumber</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.setName(<span class="string">&quot;线程：&quot;</span> + (id + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (sequence &lt; SEQUENCE_END) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//对序号取模,如果不等于当前线程的id,则先唤醒其他线程,然后当前线程进入等待状态</span></span><br><span class="line">                <span class="keyword">while</span> ((sequence/<span class="number">5</span>) % conditions.length != id) &#123;</span><br><span class="line">                    conditions[(id + <span class="number">1</span>) % conditions.length].signal();</span><br><span class="line">                    conditions[id].await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + sequence++);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒当前线程的下一个线程</span></span><br><span class="line">                conditions[(id + <span class="number">1</span>) % conditions.length].signal();</span><br><span class="line">                <span class="comment">//当前线程进入等待状态</span></span><br><span class="line">                conditions[id].await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将释放锁的操作放到finally代码块中,保证锁一定会释放</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字打印完毕,线程结束前唤醒其余的线程,让其他线程也可以结束</span></span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        conditions[(id + <span class="number">1</span>) % conditions.length].signal();</span><br><span class="line">        conditions[(id + <span class="number">2</span>) % conditions.length].signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//        ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//        Condition[] conditions = new Condition[threadCount];</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; threadCount; i++) &#123;</span></span><br><span class="line"><span class="comment">//            conditions[i] = lock.newCondition();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        PrintNumber[] printNumbers = <span class="keyword">new</span> <span class="title class_">PrintNumber</span>[threadCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            printNumbers[i] = <span class="keyword">new</span> <span class="title class_">PrintNumber</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PrintNumber printNumber : printNumbers) &#123;</span><br><span class="line">            printNumber.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的交替方式有：唤醒所有线程，竞争锁，进入判断条件是否wait释放锁，交给其他线程。</p>
<p>更细粒度的控制是，唤醒指定线程，自身沉眠。</p>
<h2 id="依次打印奇偶数-if版本"><a href="#依次打印奇偶数-if版本" class="headerlink" title="依次打印奇偶数(if版本)"></a>依次打印奇偶数(if版本)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Num</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Num</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">PrintEven</span> <span class="variable">printEven</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintEven</span>(num,o);</span><br><span class="line">        <span class="type">PrintOdd</span> <span class="variable">printOdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintOdd</span>(num, o);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printEven);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printOdd);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintOdd</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Num num;</span><br><span class="line">        <span class="keyword">public</span> Object lock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PrintOdd</span><span class="params">(Num num,Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num.n&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ((num.n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;odd:&quot;</span>+num.n);</span><br><span class="line">                        num.n++;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintEven</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Num num;</span><br><span class="line">        <span class="keyword">public</span> Object lock;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PrintEven</span><span class="params">(Num num,Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num.n&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ((num.n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;even:&quot;</span>+num.n);</span><br><span class="line">                        num.n++;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Num</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Num</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依次打印奇偶数-while版本"><a href="#依次打印奇偶数-while版本" class="headerlink" title="依次打印奇偶数(while版本)"></a>依次打印奇偶数(while版本)</h2><p>有问题，会导致输出一个100.因为一开始就卡住了，后面唤醒没有判断外层while条件，直接输出，会导致唤醒时候已经不符合条件但是依然运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Num</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Num</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">PrintEven</span> <span class="variable">printEven</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintEven</span>(num,o);</span><br><span class="line">        <span class="type">PrintOdd</span> <span class="variable">printOdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintOdd</span>(num, o);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printEven);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printOdd);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintOdd</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Num num;</span><br><span class="line">        <span class="keyword">public</span> Object lock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PrintOdd</span><span class="params">(Num num,Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num.n&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> ((num.n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;odd&quot;</span>+num.n++);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintEven</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Num num;</span><br><span class="line">        <span class="keyword">public</span> Object lock;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PrintEven</span><span class="params">(Num num,Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num.n&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> ((num.n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;even&quot;</span>+num.n++);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Num</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Num</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="69-关于wait-notify-notifyall-synchronized"><a href="#69-关于wait-notify-notifyall-synchronized" class="headerlink" title="69 关于wait  notify,notifyall, synchronized"></a>69 关于wait  notify,notifyall, synchronized</h1><p><strong>调用notify&#x2F;notifyAll后等待中的线程会立刻唤醒吗？</strong><br>hotspot真正的实现是退出同步代码块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。<br>这个也可从jdk源代码的objectMonitor类objectMonitor::notify方法中看到.在调用notify时的默认策略是Policy &#x3D;&#x3D; 2（这个值是源码中的初值，可以通过-XX:SyncKnobs来设置）</p>
<p>其实对于Policy(1、2、3、4)都是将objectMonitor的ObjectWaiter集合中取出一个等待线程，放入到_EntryList（blocked线程集合，可以参与下次抢锁），只是放入_EntryList的策略不一样，体现为唤醒wait线程的规则不一样。</p>
<p>对于默认策略notify在将一个等待线程放入阻塞线程集合之后就退出，因为同步块还没有执行完monitorexit，锁其实还未释放，所以在打印出“thread1 is exit synchronized!”的时候，thread2线程还是blocked状态（因为thread1还没有退出同步块）。</p>
<p>这里可以发现，对于不在Policy中的情况，会直接将一个ObjectWaiter进行unpark唤醒操作，但是被唤醒的线程是否立即获取到了锁呢？答案是否定的。</p>
<p><strong>如果在同步块中调用wait，会释放锁，但是当重新获得锁的时候会从释放锁的位置继续运行，而不是从同步代码块的最开始运行。</strong></p>
<h2 id="什么是监视器-monitor"><a href="#什么是监视器-monitor" class="headerlink" title="什么是监视器(monitor)"></a>什么是监视器(monitor)</h2><p>Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue)组成.<br>对于一个对象的方法， 如果没有synchonized关键字， 该方法可以被任意数量的线程，在任意时刻调用。<br>对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/format,png" alt="img"></p>
<p>进入区(Entry Set): 表示线程通过 synchronized要求获得对象锁，如果获取到了，则成为拥有者，如果没有获取到在在进入区等待，直到其他线程释放锁之后再去竞争(谁获取到则根据)</p>
<p>拥有者(Owner): 表示线程获取到了对象锁，可以执行synchronized包围的代码了</p>
<p>等待区(Wait Set): 表示线程调用了wait方法,此时释放了持有的对象锁，等待被唤醒(谁被唤醒取得监视器锁由jvm决定)</p>
<h1 id="70-mysql-和redis一致性的问题"><a href="#70-mysql-和redis一致性的问题" class="headerlink" title="70 mysql 和redis一致性的问题"></a>70 mysql 和redis一致性的问题</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhongxiangbo/article/details/85494154">https://blog.csdn.net/zhongxiangbo/article/details/85494154</a></p>
<h3 id="五、先删缓存，再更新数据库"><a href="#五、先删缓存，再更新数据库" class="headerlink" title="五、先删缓存，再更新数据库"></a><strong>五、先删缓存，再更新数据库</strong></h3><p>该方案会导致不一致的原因是：同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存；</p>
<p>（2）请求B查询发现缓存不存在；</p>
<p>（3）请求B去数据库查询得到旧值；</p>
<p>（4）请求B将旧值写入缓存；</p>
<p>（5）请求A将新值写入数据库；</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>那么，<strong>如何解决呢？<strong><strong>采用</strong></strong>延时双删策略</strong></p>
<p>转化为中文描述就是：</p>
<p>（1）先淘汰缓存；</p>
<p>（2）再写数据库（这两步和原来一样）；</p>
<p>（3）休眠1秒，再次淘汰缓存；</p>
<h3 id="六、先更新数据库，再删缓存"><a href="#六、先更新数据库，再删缓存" class="headerlink" title="六、先更新数据库，再删缓存"></a><strong>六、先更新数据库，再删缓存</strong></h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出：</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中；</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回；</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效；</li>
</ul>
<p>另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。</p>
<p><strong>6.1、这种情况不存在并发问题么？</strong></p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生：</p>
<p>（1）缓存刚好失效；</p>
<p>（2）请求A查询数据库，得一个旧值；</p>
<p>（3）请求B将新值写入数据库；</p>
<p>（4）请求B删除缓存；</p>
<p>（5）请求A将查到的旧值写入缓存；</p>
<p>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p>**<em>*6.2、*<em>然而，发生这种情况的概率又有多少呢？</em></em></p>
<p>发生上述情况有一个先天性条件，就是6.1中步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p>
<h2 id="Cache-Aside-Pattern-删缓存失败的重试方案："><a href="#Cache-Aside-Pattern-删缓存失败的重试方案：" class="headerlink" title="Cache-Aside Pattern 删缓存失败的重试方案："></a>Cache-Aside Pattern 删缓存失败的重试方案：</h2><p>流程如下图所示：</p>
<p>（1）更新数据库数据；</p>
<p>（2）数据库会将操作信息写入binlog日志当中；</p>
<p>（3）订阅程序提取出所需要的数据以及key；</p>
<p>（4）另起一段非业务代码，获得该信息；</p>
<p>（5）尝试删除缓存操作，发现删除失败；</p>
<p>（6）将这些信息发送至消息队列；</p>
<p>（7）重新从消息队列中获得该数据，重试操作；</p>
<p>备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache-Aside Pattern"></a>Cache-Aside Pattern</h3><p>流程：</p>
<ol>
<li><p>首先从缓存中查询数据，如果缓存命中则直接返回。</p>
</li>
<li><p>缓存未命中，则去数据库中读取。</p>
</li>
<li><p>将从数据库中读取的结果的副本放入到缓存中，并返回。</p>
</li>
<li><p>写操作</p>
<p>流程：</p>
<ol>
<li>首先更新数据库。</li>
<li>然后<strong>删除缓存中的数据</strong>。</li>
</ol>
</li>
</ol>
<p>为什么是删除缓存，而不是更新缓存？主要基于以下两点考量：</p>
<ul>
<li><p>数据更新后，可能不会有大量的访问。如果每次更新数据后都更新缓存，可能会造成大量不必要的计算开销。因此，这里采用一种lazy的思想，每次更新数据时仅仅是删除缓存，只有在真正读请求到来时才进行缓存的更新。</p>
</li>
<li><p>在高并发场景下，并发地更新缓存可能会造成缓存可数据库中数据不一致的问题。<br>写操作的流程十分关键！一定要先更新数据库，再删除缓存。如果先删除缓存，就会存在一个很小的窗口期，使得客户端查询时无法命中缓存，而去读数据库，然而此时数据库中的数据还未更新，就会从数据库中加载到旧的数据并放入缓存中，最终导致缓存数据被污染。</p>
</li>
</ul>
<p><strong>缓存的过期策略</strong></p>
<p>许多缓存系统都会对缓存数据设置一定的过期策略。使用Cache-Aside Pattern时，一定要合理地设置过期策略。如果过期时间太短，可能导致大量请求涌入数据库。相反，如果过期时间太长，有可能导致缓存中数据的大量失效。使用缓存的一个原则，就是尽量缓存那些相对静态的、频繁被读取的数据。</p>
<p><strong>Cache-Aside Pattern并无法完全保证数据库和缓存的数据一致性。</strong>当某条数据被修改时，在数据库中会立即更新，但是缓存中的更新会在下次读取数据时才会发生，</p>
<h1 id="71-JVM"><a href="#71-JVM" class="headerlink" title="71 JVM"></a>71 JVM</h1><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204183337019.png" alt="image-20211204183337019"></p>
<h1 id="72-计网"><a href="#72-计网" class="headerlink" title="72 计网"></a>72 计网</h1><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204190742189.png" alt="image-20211204190742189"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204192201427.png" alt="image-20211204192201427"></p>
<p>快恢复：cwmd &#x3D; ssthresh + 确认收到数据包的个数</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204215841989.png" alt="image-20211204215841989"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204221001146.png" alt="image-20211204221001146"></p>
<h1 id="73-操作系统"><a href="#73-操作系统" class="headerlink" title="73  操作系统"></a>73  操作系统</h1><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204223155099.png" alt="image-20211204223155099"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204224707733.png" alt="image-20211204224707733"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211204231255806.png" alt="image-20211204231255806"></p>
<h1 id="74-自定义springboot注解（aop实现）"><a href="#74-自定义springboot注解（aop实现）" class="headerlink" title="74 自定义springboot注解（aop实现）"></a>74 自定义springboot注解（aop实现）</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/oldboyooxx/p/9245593.html">使用IDEA创建SpringBoot自定义注解 - oldboyooxx - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/153317556">https://zhuanlan.zhihu.com/p/153317556</a></p>
<h3 id="表达式标签（10种）"><a href="#表达式标签（10种）" class="headerlink" title="表达式标签（10种）"></a>表达式标签（10种）</h3><ul>
<li>execution：用于匹配方法执行的连接点</li>
<li>within：用于匹配指定类型内的方法执行</li>
<li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也* 类型匹配</li>
<li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配</li>
<li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法</li>
<li>@within：用于匹配所以持有指定注解类型内的方法</li>
<li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解</li>
<li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行</li>
<li>@annotation：用于匹配当前执行方法持有指定注解的方法</li>
<li>bean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法<br>10种标签组成了12种用法</li>
<li></li>
</ul>
<p>重要点： @Aspect注解 。    @Pointcut（） 配合 @annotation(注解类位置)  。      private void <strong>oldboy</strong>() { }  使得 后续@Around() 里面使用的都是  “<strong>oldboy（）</strong> ”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> vip.oldboy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by peng on 18/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldBoyAspect</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(vip.oldboy.OldBoy)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">oldboy</span><span class="params">()</span> &#123; &#125;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制一个环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;oldboy()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">advice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Around Begin&quot;</span>);</span><br><span class="line">        joinPoint.proceed();<span class="comment">//执行到这里开始走进来的方法体（必须声明）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Around End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当想获得注解里面的属性，可以直接注入改注解</span></span><br><span class="line">    <span class="comment">//方法可以带参数，可以同时设置多个方法用&amp;&amp;</span></span><br><span class="line">    <span class="meta">@Before(&quot;oldboy()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@After(&quot;oldboy()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="75-jdk1-8默认垃圾回收器"><a href="#75-jdk1-8默认垃圾回收器" class="headerlink" title="75 jdk1.8默认垃圾回收器"></a>75 jdk1.8默认垃圾回收器</h1><p>Parallel Scanvenge  为年轻，老年为Parallel Old</p>
<h1 id="76-保证消息队列消息一定被消费且不被多次消费"><a href="#76-保证消息队列消息一定被消费且不被多次消费" class="headerlink" title="76 保证消息队列消息一定被消费且不被多次消费"></a>76 保证消息队列消息一定被消费且不被多次消费</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1664494">https://cloud.tencent.com/developer/article/1664494</a></p>
<p>一定消费： 失败的地方可能是3中，生产者，消息队列，消费者。</p>
<ol>
<li><p>生产者部分，如果发送消息失败（没收到ack） 选择重发2，3次。</p>
</li>
<li><p>如果在消息队列部分，那么选择持久化（持久化还是可能丢失，那么集群用其他部分存储，其他部分存储完毕返回成功，整个消息队列才认为存储成功消息）。</p>
</li>
<li><p>如果在消费者部分，那么就是一定要消费完毕才更改状态，当消费过程中发生了消费失败的问题，因为状态没更新，所以认为没被成功消费</p>
</li>
</ol>
<p>不被多次消费：</p>
<ul>
<li>生产者 端有  (生产者id,上次最后发送消息id)，新消息对比这个信息，以此确认是否重复。</li>
<li>消费者端，要通过唯一id确认自己是否消费。 如果持久化消费结果因为宕机没有持久化成功，要采用事务，就可以了。 如果不愿意事务，那就一开始生产消息时，将目标更新的数据库数据行加一个版本列，版本信息也放入消息中，用于cas操作，当消费数据时，只有数据库中版本与消息的版本对应才能更新成功。如果已经消费了，那消息的版本和数据库对不上，更新失败，避免重复消费。</li>
</ul>
<h1 id="77-ES"><a href="#77-ES" class="headerlink" title="77 ES"></a>77 ES</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、exist query:查询字段不为null的文档。查询字段address 不为null的数据</span></span><br><span class="line">QueryBuilders.existsQuery(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、missing query:返回没有字段或值为null或没有值的文档。</span></span><br><span class="line">QueryBuilders.missingQuery(<span class="string">&quot;accountGuid&quot;</span>)</span><br><span class="line"><span class="comment">//java client标记该方法已经过时，推荐用exist代替 如下</span></span><br><span class="line">QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery(<span class="string">&quot;accountGuid&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//12、布尔查询</span></span><br><span class="line">QueryBuilders.boolQuery()</span><br><span class="line">QueryBuilders.boolQuery().must();<span class="comment">//文档必须完全匹配条件，相当于and</span></span><br><span class="line">QueryBuilders.boolQuery().mustNot();<span class="comment">//文档必须不匹配条件，相当于not</span></span><br><span class="line">QueryBuilders.boolQuery().should();<span class="comment">//至少满足一个条件，这个文档就符合should，相当于or</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为空搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> search       搜索条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryBuilder 查询器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isNullSearch</span><span class="params">(CrmSearchBO.Search search, BoolQueryBuilder queryBuilder)</span> &#123;</span><br><span class="line">        <span class="type">FieldEnum</span> <span class="variable">fieldEnum</span> <span class="operator">=</span> FieldEnum.parse(search.getFormType());</span><br><span class="line">        <span class="keyword">if</span> (Arrays.asList(FieldEnum.DATETIME, FieldEnum.DATE, FieldEnum.NUMBER, FieldEnum.FLOATNUMBER).contains(fieldEnum)) &#123;</span><br><span class="line">            queryBuilder.mustNot(QueryBuilders.existsQuery(search.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BoolQueryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">            builder.should(QueryBuilders.termQuery(search.getName(), <span class="string">&quot;&quot;</span>));</span><br><span class="line">            builder.should(QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery(search.getName())));</span><br><span class="line">            queryBuilder.filter(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不为空搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> search       搜索条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryBuilder 查询器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isNotNullSearch</span><span class="params">(CrmSearchBO.Search search, BoolQueryBuilder queryBuilder)</span> &#123;</span><br><span class="line">        queryBuilder.filter(QueryBuilders.existsQuery(search.getName()));</span><br><span class="line">        <span class="type">FieldEnum</span> <span class="variable">fieldEnum</span> <span class="operator">=</span> FieldEnum.parse(search.getFormType());</span><br><span class="line">        <span class="keyword">if</span> (!Arrays.asList(FieldEnum.DATETIME, FieldEnum.DATE, FieldEnum.NUMBER, FieldEnum.FLOATNUMBER).contains(fieldEnum)) &#123;</span><br><span class="line">            queryBuilder.mustNot(QueryBuilders.termQuery(search.getName(), <span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addField</span><span class="params">(RestHighLevelClient client, CrmFieldConfig crmField, Integer fieldType)</span> &#123;</span><br><span class="line">        <span class="comment">//添加Mapping</span></span><br><span class="line">        <span class="type">CrmEnum</span> <span class="variable">crmEnum</span> <span class="operator">=</span> CrmEnum.parse(crmField.getLabel());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            child.put(StrUtil.toCamelCase(crmField.getFieldName()), parseType(fieldType));</span><br><span class="line">            object.put(<span class="string">&quot;properties&quot;</span>, child);</span><br><span class="line">            <span class="type">PutMappingRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutMappingRequest</span>(crmEnum.getIndex());</span><br><span class="line">            request.source(object);</span><br><span class="line">            client.indices().putMapping(request, RequestOptions.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;新增字段错误&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CrmException</span>(SystemCodeEnum.SYSTEM_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ES与mysql同步"><a href="#ES与mysql同步" class="headerlink" title="ES与mysql同步"></a>ES与mysql同步</h2><ol>
<li><strong>目前比较好的一个方案是 binlog-MQ-ESWriter-ES</strong></li>
</ol>
<p>使用canel这种binlog监听插件，监听到数据库数据的变化，作为producer发给MQ；</p>
<p>实现ESWriter进程，消费MQ并写入ES</p>
<p>实现上，canel相对好上手。最需要注意的就是ESWriter这个进程在消费的时候如何设置ack，并避免异常场景。</p>
<ol>
<li>方法一：**.双写模式**<br>1、首先添加商品入数据库，添加商品成功后，商品入ES，<br>2、若入ES失败，将失败的商品ID放入redis（或MQ），且失败的商品ID入log文件（若出现redis挂掉，可从日志中取异常商品ID然后再入ES）<br>3、指定定时task任务每秒刷新一下redis缓存，若是从缓存中取到商品ID，则根据商品ID从数据库中获取商品数据然后入ES</li>
</ol>
<h1 id="78-抽象类和普通类的区别-与接口的差别"><a href="#78-抽象类和普通类的区别-与接口的差别" class="headerlink" title="78 抽象类和普通类的区别 与接口的差别"></a>78 抽象类和普通类的区别 与接口的差别</h1><ul>
<li>抽象类不能被实例化</li>
<li>抽象类可以有抽象方法，抽象方法只需申明，无需实现</li>
<li>含有抽象方法的类必须申明为抽象类</li>
<li>抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</li>
<li>抽象方法不能被声明为静态</li>
<li>抽象方法不能用private修饰</li>
<li>抽象方法不能用final修饰</li>
</ul>
<p>1、接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。<br> 2、单继承，多实现。接口可以实现多个，只能继承一个抽象类。<br> 3、接口强调的是功能，抽象类强调的是所属关系。<br> 4、接口中的所有成员变量 为public static final， 静态不可修改，当然必须初始化。接口中的所有方法都是public abstract 公开抽象的。而且不能有构造方法。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有。</p>
<p>① 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
<p>② 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</p>
<h1 id="79-数组与List集合之间的相互转换"><a href="#79-数组与List集合之间的相互转换" class="headerlink" title="79  数组与List集合之间的相互转换]"></a>79  数组与List集合之间的相互转换]</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Arrays.asList(arr);</span><br><span class="line">    Object[] objects = ls.toArray();</span><br></pre></td></tr></table></figure>

<h1 id="80-什么是页缓存（Page-Cache）（转载）"><a href="#80-什么是页缓存（Page-Cache）（转载）" class="headerlink" title="80 什么是页缓存（Page Cache）（转载）"></a>80 什么是页缓存（Page Cache）（转载）</h1><h2 id="什么是页缓存"><a href="#什么是页缓存" class="headerlink" title="什么是页缓存"></a>什么是页缓存</h2><p>由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux">Linux</a> 内核使用<strong>页缓存（Page Cache）</strong>机制来对文件中的数据进行缓存</p>
<p>为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为<strong>页缓存</strong>）与文件中的数据块进行绑定。如下图所示：</p>
<h1 id="81-什么是红黑树"><a href="#81-什么是红黑树" class="headerlink" title="81 什么是红黑树"></a>81 什么是红黑树</h1><p><strong>红黑树</strong></p>
<p>红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性：</p>
<ol>
<li><p>节点是红色或者黑色</p>
</li>
<li><p>根节点是黑色</p>
</li>
<li><p>每个叶子的节点都是黑色的空节点（NULL）</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色的。</p>
</li>
<li><p>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</p>
</li>
</ol>
<h1 id="82-怎么实现一个协程"><a href="#82-怎么实现一个协程" class="headerlink" title="82 怎么实现一个协程"></a>82 怎么实现一个协程</h1><p>协程又叫用户级轻量线程，它不需要像线程那样占用大量系统资源，但却能像线程那样并发地运行多个函数，它是怎样实现的呢？让我们先搞清楚它的实现细节，然后再动手自己做一个。</p>
<p>在CPU中有个<strong>IP寄存器</strong>，它的值决定了下一条将要执行的指令地址，出于安全起见，通常我们不能手动设置它的值，但是有一些指令，如CALL和RET能够间接的改变它。比如<strong>CALL指令将函数地址赋值给IP寄存器</strong>，使CPU接下来跳到函数中执行，在函数执行完成之后，<strong>RET指令从堆栈中弹出CALL之后的那条指令</strong>，并且赋值给IP寄存器，那么函数返回后就能按原来的流程继续执行。</p>
<p>还有两个比较重要的寄存器：<strong>BP和SP</strong>，他们控制着当前函数的局部变量，以及所有的子函数调用。<strong>BP指向当前函数的栈顶，在函数运行期间是固定的，SP指向函数的栈底</strong>，它们之间的内存区域标识当前函数的执行状态。如下图所示：</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/webp" alt="img"></p>
<p>如果我们能想到办法，通过某种机制保存函数这时候的状态，是不是可以在多个函数之间切换呢？</p>
<p>在c语言库函数中，真有这样的函数：setjmp()和longjmp()，setjmp()负责保存当前函数的执行状态，longjmp()可以在其它函数中随时返回之前的现场，是不是很神奇</p>
<p>如果有很多函数，我们为每个函数都调用setjmp()保存一个现场，是不是可以随意在多个函数之间切换呢？答案是否定的，因为使用setjmp()和longjmp()有个约束，只能跳一次，而且只能从栈的深处向浅处跳！为什么呢？因为正常的进程栈栈，无论有多少个函数，全部共用一块连续的内存区域，一旦发生跳转，跳转之间的区域全部丢失，这将导致堆栈被破坏，再也跳不回来了！</p>
<p>有朋友会提出问题：可以为每个函数独立设置堆栈吗？答案是可以！但是c函数库的setjmp()和longjmp()不行，我们必须自己动手写。</p>
<p>在setjmp中，只保存了BP和SP这两个寄存器，以及从堆栈中取出函数的返回地址（即原本应该执行的下一条语句！），并且设置返回值为0，加以区别。</p>
<p>在longjmp中，将入参的BP、SP、函数返回地址加以恢复，实际上是通过破坏堆栈的方式欺骗了RET指令！让RET误以为函数正常返回，实际上却切换到了别的函数中。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/95659fef6615">https://www.jianshu.com/p/95659fef6615</a></p>
<h1 id="83-mybaits里的-、-、-的区别"><a href="#83-mybaits里的-、-、-的区别" class="headerlink" title="83 mybaits里的$、#、{}的区别"></a>83 mybaits里的$、#、{}的区别</h1><p>（1）#{} 占位符</p>
<p>（2）${} 拼接符 </p>
<p>1）#{} 为参数占位符 ?，即sql 预编译</p>
<p>2）${} 为字符串替换，即 sql 拼接<br>1）变量替换后，#{} 对应的变量自动加上单引号 ‘’</p>
<p>2）变量替换后，${} 对应的变量不会加上单引号 ‘’</p>
<p>1）#{} 能防止sql 注入</p>
<p>2）${} 不能防止sql 注入</p>
<h1 id="84-变量定义合法吗-int-i-x3D-5-1-j-x3D-52"><a href="#84-变量定义合法吗-int-i-x3D-5-1-j-x3D-52" class="headerlink" title="84 变量定义合法吗 ( int i &#x3D; 5___1, j &#x3D; 52__"></a>84 变量定义合法吗 ( int i &#x3D; 5___1, j &#x3D; 52__</h1><p>第一个合法，第二个不合法。 所以__不能放在开头或者结尾。</p>
<h1 id="设计模式-面向对象-有六大原则"><a href="#设计模式-面向对象-有六大原则" class="headerlink" title="设计模式(面向对象)有六大原则"></a>设计模式(面向对象)有六大原则</h1><h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.<strong>开闭原则</strong></h2><p><strong>1.概念：</strong> </p>
<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。</p>
<h2 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2.里氏代换原则"></a>2.<strong>里氏代换原则</strong></h2><p><strong>1.概述：</strong> 派生类(子类)对象能够替换其基类(父类)对象被调用</p>
<h2 id="3依赖倒转原则"><a href="#3依赖倒转原则" class="headerlink" title="3依赖倒转原则"></a>3<strong>依赖倒转原则</strong></h2><p><strong>1.概念：</strong> </p>
<p>依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<h2 id="4接口隔离原则"><a href="#4接口隔离原则" class="headerlink" title="4接口隔离原则"></a>4<strong>接口隔离原则</strong></h2><p><strong>1.概念：</strong> </p>
<p>客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上</p>
<h2 id="5合成-x2F-聚合复用原则"><a href="#5合成-x2F-聚合复用原则" class="headerlink" title="5合成&#x2F;聚合复用原则"></a>5<strong>合成&#x2F;聚合复用原则</strong></h2><p>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）经常又叫做合成复用原则。合成&#x2F;聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。它的设计原则是：要尽量使用合成&#x2F;聚合，尽量不要使用继承。</p>
<h2 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6 迪米特法则"></a>6 <strong>迪米特法则</strong></h2><p><strong>1.概念：</strong> </p>
<p>一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。</p>
<h1 id="86-模板方法"><a href="#86-模板方法" class="headerlink" title="86 模板方法"></a>86 模板方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WriteArticle</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">theLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">actualContent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeAnCompleteArticle</span><span class="params">()</span> &#123;</span><br><span class="line">        introduction();</span><br><span class="line">        actualContent();</span><br><span class="line">        theLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java3yWriteArticle</span> <span class="keyword">extends</span> <span class="title class_">WriteArticle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现基本方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;只有充钱才能变强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现基本方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">theLast</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关注我的公众号：Java3y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现基本方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">actualContent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大家好，我是3y，今天来给大家分享我写的模板方法模式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>基本方法</strong>：在子类实现，并且在模板方法中被调用</li>
<li><strong>模板方法</strong>：定义了一个框架，<strong>实现对基本方法的调用，完成固定的逻辑</strong>。</li>
</ul>
<h2 id="1-4模板方法的优缺点"><a href="#1-4模板方法的优缺点" class="headerlink" title="1.4模板方法的优缺点"></a>1.4模板方法的优缺点</h2><p>优点：</p>
<ul>
<li><strong>封装不变的部分，扩展可变的部分</strong>。把认为是不变的部分的算法封装到父类，可变部分的交由子类来实现！</li>
<li>提取公共部分的代码，行为由父类控制，子类实现！</li>
</ul>
<p>缺点：</p>
<ul>
<li>抽象类定义了部分抽象方法，这些抽象的方法由子类来实现，子类执行的结果影响了父类的结果(<strong>子类对父类产生了影响</strong>)，会带来阅读代码的难度！</li>
</ul>
<p>我们可以看一下AQS定义的<code>acquire()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>acquire()</code>相当于模板方法，<code>tryAcquire(arg)</code>相当于基本方法。</p>
<h1 id="87-exception-和-eror区别"><a href="#87-exception-和-eror区别" class="headerlink" title="87  exception 和 eror区别"></a>87  exception 和 eror区别</h1><p>Exception和Error体现了java平台设计者对不同异常情况的分类，Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理。uuu</p>
<p>Error是指正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常状态，不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</p>
<h1 id="88-僵尸进程"><a href="#88-僵尸进程" class="headerlink" title="88 僵尸进程"></a>88 僵尸进程</h1><p>所以，当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。</p>
<p>而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。</p>
<p>他需要他的父进程来为他收尸，如果他的父进程没有安装SIGCHLD信号处理函数调用wait 或 waitpid() 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程会自动接手这个子进程，为他收尸，他还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么有时候会有很多的僵尸进程。</p>
<p><strong>如何处理僵尸进程</strong></p>
<p>僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过 wait() 来避免僵尸进程的产生。</p>
<p>当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。</p>
<h1 id="89-查看内存占用率的Linux指令？-free"><a href="#89-查看内存占用率的Linux指令？-free" class="headerlink" title="89 查看内存占用率的Linux指令？ free"></a>89 查看内存占用率的Linux指令？ free</h1><h1 id="90-LRU-cache"><a href="#90-LRU-cache" class="headerlink" title="90 LRU cache"></a>90 LRU cache</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</span><br><span class="line"></span><br><span class="line">哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</span><br><span class="line"></span><br><span class="line">这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(<span class="number">1</span>)O(<span class="number">1</span>) 的时间内完成 get 或者 put 操作。具体的方法如下：</span><br><span class="line"></span><br><span class="line">对于 get 操作，首先判断 key 是否存在：</span><br><span class="line"></span><br><span class="line">如果 key 不存在，则返回 -<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</span><br><span class="line"></span><br><span class="line">对于 put 操作，首先判断 key 是否存在：</span><br><span class="line"></span><br><span class="line">如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</span><br><span class="line"></span><br><span class="line">如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</span><br><span class="line"></span><br><span class="line">上述各项操作中，访问哈希表的时间复杂度为 O(<span class="number">1</span>)O(<span class="number">1</span>)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(<span class="number">1</span>)O(<span class="number">1</span>)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(<span class="number">1</span>)O(<span class="number">1</span>) 时间内完成。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="91-RSA加密算法的缺点"><a href="#91-RSA加密算法的缺点" class="headerlink" title="91 RSA加密算法的缺点"></a>91 RSA加密算法的缺点</h1><p>RSA 算法的缺陷<br>使⽤ RSA 密钥协商算法的最⼤问题是不⽀持前向保密。因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之<br>⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏<br>了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。</p>
<p>以及 相比ECDHE ，自己握手四次，ECDHE握手三次。</p>
<h1 id="92-信号"><a href="#92-信号" class="headerlink" title="92 信号"></a>92 信号</h1><p>（1）信号的概念</p>
<p>分为硬件和软件产生的信号</p>
<pre><code>       信号的特点：简单，不能携带大量信息，满足某种特定条件才触发。

       信号的机制；“软中断”，通过软件方式实现，具有很强的延时性。每个进程收到的信号，都由内核负责发送，内核处理。
</code></pre>
<p>​    		<br>​    		<br>​<br>​           信号的产生：1）按键产生（ctrl+c,ctrl+z,ctrl+\）  ：硬件<br>​<br>​                                   2) 系统调用产生（kill，abort，raise） ：软件<br>信号交给内核处理。</p>
<h1 id="91-volitile的可见性与禁止指令重排"><a href="#91-volitile的可见性与禁止指令重排" class="headerlink" title="91 volitile的可见性与禁止指令重排"></a>91 volitile的可见性与禁止指令重排</h1><p><strong>volatile是两条实现原则：</strong><br><em><code>1.Lock前缀指令会引起处理器缓存会写到内存</code></em><br>当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中<br><code>2.一个处理器的缓存回写到内存会导致其他处理器的缓存失效</code><br>处理器使用嗅探技术保证内部缓存 系统内存和其他处理器的缓存的数据在总线上保持一致。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133851347">https://zhuanlan.zhihu.com/p/133851347</a></p>
<p>编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。（首先保证了正确性，再去追求执行效率）<br><code>1.在每个volatile写操作前插入StoreStore屏障；</code>对于这样的语句Store1; StoreLoad; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br><code>2.在每个volatile写操作后插入StoreLoad屏障；</code>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。<br><code>3.在每个volatile读操作前插入LoadLoad屏障；</code>对于这样的语句Load1;LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><code>4.在每个volatile读操作后插入LoadStore屏障；</code>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
<h2 id="volatile在java内存模型的i规则"><a href="#volatile在java内存模型的i规则" class="headerlink" title="volatile在java内存模型的i规则"></a>volatile在java内存模型的i规则</h2><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211219002533934.png" alt="image-20211219002533934"></p>
<h1 id="92-java线程和操作系统线程的关系"><a href="#92-java线程和操作系统线程的关系" class="headerlink" title="92  java线程和操作系统线程的关系"></a>92  java线程和操作系统线程的关系</h1><h2 id="1-内核线程（1：1）"><a href="#1-内核线程（1：1）" class="headerlink" title="1.内核线程（1：1）"></a>1.内核线程（1：1）</h2><p>使用内核线程实现的方式也被称为1:1实现。内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel，下称内核)支持的线程 。程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个 内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1 的关系称为一对一的线程模型 。</p>
<h2 id="2-用户线程（1：N）"><a href="#2-用户线程（1：N）" class="headerlink" title="2.用户线程（1：N）"></a>2.用户线程（1：N）</h2><p>使用用户线程实现的方式被称为1:N实现。 广义上来讲，一个线程只要不是内核线程，都可以认 为是用户线程(User Thread，UT)的一种 。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存 在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助 。用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都 需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操 作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处 理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。<br>。Java、Ruby等语言都曾经使 用过用户线程，最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支 持了用户线程，譬如Golang、Erlang等，使得用户线程的使用率有所回升。 </p>
<h2 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3.混合实现"></a>3.混合实现</h2><p>N:M 实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。 用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以 支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁， 这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来 完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量 比是不定的，是N:M 的关系，如图12-5所示，这种就是多对多的线程模型。</p>
<h2 id="4-关系"><a href="#4-关系" class="headerlink" title="4.关系"></a>4.关系</h2><p>Java线程在 早期的Classic虚拟机上(JDK 1.2以前)，是基于一种被称为“绿色线程”(Green Threads)的用户线程实现的，但从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1:1的线程模型。<br>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间 没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的(可以设置线程优先级给操作系统提 </p>
<p>前面强调是两个“主流”，那就说明肯定还有例外的情况，这里举两个比较著名的例子，一个是用 于Java ME的CLDC HotSpot Implementation(CLDC-HI，介绍可见第1章)。它同时支持两种线程模 型，默认使用1:N由用户线程实现的线程模型，所有Java线程都映射到一个内核线程上 </p>
<h1 id="93-Controller和-RestController的区别？"><a href="#93-Controller和-RestController的区别？" class="headerlink" title="93  [@Controller和@RestController的区别？"></a>93  [@Controller和@RestController的区别？</h1><ol>
<li><p>如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。</p>
</li>
<li><p>如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。<br>  如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解</p>
</li>
</ol>
<h1 id="94-剑指-Offer-67-把字符串转换成整数"><a href="#94-剑指-Offer-67-把字符串转换成整数" class="headerlink" title="94 剑指 Offer 67. 把字符串转换成整数"></a>94 剑指 Offer 67. 把字符串转换成整数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 <span class="number">32</span> 位大小的有符号整数，那么其数值范围为 [−<span class="number">231</span>,  <span class="number">231</span> − <span class="number">1</span>]。如果数值超过这个范围，请返回  INT_MAX (<span class="number">231</span> − <span class="number">1</span>) 或 INT_MIN (−<span class="number">231</span>) 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = str.trim().toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; c.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] &lt; <span class="string">&#x27;0&#x27;</span> || c[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="type">return</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE; <span class="comment">//这里大于7是巧妙处理，因为最小值MIN_VALUE对应的是8，直接用int被赋值是失败的（即使可以存，但是会失败，所以换种方式）</span></span><br><span class="line">            res = res * <span class="number">10</span> + (c[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="95-堆栈队列的使用场景"><a href="#95-堆栈队列的使用场景" class="headerlink" title="95 堆栈队列的使用场景"></a>95 堆栈队列的使用场景</h1><ul>
<li>栈可以用于字符匹配，数据反转等场景</li>
<li>队列可以用于任务队列，共享打印机等场景</li>
<li>堆可以用于优先队列，堆排序等场景</li>
</ul>
<h1 id="96-CMS垃圾回收器和G1垃圾回收器区别"><a href="#96-CMS垃圾回收器和G1垃圾回收器区别" class="headerlink" title="96   CMS垃圾回收器和G1垃圾回收器区别"></a>96   CMS垃圾回收器和G1垃圾回收器区别</h1><p>G1的设计思路，将内存区域分为不同region，实现局部收集。而不是以往的固定大小的分代区域。可以按照自己需求，将不同的region认为是eden，survivor等。 所以可以预测停顿时间。</p>
<p>4、筛选回收</p>
<p>最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>
<p>CMS是追求最短停顿时间的垃圾回收器。 以及是专用于老年代，永久代（元空间）的垃圾回收器。</p>
<p>并发清除时产生的垃圾是浮动垃圾，本次垃圾回收无法清除，只等下一次。</p>
<p>最终收集就是收集没有标记的对象。</p>
<p>关于两种垃圾回收器的选择，看情况。一般是GC，有个结论，目前的情况是，小内存应用上CMS优于G1。大内存反着。  但是G1未来还会进步。</p>
<h2 id="97-Spring框架的全局异常处理（涉及到的注解以及用法）-RestControllerAdvice，-ExceptionHandler"><a href="#97-Spring框架的全局异常处理（涉及到的注解以及用法）-RestControllerAdvice，-ExceptionHandler" class="headerlink" title="97 Spring框架的全局异常处理（涉及到的注解以及用法） @RestControllerAdvice，@ExceptionHandler"></a>97 Spring框架的全局异常处理（涉及到的注解以及用法） @RestControllerAdvice，@ExceptionHandler</h2><p>原理：</p>
<p>通过上述代码可以看出，在ExceptionHandlerExceptionResolver类中，该类扫描了所有标注有ExceptionHandler注解的方法，并将他们存入了exceptionHandlerAdviceCache中。</p>
<p>进入DispatcherServlet的doDispatch方法,从doDispatch方法中可以看出，程序先处理了controller层的业务逻辑，对于业务逻辑抛出的异常，程序统一做了封装，然后进入了processDispatchResult方法中进行处理。所以我们进入该方法一探究竟。</p>
<p>在DispatcherServlet初始化的时候，会去容器中找HandlerExceptionResolver类型的类。而刚刚的ExceptionHandlerExceptionResolver类就是继承了HandlerExceptionResolver接口，所以这个地方就将他放入了DispatcherServlet中。所以上面的遍历handlerExceptionResolvers处理异常信息的地方，就是调用了ExceptionHandlerExceptionResolver的resolveException方法。所以我们进入该方法。</p>
<p>首先我们可以自定义异常类如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoLoginException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoLoginException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoLoginException</span><span class="params">(UserExtraInfo info)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;请先登录！&quot;</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserExtraInfo <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthException</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建全局异常处理类 涉及到的关键注解  @RestControllerAdvice（用于类上面。加了Rest代表返回json字符串），与方法上加@ExceptionHandler(value &#x3D; Exception.class) ，其中的value指定捕捉的是哪种异常，其标志的方法就是发生这种异常后的处理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangzhiwei</span></span><br><span class="line"><span class="comment"> * 全局异常处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">defaultException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 默认异常需要处理</span></span><br><span class="line">        log.error(<span class="string">&quot;默认异常需要处理&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ResultCode) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(((ResultCode) ex).getCode(), ((ResultCode) ex).getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.error(SystemCodeEnum.SYSTEM_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = AuthException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">authException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.noAuth();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NoLoginException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;UserExtraInfo&gt; <span class="title function_">noLoginException</span><span class="params">(NoLoginException e)</span> &#123;</span><br><span class="line">        Result&lt;UserExtraInfo&gt; result = Result.error(SystemCodeEnum.SYSTEM_NOT_LOGIN);</span><br><span class="line">        result.setData(e.getInfo());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="97-动态代理和静态代理的区别"><a href="#97-动态代理和静态代理的区别" class="headerlink" title="97 动态代理和静态代理的区别"></a>97 动态代理和静态代理的区别</h1><p>按照代理的创建时期，代理类可以分为两种： </p>
<p>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。</p>
<p>动态：在程序运行时运用反射机制动态创建而成。</p>
<h1 id="98-Java类加载器工作原理-类加载器的类之间的可见性-（委托机制、单一性、可见性）"><a href="#98-Java类加载器工作原理-类加载器的类之间的可见性-（委托机制、单一性、可见性）" class="headerlink" title="98 Java类加载器工作原理  类加载器的类之间的可见性 （委托机制、单一性、可见性）"></a>98 Java类加载器工作原理  类加载器的类之间的可见性 （委托机制、单一性、可见性）</h1><p>Java类加载器基于三个原则：委托、可见性、唯一性。</p>
<ul>
<li><p>委托原则把加载类的请求转发给父 类加载器，而且仅加载类当父 类加载器无法找到或者不能加载类时。</p>
</li>
<li><p>可见性原则允许子类加载器查看由父类加载器加载的所有的类，但是父类加载器不能查看由子类加载器加载的类。</p>
</li>
<li><p>唯一性原则只允许加载一次类文件，这基本上是通过委托原则来实现的并确保子类加载器不重新加载由父类加载器加载过的类</p>
</li>
</ul>
<h1 id="99-JVM内存模型（区分开内存结构）"><a href="#99-JVM内存模型（区分开内存结构）" class="headerlink" title="99 JVM内存模型（区分开内存结构）"></a>99 JVM内存模型（区分开内存结构）</h1><p>此处的变量（Variables）与Java编程中所说的变量有所区 别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后 者是线程私有的[1]，不会被共享，自然就不会存在竞争问题。</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004020420.png" alt="image-20211215004020420"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004457328.png" alt="image-20211215004457328"></p>
<ul>
<li><p>注意，Java内存模型只要求上述两个操作 必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令 的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。</p>
</li>
<li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内 存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</p>
</li>
</ul>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215004956435.png" alt="image-20211215004956435"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211215005803320.png" alt="image-20211215005803320"></p>
<h1 id="100-Concurrentmap的size（）-以及各类如何保障线程安全"><a href="#100-Concurrentmap的size（）-以及各类如何保障线程安全" class="headerlink" title="100 Concurrentmap的size（） 以及各类如何保障线程安全"></a>100 Concurrentmap的size（） 以及各类如何保障线程安全</h1><p>因为有并行操作，获取size（）时，还会插入数据。 </p>
<h3 id="3-2-3-size-方法"><a href="#3-2-3-size-方法" class="headerlink" title="3.2.3 size()方法"></a>3.2.3 size()方法</h3><p>JDK1.7中的ConcurrentHashMap的size方法，计算size的时候会先不加锁获取一次数据长度，然后再获取一次，最多三次。比较前后两次的值，如果相同的话说明不存在竞争的编辑操作，就直接把值返回就可以了。<br>但是如果前后获取的值不一样，那么会将每个Segment都加上锁，然后计算ConcurrentHashMap的size值。</p>
<p>在JDK1.8中增加了<code>mappingCount()</code>方法，这个方法的返回值是long类型的，所以JDK1.8以后更推荐用这个方法获取Map中数据的数量。</p>
<p>无论是<code>size()</code>方法还是<code>mappingCount()</code>方法，核心方法都是<code>sumCount()</code>方法。</p>
<p>在上面sumCount()方法中我们看到，当<code>counterCells</code>为空时直接返回<code>baseCount</code>，当<code>counterCells</code>不为空时遍历它并垒加到<code>baseCount</code>中。</p>
<p><code>baseCount</code>是一个<code>volatile</code>变量，那么我们来看在<code>put()</code>方法执行时是如何使用baseCount的，在put方法的最后一段代码中会调用<code>addCount()</code>方法，而<code>addCount()</code>方法的源码如下：</p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_36,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先对baseCount做CAS自增操作。<br>如果并发导致了baseCount的CAS失败了，则使用counterCells进行CAS。<br>如果counterCells的CAS也失败了，那么则进入<code>fullAddCount()</code>方法，<code>fullAddCount()</code>方法中会进入死循环，直到成功为止。</p>
<p>然后，CounterCell 这个类到底是什么？我们会发现它使用了 @sun.misc.Contended 标记的类，内部包含一个 volatile 变量。@sun.misc.Contended 这个注解标识着这个类防止需要防止 “伪共享”。那么，什么又是伪共享呢？</p>
<p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<p>上面获取Cell数组的随机数是一种线程探针哈希。</p>
<ol>
<li>利用CAS递增baseCount值来感知是否存在线程竞争，若竞争不大直接CAS递增baseCount值即可，性能与直接baseCount++差别不大</li>
<li>若存在线程竞争，则初始化计数桶，若此时初始化计数桶的过程中也存在竞争，多个线程同时初始化计数桶，则没有抢到初始化资格的线程直接尝试CAS递增baseCount值的方式完成计数，最大化利用了线程的并行。此时使用计数桶计数，分而治之的方式来计数，此时两个计数桶最大可提供两个线程同时计数，同时使用CAS操作来感知线程竞争，若两个桶情况下CAS操作还是频繁失败（失败3次），则直接扩容计数桶，变为4个计数桶，支持最大同时4个线程并发计数，以此类推…同时使用位运算和随机数的方式”负载均衡”一样的将线程计数请求接近均匀的落在各个计数桶中。</li>
</ol>
<h2 id="1-初始化数据结构时的线程安全"><a href="#1-初始化数据结构时的线程安全" class="headerlink" title="1 .初始化数据结构时的线程安全"></a>1 .初始化数据结构时的线程安全</h2><p>在JDK1.8中，初始化ConcurrentHashMap的时候这个Node[]数组是还未初始化的，会等到第一次put方法调用时才初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//判断Node数组为空</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//初始化Node数组</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">          ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时是会有并发问题的，如果多个线程同时调用initTable初始化Node数组怎么办？看看大师是如何处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">  <span class="comment">//每次循环都获取最新的Node数组引用</span></span><br><span class="line">  <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//sizeCtl是一个标记位，若为-1也就是小于0，代表有线程在进行初始化工作了</span></span><br><span class="line">    <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//让出CPU时间片</span></span><br><span class="line">      Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">    <span class="comment">//CAS操作，将本实例的sizeCtl变量设置为-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">//如果CAS操作成功了，代表本线程将负责初始化工作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//再检查一遍数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//在初始化Map时，sizeCtl代表数组大小，默认16</span></span><br><span class="line">          <span class="comment">//所以此时n默认为16</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          <span class="comment">//Node数组</span></span><br><span class="line">          Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">          <span class="comment">//将其赋值给table变量</span></span><br><span class="line">          table = tab = nt;</span><br><span class="line">          <span class="comment">//通过位运算，n减去n二进制右移2位，相当于乘以0.75</span></span><br><span class="line">          <span class="comment">//例如16经过运算为12，与乘0.75一样，只不过位运算更快</span></span><br><span class="line">          sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//将计算后的sc（12）直接赋值给sizeCtl，表示达到12长度就扩容</span></span><br><span class="line">        <span class="comment">//由于这里只会有一个线程在执行，直接赋值即可，没有线程安全问题</span></span><br><span class="line">        <span class="comment">//只需要保证可见性</span></span><br><span class="line">        sizeCtl = sc;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-put操作的线程安全"><a href="#2-put操作的线程安全" class="headerlink" title="2.put操作的线程安全"></a>2.put操作的线程安全</h2><p>当Node数组，算出的位置还为null，此时采用CAS操作插入数据。</p>
<p>假如此处已经有数据了，那么使用Synchronized关键字锁住这个节点，然后首先二次确认这个位置开始的节点没变。之后无线循环，如果找到key一样的地方，直接替换，结束循环。如果找到直到下一个为null，那就直接插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="comment">//对key的hashCode进行散列</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//一个无限循环，直到put操作完成后退出循环</span></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">    <span class="comment">//当Node数组为空时进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      tab = initTable();</span><br><span class="line">    <span class="comment">//Unsafe类volatile的方式取出hashCode散列后通过与运算得出的Node数组下标值对应的Node对象</span></span><br><span class="line">    <span class="comment">//此时的Node对象若为空，则代表还未有线程对此Node进行插入操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//直接CAS方式插入数据</span></span><br><span class="line">      <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="comment">//插入成功，退出循环</span></span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看是否在扩容，先不看，扩容再介绍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      <span class="comment">//帮助扩容</span></span><br><span class="line">      tab = helpTransfer(tab, f);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//对Node对象进行加锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="comment">//二次确认此Node对象还是原来的那一个</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无限循环，直到完成put</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">              K ek;</span><br><span class="line">              <span class="comment">//和HashMap一样，先比较hash，再比较equals</span></span><br><span class="line">              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key ||</span><br><span class="line">                   (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                oldVal = e.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  e.val = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Node&lt;K,V&gt; pred = e;</span><br><span class="line">              <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//和链表头Node节点不冲突，就将其初始化为新Node作为上一个Node节点的next</span></span><br><span class="line">                <span class="comment">//形成链表结构</span></span><br><span class="line">                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                          value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">值得关注的是tabAt(tab, i)方法，其使用Unsafe类<span class="keyword">volatile</span>的操作<span class="keyword">volatile</span>式地查看值，保证每次获取到的值都是最新的：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-扩容操作的线程安全"><a href="#3-扩容操作的线程安全" class="headerlink" title="3 . 扩容操作的线程安全"></a>3 . 扩容操作的线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">  <span class="comment">//根据机器CPU核心数来计算，一条线程负责Node数组中多长的迁移量</span></span><br><span class="line">  <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">    <span class="comment">//本线程分到的迁移量</span></span><br><span class="line">    <span class="comment">//假设为16（默认也为16）</span></span><br><span class="line">    stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">  <span class="comment">//nextTab若为空代表线程是第一个进行迁移的</span></span><br><span class="line">  <span class="comment">//初始化迁移后的新Node数组</span></span><br><span class="line">  <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">//这里n为旧数组长度，左移一位相当于乘以2</span></span><br><span class="line">      <span class="comment">//例如原数组长度16，新数组长度则为32</span></span><br><span class="line">      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">      nextTab = nt;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">      sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置nextTable变量为新数组</span></span><br><span class="line">    nextTable = nextTab;</span><br><span class="line">    <span class="comment">//假设为16</span></span><br><span class="line">    transferIndex = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//假设为32</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">  <span class="comment">//标示Node对象，此对象的hash变量为-1</span></span><br><span class="line">  <span class="comment">//在get或者put时若遇到此Node，则可以知道当前Node正在迁移</span></span><br><span class="line">  <span class="comment">//传入nextTab对象</span></span><br><span class="line">  ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">    <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">      <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">      <span class="comment">//i为当前正在处理的Node数组下标，每次处理一个Node节点就会自减1</span></span><br><span class="line">      <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">        advance = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//假设nextIndex=16</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        i = -<span class="number">1</span>;</span><br><span class="line">        advance = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//由以上假设，nextBound就为0</span></span><br><span class="line">      <span class="comment">//且将nextIndex设置为0</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">               (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                             nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">//bound=0</span></span><br><span class="line">        bound = nextBound;</span><br><span class="line">        <span class="comment">//i=16-1=15</span></span><br><span class="line">        i = nextIndex - <span class="number">1</span>;</span><br><span class="line">        advance = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">      <span class="type">int</span> sc;</span><br><span class="line">      <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        nextTable = <span class="literal">null</span>;</span><br><span class="line">        table = nextTab;</span><br><span class="line">        sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        finishing = advance = <span class="literal">true</span>;</span><br><span class="line">        i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时i=15，取出Node数组下标为15的那个Node，若为空则不需要迁移</span></span><br><span class="line">    <span class="comment">//直接设置占位标示，代表此Node已处理完成</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">      advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">    <span class="comment">//检测此Node的hash是否为MOVED，MOVED是一个常量-1，也就是上面说的占位Node的hash</span></span><br><span class="line">    <span class="comment">//如果是占位Node，证明此节点已经处理过了，跳过i=15的处理，继续循环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//锁住这个Node</span></span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="comment">//确认Node是原先的Node</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="comment">//ln为lowNode，低位Node，hn为highNode，高位Node</span></span><br><span class="line">          <span class="comment">//这两个概念下面以图来说明</span></span><br><span class="line">          Node&lt;K,V&gt; ln, hn;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//此时fh与原来Node数组长度进行与运算</span></span><br><span class="line">            <span class="comment">//如果高X位为0，此时runBit=0</span></span><br><span class="line">            <span class="comment">//如果高X位为1，此时runBit=1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">              <span class="comment">//这里的Node，都是同一Node链表中的Node对象</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">              <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                runBit = b;</span><br><span class="line">                lastRun = p;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//正如上面所说，runBit=0，表示此Node为低位Node</span></span><br><span class="line">            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">              ln = lastRun;</span><br><span class="line">              hn = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//Node为高位Node</span></span><br><span class="line">              hn = lastRun;</span><br><span class="line">              ln = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">              <span class="comment">//若hash和n与运算为0，证明为低位Node，原理同上</span></span><br><span class="line">              <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">              <span class="comment">//这里将高位Node与地位Node都各自组成了两个链表</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将低位Node设置到新Node数组中，下标为原来的位置</span></span><br><span class="line">            setTabAt(nextTab, i, ln);</span><br><span class="line">            <span class="comment">//将高位Node设置到新Node数组中，下标为原来的位置加上原Node数组长度</span></span><br><span class="line">            setTabAt(nextTab, i + n, hn);</span><br><span class="line">            <span class="comment">//将此Node设置为占位Node，代表处理完成</span></span><br><span class="line">            setTabAt(tab, i, fwd);</span><br><span class="line">            <span class="comment">//继续循环</span></span><br><span class="line">            advance = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          ....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说一下迁移时为什么要分一个ln（低位Node）、hn（高位Node），首先说一个现象：</p>
<p>我们知道，在put值的时候，首先会计算hash值，再散列到指定的Node数组下标中：</p>
<p>其中n为Node数组长度，这里假设为16。</p>
<p>假设有一个key进来，它的散列之后的hash&#x3D;9，那么它的下标值是多少呢？</p>
<p>（16 - 1）和 9 进行与运算 -&gt; 0000 1111 和 0000 1001 结果还是 0000 1001 &#x3D; 9<br>假设Node数组需要扩容，我们知道，扩容是将数组长度增加两倍，也就是32，那么下标值会是多少呢？</p>
<p>（32 - 1）和 9 进行与运算 -&gt; 0001 1111 和 0000 1001 结果还是9<br>此时，我们把散列之后的hash换成20，那么会有怎样的变化呢？</p>
<p>（16 - 1）和 20 进行与运算 -&gt; 0000 1111 和 0001 0100 结果是 0000 0100 &#x3D; 4<br>（32 - 1）和 20 进行与运算 -&gt; 0001 1111 和 0001 0100 结果是 0001 0100 &#x3D; 20<br>此时细心的读者应该可以发现，如果hash在高X位为1，（X为数组长度的二进制-1的最高位），则扩容时是需要变换在Node数组中的索引值的，不然就hash不到，丢失数据，所以这里在迁移的时候将高X位为1的Node分类为hn，将高X位为0的Node分类为ln</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; </span><br><span class="line">  <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; </span><br><span class="line">  <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">  <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个操作将高低位组成了两条链表结构，由下图所示：</p>
<p>然后将其CAS操作放入新的Node数组中：</p>
<p>其中，低位链表放入原下标处，而高位链表则需要加上原Node数组长度，其中为什么不多赘述，上面已经举例说明了，这样就可以保证高位Node在迁移到新Node数组中依然可以使用hash算法散列到对应下标的数组中去了。</p>
<p>最后将原Node数组中对应下标Node对象设置为fwd标记Node，表示该节点迁移完成，到这里，一个节点的迁移就完成了，将进行下一个节点的迁移，也就是i-1&#x3D;14下标的Node节点。</p>
<h3 id="扩容时的get操作"><a href="#扩容时的get操作" class="headerlink" title="扩容时的get操作"></a>扩容时的get操作</h3><p>假设Node下标为16的Node节点正在迁移，突然有一个线程进来调用get方法，正好key又散列到下标为16的节点，此时怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">  <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假如Node节点的hash值小于0</span></span><br><span class="line">    <span class="comment">//则有可能是fwd节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//调用节点对象的find方法查找值</span></span><br><span class="line">      <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">          ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看有注释的那两行，在get操作的源码中，会判断Node中的hash是否小于0，是否还记得我们的占位Node，其hash为MOVED，为常量值-1，所以此时判断线程正在迁移，委托给fwd占位Node去查找值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">ConcurrentHashMap</span>.Node&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> ConcurrentHashMap.Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">        ForwardingNode(ConcurrentHashMap.Node&lt;K, V&gt;[] tab) &#123;</span><br><span class="line">            <span class="built_in">super</span>(-<span class="number">1</span>, (Object)<span class="literal">null</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">       ......</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类	ForwardingNode中</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">  <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">  <span class="comment">// 这里的查找，是去新Node数组中查找的</span></span><br><span class="line">  <span class="comment">// 下面的查找过程与HashMap查找无异，不多赘述</span></span><br><span class="line">  outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="literal">null</span> || tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">int</span> eh; K ek;</span><br><span class="line">      <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">          ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">          tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">          <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里应该可以恍然大悟了，之所以占位Node需要保存新Node数组的引用也是因为这个，它可以支持在迁移的过程中照样不阻塞地查找值，可谓是精妙绝伦的设计。</p>
<h3 id="多线程协助扩容"><a href="#多线程协助扩容" class="headerlink" title="多线程协助扩容"></a>多线程协助扩容</h3><p>在put操作时，假设正在迁移，正好有一个线程进来，想要put值到迁移的Node上，怎么办？</p>
<p>此时sizeCtl变量用来标示HashMap正在扩容，当其准备扩容时，会将sizeCtl设置为一个负数，（例如数组长度为16时）其二进制表示为：</p>
<p>无符号位为1，表示负数。其中高16位代表数组长度的一个位算法标示（有点像epoch的作用，表示当前迁移朝代为数组长度X），低16位表示有几个线程正在做迁移，刚开始为2，接下来自增1，线程迁移完会进行减1操作，也就是如果低十六位为2，代表有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</p>
<p>只要数组长度足够长，就可以同时容纳足够多的线程来一起扩容，最大化并行任务，提高性能。</p>
<p>扩容条件和hashmap一样。</p>
<h1 id="101-自定义线程池名称"><a href="#101-自定义线程池名称" class="headerlink" title="101 自定义线程池名称"></a>101 自定义线程池名称</h1><p>主要通过继承ThreadFactory接口，重写newThread方法，创建线程时，给其名字带上特征，代表哪个线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MssThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    MssThreadFactory(String namePrefix) &#123;</span><br><span class="line">        <span class="built_in">this</span>.namePrefix = namePrefix+<span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( r,namePrefix + threadNumber.getAndIncrement());</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="102-Redis-集群，主从延迟大，脑裂的处理方案"><a href="#102-Redis-集群，主从延迟大，脑裂的处理方案" class="headerlink" title="102 Redis 集群，主从延迟大，脑裂的处理方案"></a>102 Redis 集群，主从延迟大，脑裂的处理方案</h1><p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/446808194_283613">https://www.sohu.com/a/446808194_283613</a>  主从延迟，开任务监视，延迟大就主库读</p>
<p>如果分区故障，sentinal选出新master，客户端给原master发信息，就是脑裂。 会丢失数据，redis有设置属性，如果超过 n个slave 数据复制同步超过m 时间，那么这个master不再接受指令。</p>
<h1 id="103-Arraylist的扩容，以及copy方法"><a href="#103-Arraylist的扩容，以及copy方法" class="headerlink" title="103 Arraylist的扩容，以及copy方法"></a>103 Arraylist的扩容，以及copy方法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zymx14/article/details/78324464">https://blog.csdn.net/zymx14/article/details/78324464</a>  Arraylist的扩容，一般扩容为1.5倍。如果一开始还为空时，且插入的数量小于默认的10，开个10大小的。</p>
<p>扩容赋值调用的 Arrays.copyOf() 实际System.arraycopy() ；</p>
<h1 id="104-螺旋矩阵"><a href="#104-螺旋矩阵" class="headerlink" title="104 螺旋矩阵"></a>104 螺旋矩阵</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="literal">null</span>||matrix.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numEle</span> <span class="operator">=</span> matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span> (numEle &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right &amp;&amp; numEle &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">                numEle--;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom &amp;&amp; numEle &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">                numEle--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left &amp;&amp; numEle &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                result.add(matrix[bottom][i]);</span><br><span class="line">                numEle--;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; numEle &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">                numEle--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="105-synchronize加锁，时间片消耗完切换线程也不释放锁。"><a href="#105-synchronize加锁，时间片消耗完切换线程也不释放锁。" class="headerlink" title="105 synchronize加锁，时间片消耗完切换线程也不释放锁。"></a>105 synchronize加锁，时间片消耗完切换线程也不释放锁。</h1><h1 id="106-RPC系统宕机问题"><a href="#106-RPC系统宕机问题" class="headerlink" title="106 RPC系统宕机问题"></a>106 RPC系统宕机问题</h1><p>健壮性</p>
<ul>
<li><p>监控中心宕掉<br>不影响使用，只是丢失部分采样数据</p>
</li>
<li><p>数据库宕掉<br>注册中心，仍能通过缓存提供服务列表查询，但不能注册新服务</p>
</li>
<li><p>注册中心<br>对等集群，任意一台宕掉，将自动切换到另一台</p>
</li>
<li><p>注册中心<br>全部宕掉后，服务提供者和服务消费者，仍能通过本地缓存通讯</p>
</li>
<li><p>服务提供者<br>无状态，任意一台宕掉，不影响使用</p>
</li>
<li><p>服务提供者<br>全部宕掉，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>
</li>
</ul>
<h1 id="107-redis宕机问题"><a href="#107-redis宕机问题" class="headerlink" title="107 redis宕机问题"></a>107 redis宕机问题</h1><ul>
<li>slave从redis宕机</li>
</ul>
<p>配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志，求达到主从复制。<br>1）在Redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据；<br>2）如果从数据库实现了持久化，可以直接连接到主的上面，只要实现增量备份（宕机到重新连接过程中，主的数据库发生数据操作，复制到从数据库），重新连接到主从架构中会实现增量同步。</p>
<ul>
<li>Master 宕机</li>
</ul>
<p>假如主从都没数据持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：<br>在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库<br>此时重新启动主数据库，执行SLAVEOF,把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。<br>以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法：redis的哨兵（sentinel）的功能。</p>
<p>Redis提供了sentinel（哨兵）机制通过sentinel模式启动redis后，自动监控master&#x2F;slave的运行状态，基本原理是：心跳机制+投票裁决。</p>
<p>每个sentinel会向其它sentinal、master、slave定时发送消息（哨兵定期给主或者从和slave发送ping包（IP：port），正常则响应pong，ping和pong就叫心跳机制），以确认对方是否“活”着，如果发现对方在指定时间（可配置）内未回应，则暂时认为对方已挂（所谓的“主观认为宕机” Subjective Down，简称SDOWN）。</p>
<p>若”哨兵群”中的多数sentinel，都报告某一master没响应，系统才认为该master”彻底死亡”(即：客观上的真正down机，Objective Down，简称ODOWN)，通过一定的vote算法，从剩下的slave节点中，选一台提升为master，然后自动修改相关配置。</p>
<h1 id="108-实现长地址请求到服务端，然后服务端重定向短地址给客户端，如何实现长短地址的互相映射？"><a href="#108-实现长地址请求到服务端，然后服务端重定向短地址给客户端，如何实现长短地址的互相映射？" class="headerlink" title="108 实现长地址请求到服务端，然后服务端重定向短地址给客户端，如何实现长短地址的互相映射？"></a>108 实现长地址请求到服务端，然后服务端重定向短地址给客户端，如何实现长短地址的互相映射？</h1><p><a target="_blank" rel="noopener" href="http://vearne.cc/archives/39248">http://vearne.cc/archives/39248</a></p>
<h3 id="2-实现-amp-原理"><a href="#2-实现-amp-原理" class="headerlink" title="2. 实现&amp;原理"></a>2. 实现&amp;原理</h3><h4 id="2-2-生成短地址"><a href="#2-2-生成短地址" class="headerlink" title="2.2 生成短地址"></a>2.2 生成短地址</h4><h5 id="1-将长地址与一个整数建立映射-一对多"><a href="#1-将长地址与一个整数建立映射-一对多" class="headerlink" title="1) 将长地址与一个整数建立映射(一对多)"></a>1) 将长地址与一个整数建立映射(一对多)</h5><p>这里整数使用int64，保存映射关系。笔者为了简单使用是MySQL数据库，如果为了更好的并发存储，还可以NoSQL数据库或者数据分分库分表。</p>
<h5 id="2）base62编码"><a href="#2）base62编码" class="headerlink" title="2）base62编码"></a>2）base62编码</h5><p>整数如果直接按字符串传输，长度还是太长。可以对整数进行base62编码<br>之所以是62，其实是 26个小写英文字母[a-z], 26个大写英文字母[A-Z], 以及阿拉伯数字[0-9]。有意的避开特殊符号和不可见字符。</p>
<h5 id="3-拼接上域名"><a href="#3-拼接上域名" class="headerlink" title="3) 拼接上域名"></a>3) 拼接上域名</h5><p>就得形如， 短链接地址: <a target="_blank" rel="noopener" href="http://st.vearne.cc/2h9">http://st.vearne.cc/2h9</a></p>
<h1 id="109-java-集合基础"><a href="#109-java-集合基础" class="headerlink" title="109 java 集合基础"></a>109 java 集合基础</h1><ol>
<li>Map的遍历方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>         <span class="comment">//第一种遍历map的方法，通过加强for循环map.keySet()，然后通过键key获取到value值</span></span><br><span class="line"><span class="number">23</span>         <span class="keyword">for</span>(String s:map.keySet())&#123;</span><br><span class="line"><span class="number">24</span>             System.out.println(<span class="string">&quot;key : &quot;</span>+s+<span class="string">&quot; value : &quot;</span>+map.get(s));</span><br><span class="line"><span class="number">25</span>         &#125;</span><br><span class="line"><span class="number">26</span>         System.out.println(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line"><span class="number">27</span>         </span><br><span class="line"><span class="number">28</span>         <span class="comment">//第二种只遍历键或者值，通过加强for循环</span></span><br><span class="line"><span class="number">29</span>         <span class="keyword">for</span>(String s1:map.keySet())&#123;<span class="comment">//遍历map的键</span></span><br><span class="line"><span class="number">30</span>             System.out.println(<span class="string">&quot;键key ：&quot;</span>+s1);</span><br><span class="line"><span class="number">31</span>         &#125;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">for</span>(String s2:map.values())&#123;<span class="comment">//遍历map的值</span></span><br><span class="line"><span class="number">33</span>             System.out.println(<span class="string">&quot;值value ：&quot;</span>+s2);</span><br><span class="line"><span class="number">34</span>         &#125;</span><br><span class="line"><span class="number">35</span>         System.out.println(<span class="string">&quot;====================================&quot;</span>);    </span><br><span class="line"><span class="number">36</span>         </span><br><span class="line"><span class="number">37</span>         <span class="comment">//第三种方式Map.Entry&lt;String, String&gt;的加强for循环遍历输出键key和值value</span></span><br><span class="line"><span class="number">38</span>         <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line"><span class="number">39</span>             System.out.println(<span class="string">&quot;键 key ：&quot;</span>+entry.getKey()+<span class="string">&quot; 值value ：&quot;</span>+entry.getValue());</span><br><span class="line"><span class="number">40</span>         &#125;</span><br><span class="line"><span class="number">41</span>         System.out.println(<span class="string">&quot;====================================&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="快速报错（fail-fast）"><a href="#快速报错（fail-fast）" class="headerlink" title="快速报错（fail-fast）"></a>快速报错（fail-fast）</h2><p>java容器有一种保护机制，能够防止多个进程同时修改同一容器的内容。</p>
<p>如果在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入、删除或修改此容器内的某个对象，那么就容易出现问题。</p>
<p>java容器类类库采用fail-fast机制。他会探查容器上除了当前线程所进行的操作之外的所有变化，一旦发现其它进程修改了容器，就会立刻抛出ConcurrentModificationException异常。</p>
<h2 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h2><p>Hash</p>
<blockquote>
<p><strong>HashSet</strong>: 为快速查找而设计,可以认为是基于<strong>哈希表</strong>的实现。 存入HashSet的元素<strong>必须定义hashCode().</strong></p>
</blockquote>
<blockquote>
<p><strong>LinkedHashSet:</strong> 具有HashSet的查询速度且内部使用链表维护元素的顺序（按插入的顺序或最近最少使用顺序）</p>
</blockquote>
<p>Tree</p>
<blockquote>
<p><strong>TreeSet：</strong>保持次序的Set，底层为树结构（红黑树）。使用它可以从Set提取有序的序列。元素<strong>必须实现Comparable接口</strong>或者在构造TreeSet时传入Comparator参数。</p>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p>HashMap 基于散列表的实现（它取代了HashTable, HashTable是过时的类）。</p>
</blockquote>
<blockquote>
<p>LinkedHashMap 类似与HashMap， 但是迭代遍历时，取得“键值对”的顺序是其插入的顺序</p>
<p>​            或最近最少使用的顺序(如果在构造LiskedHashMap传入参数accessOrder&#x3D;true)。</p>
<p>​            比HashMap慢一点，但是在迭代访问时更快，因为它使用链表维护内部的次序。</p>
<p>TreeMap 基于红黑树的实现。查看key 或 key-value是，它们会被排序（次序由Comparator或Comparable决定）</p>
</blockquote>
<h2 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h2><blockquote>
<p><strong>ArrayList</strong>  内部实现是用数组, 随机访问速度快， 删除或插入元素速度慢。   容量最大Integer</p>
</blockquote>
<blockquote>
<p><strong>LinkedList</strong> 内部实现是用链表, 随机访问速度慢，删除和插入元素相对较快。  容量无限制</p>
</blockquote>
<p>平时最佳的做法可能是将ArrayList作为默认首选，只有你需要使用额外的功能，或者因为经常从表中插入或删除元素导致程序性能变差的时候，才去选择LinkedList。</p>
<p>Vector和Stack是过去遗留下来的类，目的只是为了支持老程序，应该在编写程序时尽量避免使用它们。</p>
<h1 id="110-CountDownLatch与CyclicBarrier区别"><a href="#110-CountDownLatch与CyclicBarrier区别" class="headerlink" title="110 CountDownLatch与CyclicBarrier区别"></a>110 CountDownLatch与CyclicBarrier区别</h1><p>1）       CountDownLatch：一个线程或者多个线程，等待另外N个线程完成某个事情之后才能执行。只有一个等待线程，其他N个线程都可以顺利执行完毕。</p>
<p>2）       CyclicBarrier：N个线程互相等待，任何一个线程完成之前，所有线程都必须等待。在最后一个未await之前，所有N个线程都不算完成，都处于阻塞状态。</p>
<h1 id="111-什么是分布式"><a href="#111-什么是分布式" class="headerlink" title="111 什么是分布式"></a>111 什么是分布式</h1><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/image-20211222220843760.png" alt="image-20211222220843760"></p>
<h1 id="112-重载"><a href="#112-重载" class="headerlink" title="112 重载"></a>112 重载</h1><p>集合类的泛型擦除，所以不是重载，会报错。</p>
<p>主要通过参数个数，以及参数类型，参数类型位置是否一样（相同数量参数，一样位置就报错）</p>
<h1 id="113-什么是横向扩展，什么是纵向扩展"><a href="#113-什么是横向扩展，什么是纵向扩展" class="headerlink" title="113  什么是横向扩展，什么是纵向扩展"></a>113  什么是横向扩展，什么是纵向扩展</h1><ul>
<li><strong>纵向扩展：</strong></li>
</ul>
<p>表示在需要处理更多负载时通过提高单个系统处理能力的方法来解决问题。<br>最简单的情况就是为应用系统提供更为强大的硬件。例如如果数据库所在的服务器实例只有<br>2G内存、低配CPU、小容量硬盘，进而导致了数据库不能高效地运行，那么我们就可以通过<br>将该服务器的内存扩展至8G、更换大容量硬盘或者更换高性能服务器来解决这个问题</p>
<ul>
<li><strong>横向扩展:</strong></li>
</ul>
<p>是将服务分割为众多的子服务并在负载平衡等技术的帮助下在应用中添加新的服务实例.<br>例如如果数据库所在的服务器实例只有一台服务器，进而导致了数据库不能高效地运行，<br>那么我们就可以通过增加服务器数量，将其构成一个集群来解决这个问题。</p>
<h1 id="114-hashmap的扩容（1-8）"><a href="#114-hashmap的扩容（1-8）" class="headerlink" title="114 hashmap的扩容（1.8）"></a>114 hashmap的扩容（1.8）</h1><p>和concurrenthashmap类似，处理链表，红黑树时，有两个链表头，两个链表尾，一个是低位原来位置，一个是原来位置加上原来数组的长度。  且每次是链表尾移动，所以是尾插法，不会再有无线循环问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">	<span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">	<span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 第一次进来，table为null，oldCap为0，不会进入这里</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">			threshold = Integer.MAX_VALUE; <span class="comment">// 取整型最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">			<span class="keyword">return</span> oldTab;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// oldCap翻倍得到newCap</span></span><br><span class="line">				 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">			newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold // 第一次进来，如果手动设置了初始容量initialCapacity，这里为true，则将threshold作为初始容量</span></span><br><span class="line">		newCap = oldThr;</span><br><span class="line">	<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults // 如果没有手动设置initialCapacity，则设为默认值16</span></span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">		newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 第一次进来，这里必为true，重新计算 threshold = capacity * Load factor</span></span><br><span class="line">		<span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">				  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	threshold = newThr;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">		Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">	table = newTab;</span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 对oldTab中所有元素进行rehash。由于每次扩容是2次幂的扩展(指数组长度/桶数量扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">			Node&lt;K,V&gt; e;</span><br><span class="line">			<span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123; <span class="comment">// 数组j位置的元素不为空，需要该位置上的所有元素进行rehash</span></span><br><span class="line">				oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">// 桶中只有一个元素，则直接rehash</span></span><br><span class="line">					newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 桶中是树结构</span></span><br><span class="line">					((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="comment">// preserve order // 桶中是链表结构（JDK1.7中旧链表迁移新链表的时候，用的是头插法，如果在新表的数组索引位置相同，则链表元素会倒置；但是JDK1.8不会倒置，用的是双指针）</span></span><br><span class="line">					Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// low位链表，其桶位置不变，head和tail分别代表首尾指针</span></span><br><span class="line">					Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// high位链表，其桶位于追加后的新数组中</span></span><br><span class="line">					Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						next = e.next;</span><br><span class="line">						<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 是0的话索引没变，是1的话索引变成“原索引+oldCap”</span></span><br><span class="line">							<span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">								loHead = e; <span class="comment">// 总是指向头结点</span></span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								loTail.next = e; <span class="comment">// 该操作有可能会改变原链表结构</span></span><br><span class="line">							loTail = e; <span class="comment">// 总是指向下一个节点，直到尾节点</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">					<span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">						loTail.next = <span class="literal">null</span>;</span><br><span class="line">						newTab[j] = loHead; <span class="comment">// 原索引</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">						hiTail.next = <span class="literal">null</span>;</span><br><span class="line">						newTab[j + oldCap] = hiHead; <span class="comment">// 原索引+oldCap</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/70" alt="这里写图片描述"></p>
<h1 id><a href="#" class="headerlink" title></a></h1><p>为什么要红黑树  ：</p>
<p>红黑树是一种平衡树</p>
<p><strong>保证平衡性的最大的目的就是降低树的高度，因为树的查找性能取决于树的高度。所以树的高度越低搜索的效率越高！</strong></p>
<h1 id="115-线程池关闭的APi-区别"><a href="#115-线程池关闭的APi-区别" class="headerlink" title="115 线程池关闭的APi 区别"></a>115 线程池关闭的APi 区别</h1><p>一、一句话说明白shutdown和shutdownNow的区别</p>
<p>shutdown只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断。而shutdownNow则是将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回。</p>
<h1 id="116-找零钱-，花最少的硬币"><a href="#116-找零钱-，花最少的硬币" class="headerlink" title="116 找零钱 ，花最少的硬币"></a>116 找零钱 ，花最少的硬币</h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="117-朋友圈设计"><a href="#117-朋友圈设计" class="headerlink" title="117 朋友圈设计"></a>117 朋友圈设计</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuyujin1997/article/details/90486063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.fixedcolumn&amp;spm=1001.2101.3001.4242.2">https://blog.csdn.net/wuyujin1997/article/details/90486063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.fixedcolumn&amp;spm=1001.2101.3001.4242.2</a> </p>
<h1 id="118-逻辑题：兔子有100根胡萝卜，回家要走50米，一次最多携带50根胡萝卜，且没走一米会吃掉一根，问最多能带多少胡萝卜回家？"><a href="#118-逻辑题：兔子有100根胡萝卜，回家要走50米，一次最多携带50根胡萝卜，且没走一米会吃掉一根，问最多能带多少胡萝卜回家？" class="headerlink" title="118 逻辑题：兔子有100根胡萝卜，回家要走50米，一次最多携带50根胡萝卜，且没走一米会吃掉一根，问最多能带多少胡萝卜回家？"></a>118 逻辑题：兔子有100根胡萝卜，回家要走50米，一次最多携带50根胡萝卜，且没走一米会吃掉一根，问最多能带多少胡萝卜回家？</h1><p> 依次例举，走1m，走2m,返回，发现走的能背的数量一样，走的越远，回来越远，越浪费。所以开始每次走1m 就回头，知道某一刻能一次性背所有胡萝卜，即胡萝卜数小于50，直接到终点。 最终剩16；</p>
<h1 id="119-逻辑题：有一个天平、一个7g的砝码、一个2g的砝码，如何称3次后，将140g的盐分为50g、90g两堆？"><a href="#119-逻辑题：有一个天平、一个7g的砝码、一个2g的砝码，如何称3次后，将140g的盐分为50g、90g两堆？" class="headerlink" title="119 逻辑题：有一个天平、一个7g的砝码、一个2g的砝码，如何称3次后，将140g的盐分为50g、90g两堆？"></a>119 逻辑题：有一个天平、一个7g的砝码、一个2g的砝码，如何称3次后，将140g的盐分为50g、90g两堆？</h1><p> 70 70， 35 35，  15 20  第一次，140g对半分。 第二次，70对半分，，第三次，砝码一边2，一边7，将35拆为 15 20。  最终结果为 70 , 35 , 15, 20, 相加得到结果 50 ， 90g。</p>
<h1 id="120-有40亿个数，给一个数判断是否在这40亿个数中"><a href="#120-有40亿个数，给一个数判断是否在这40亿个数中" class="headerlink" title="120 有40亿个数，给一个数判断是否在这40亿个数中"></a>120 有40亿个数，给一个数判断是否在这40亿个数中</h1><p> 3、秒级方法：使用分布式将数据分在8个机器上，然后同时查找，返回是否存在。</p>
<p>4、毫秒级方法：32位int的范围，总共就是2的32次方，大概42亿多点。所以你可以申请2的32次方个位。40亿个数中，存在的数就在相应的位置1，其他位就是0。新的数就去找相应的位，比如来了一个1234，就找一下第1234位，如果是1就存在，是0就不存在啦。此时2的32次方个位，相当于2的29次方个字节，才500MB，真是节省了不少内存呢。其实这是一种非常有名的大数据算法，叫位图法，英文名叫bitmap。顾名思义，就是用位来表示状态，从而节省空间。</p>
<h1 id="121-联合索引的B-树图"><a href="#121-联合索引的B-树图" class="headerlink" title="121 联合索引的B+树图"></a>121 联合索引的B+树图</h1><p>也就是说，联合索引(col1, col2,col3)也是一棵B+Tree，其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/caoyuanyenang/article/details/88805670">https://blog.csdn.net/caoyuanyenang/article/details/88805670</a> </p>
<h1 id="122-为什么不用外键"><a href="#122-为什么不用外键" class="headerlink" title="122 为什么不用外键"></a>122 为什么不用外键</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yxz8102/article/details/107303975">https://blog.csdn.net/yxz8102/article/details/107303975</a>  </p>
<p>先来瞧瞧阿里的开发手册怎么说：</p>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度。</span><br></pre></td></tr></table></figure>

<p>其他大佬的看法：</p>
<ol>
<li>业务数据生成顺序，未必一定可以先生成外键的值，再生成明细数据</li>
<li>修数据：应该没有人没修过生产环境的数据吧？有外键约束，修数据就有一些麻烦了</li>
<li>性能和扩展问题：级联控制，在应用层面做，可以降低数据库的压力。因为数据库的资源是有限资源，应用资源是可以通过加机器进行水平扩展的</li>
<li>分库分表的场景，无法使用外键</li>
</ol>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l4ejgxMDI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="123-int和varchar声明的时候长度的含义等"><a href="#123-int和varchar声明的时候长度的含义等" class="headerlink" title="123 int和varchar声明的时候长度的含义等"></a>123 int和varchar声明的时候长度的含义等</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014143369/article/details/60386547?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_paycolumn_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_paycolumn_v2&utm_relevant_index=1">mysql数据库int(5)以及varchar(20)长度表示的是什么？_山里樵夫俗称大叔-CSDN博客_数据库中varchar(20)是什么意思</a></p>
<p>总结:  int(M) M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；</p>
<p>​     varchar(M) M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；</p>
<p>int 类型确定宽度后如果不足宽度长，会是补全前缀0。</p>
<h1 id="124-分库分表"><a href="#124-分库分表" class="headerlink" title="124 分库分表"></a>124 分库分表</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/azhuyangjun/article/details/86976514">数据库分库分表，何时分？怎样分？详细解读，一篇就够了_azhuyangjun的博客-CSDN博客_数据库分库分表</a></p>
<h1 id="125-Innodb行锁的实现"><a href="#125-Innodb行锁的实现" class="headerlink" title="125  Innodb行锁的实现"></a>125  Innodb行锁的实现</h1><p>Innodb 的行锁的实现是索引锁。 而不是记录锁。 如果查询语句没有通过索引条件检索数据，将会使用表锁 <a target="_blank" rel="noopener" href="https://blog.csdn.net/alexdamiao/article/details/52049993">https://blog.csdn.net/alexdamiao/article/details/52049993</a></p>
<h1 id="126-AQS阻塞的底层原理"><a href="#126-AQS阻塞的底层原理" class="headerlink" title="126 AQS阻塞的底层原理"></a>126 AQS阻塞的底层原理</h1><p>AQS 底层阻塞是调用Locksupport.park  为unsafe.park 开挂起线程</p>
<h1 id="127-如果我一个类里两个方法A和B都进行了代理-那么我在A里面调用B-还会走到B的切面吗"><a href="#127-如果我一个类里两个方法A和B都进行了代理-那么我在A里面调用B-还会走到B的切面吗" class="headerlink" title="127 如果我一个类里两个方法A和B都进行了代理, 那么我在A里面调用B, 还会走到B的切面吗?"></a>127 如果我一个类里两个方法A和B都进行了代理, 那么我在A里面调用B, 还会走到B的切面吗?</h1><p>不会。 里面嵌套调用的是this.do ,没有走代理类</p>
<h1 id="128-389-找不同"><a href="#128-389-找不同" class="headerlink" title="128 389. 找不同"></a>128 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-difference/">389. 找不同</a></h1><p>给定两个字符串 <em><strong>s</strong></em> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p>
<p>字符串 *<strong>t*</strong> 由字符串 *<strong>s*</strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p>
<p>采用异或的方法。</p>
<h1 id="129-Netty"><a href="#129-Netty" class="headerlink" title="129 Netty"></a>129 Netty</h1><h2 id="既有-HTTP-为啥用-RPC-进行服务调用"><a href="#既有-HTTP-为啥用-RPC-进行服务调用" class="headerlink" title="既有 HTTP ,为啥用 RPC 进行服务调用?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC?id=%E6%97%A2%E6%9C%89-http-%E4%B8%BA%E5%95%A5%E7%94%A8-rpc-%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">既有 HTTP ,为啥用 RPC 进行服务调用?</a></h2><h3 id="RPC-只是一种设计而已"><a href="#RPC-只是一种设计而已" class="headerlink" title="RPC 只是一种设计而已"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC?id=rpc-%E5%8F%AA%E6%98%AF%E4%B8%80%E7%A7%8D%E8%AE%BE%E8%AE%A1%E8%80%8C%E5%B7%B2">RPC 只是一种设计而已</a></h3><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>但是，HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h1 id="130Redis-如果单key过热怎么处理"><a href="#130Redis-如果单key过热怎么处理" class="headerlink" title="130Redis 如果单key过热怎么处理"></a>130Redis 如果单key过热怎么处理</h1><p>方法一:凭借业务经验，进行预估哪些是热key</p>
<p>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</p>
<p>方法二:在客户端进行收集</p>
<p>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p>
<p>方法三:在Proxy层做收集</p>
<p>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p>
<p>方法四:用redis自带命令</p>
<p>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如 redis-faina 。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</p>
<p>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</p>
<p>方法五:自己抓包评估</p>
<p>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p>
<p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢。</p>
<h2 id="目前业内的方案有两种"><a href="#目前业内的方案有两种" class="headerlink" title="目前业内的方案有两种"></a>目前业内的方案有两种</h2><p>(1)利用二级缓存</p>
<p>比如利用 ehcache ，或者一个 HashMap 都可以。在你发现热key以后，把热key加载到系统的JVM中。</p>
<p>针对这种热key请求，会直接从jvm中取，而不会走到redis层。</p>
<p>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。</p>
<p>现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p>
<p>(2)备份热key</p>
<p>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</p>
<h1 id="131AoF和RDB是先写日志还是先写内存"><a href="#131AoF和RDB是先写日志还是先写内存" class="headerlink" title="131AoF和RDB是先写日志还是先写内存"></a>131AoF和RDB是先写日志还是先写内存</h1><p>先写内存再写磁盘。  一个是写磁盘慢，会阻塞。另一个是如AOF写指令，先写磁盘会写很多错误指令。</p>
<h1 id="132-Redis主从同步"><a href="#132-Redis主从同步" class="headerlink" title="132 Redis主从同步"></a>132 Redis主从同步</h1><p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003305.jpg" alt="20220122003305"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003309.jpg" alt="20220122003309"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003313.jpg" alt="20220122003313"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003316.jpg" alt="20220122003316"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003319.jpg" alt="20220122003319"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003322.jpg" alt="20220122003322"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003325.jpg" alt="20220122003325"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003328.jpg" alt="20220122003328"></p>
<p><img src="/2022/05/05/%E9%9D%A2%E7%BB%8F/20220122003331.jpg" alt="20220122003331"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/05/%E9%9D%A2%E7%BB%8F/" data-id="cl2rx035z00019og0bzgz2icu" data-title="面经" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/05/05/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/">面试基础</a>
          </li>
        
          <li>
            <a href="/2022/05/09/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/05/05/%E9%9D%A2%E7%BB%8F/">面经</a>
          </li>
        
          <li>
            <a href="/2022/05/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>